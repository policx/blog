{"categories":[{"link":"https://blog.policx.com/categories/news/","name":"news","slug":"news"},{"link":"https://blog.policx.com/categories/notes/","name":"notes","slug":"notes"},{"link":"https://blog.policx.com/categories/program/","name":"program","slug":"program"},{"link":"https://blog.policx.com/categories/software/","name":"Software","slug":"Software"},{"link":"https://blog.policx.com/categories/wwdc/","name":"wwdc","slug":"wwdc"}],"pages":[],"posts":[{"link":"https://blog.policx.com/posts/2020/","text":" Do you want to spend the rest of your life selling sugared water or do you want a chance to change the world?\n你想用卖糖水来度过余生，还是想要一个机会来改变世界？\n  ","title":"WWDC 2020"},{"link":"https://blog.policx.com/posts/linuxdesktop/","text":"本周 Linux 刚刚迎来它的 28 岁生日。自 20 世纪 90 年代初期以来，Linux 桌面也已从简单的窗口管理器发展为成熟、完整的桌面。那么它究竟是如何一步步发展至今的呢？作为从 1993 年就开始使用 Linux 的资深用户，FreeDOS 创始人 Jim Hall 从初代窗口管理器开始，仔细梳理了一遍 Linux 桌面的进化史——\nX 和窗口管理器 Linux 上的第一个\u0026quot;桌面\u0026quot;是在 X Window 系统上运行的窗口管理器。X 为图形用户界面提供了基本构建块，例如在屏幕上创建窗口并提供键盘和鼠标输入。要运行 X 图形环境，用户需要一种方法来管理会话中的所有窗口，这就是窗口管理器的用武之地。运行像 xterm 或 xclock 这样的 X 程序，它们就会在窗口中打开。\n窗口管理器负责跟踪窗口并执行基本的任务管理，例如移动窗口并最小化。剩下的则取决于个人，你可以在通过将 X 列在 ~/.xinitrc 文件中来启动程序，不过通常，用户会从 xterm 运行新程序。\n1993 年最常见的窗口管理器是 TWM，它可以追溯至 1988 年。TWM 非常简单，只提供基本的窗口管理功能。\n▲SLM 1.05 上的 TWM，图中为 xterm、xclock 和 Emacs 编辑器\n另一个早期的窗口管理器是 OpenLook 虚拟窗口管理器（OLVWM）。OpenLook 是 Sun Microsystems 在 20 世纪 80 年代开发的图形用户界面，后来也被移植到其他 Unix 平台。作为虚拟窗口管理器，OLVWM 支持多个工作区。\n▲SLS 1.05 上的 OLVWM，图为 xterm 和 Virtual Workspaces 选择器\n当 Linux 开始普及时，创建一个具有流畅性能和改进界面的新窗口管理器并不需要花费很大力气。这些新窗口管理器中的首个便是 FVWM，一个虚拟窗口管理器。 FVWM 比 TWM 或 OLVWM 更具现代感。当然对于现代人来说，TWM 和 FVWM 可能看起来很平常。\n▲SLS 1.05 上的 FVWM，图为 xterm 和文件管理器\n当时的 Windows 桌面看起来相当简单。 Windows 版本 1 到 3 使用称为\u0026quot;程序管理器\u0026quot;的普通启动程序。\n▲Windows 3.11 上的程序管理器和记事本编辑器\n1995 年 8 月，微软发布了 Windows 95 并改变了现代 PC 桌面环境。在当时，Windows 3.x 看起来是笨拙而丑陋的，Windows 95 显然更为流畅好看。更重要的是，Windows 95 改变了人们对桌面的定义。\nWindows 95 桌面意味着集成。程序管理器消失了，取而代之的是屏幕底部的任务栏，可以使用更简单的\u0026quot;开始\u0026quot;菜单启动新程序。与之前版本的 Windows 甚至其他 Linux 窗口管理器相比，Windows 95 界面更加灵活且易于使用。\n▲Windows 95 上的记事本编辑器\nLinux 开发人员不甘示弱，创建了一个模仿 Windows 95 界面的新版 FVWM，并称为 FVWM95。新的窗口管理器仍然不是桌面，但它看起来比以前好得多。用户可以在任务栏中使用\u0026quot;开始\u0026quot;菜单启动新的 X 程序，任务栏还使用类似于 Windows 95 的按钮显示正在运行的程序。\n▲Red Hat Linux 5.2 上的 FVWM95\n虽然 FVWM95 和其他窗口管理器在不断改进，但核心问题仍然存在：Linux 并没有真正拥有桌面。它只有一系列窗口管理器罢了。\n首个 Linux 桌面 1996 年，Matthias Ettrich 希望将所有内容集成在一起，就像一个真正的桌面一样。于是他开始研究 K 桌面环境（KDE），并于 1998 年 7 月完成。KDE 1.0 比 FVWM95 这样的普通窗口管理器有了明显的改进。\n▲KDE 1.0\nKDE 代表着 Linux 的一大进步，从此 Linux 拥有了真正的桌面应用程序集成和更现代的桌面图标。\nKDE 的设计与 Windows 95 相差无几。它在屏幕底部有一个任务栏，提供了相当于 Windows 95 的开始菜单以及几个应用程序的快捷方式。此外，KDE 还支持虚拟桌面。\n但并非所有人都对 KDE 感到满意。为了从系统中抽象 GUI，KDE 使用了 Trolltech 的 Qt 工具包库。不幸的是，Qt 没有在免费软件许可下发布。Trolltech 允许 Qt 在免费软件应用程序中免费使用，但在商业或专有应用程序中使用它需要付费。这使 Linux 发行版陷入两难抉择：应该包含 KDE 吗？或者默认使用较旧但免费的软件图形用户界面，如 FVWM？\n很快，事情有了新的变化。Miguel de Icaza 和 Federico Mena 于 1997 年开始为新的 Linux 桌面工作。这个新项目被称为 GNOME，用于 GNU 网络对象模型环境。GNOME 旨在成为完全免费的软件，并使用来自 GIMP 图像编辑器的不同工具包，即 GTK（GIMP Tool Kit）。\n当 GNOME 1.0 最终在 1999 年发布时，Linux 又拥有了一个现代桌面环境。\n▲GNOME 1.0\n此后，KDE 与 GNOME 的竞争持续了一段时间。转眼来到 1999 年，Trolltech 根据新的公共许可证——Q 公共许可证（QPL）重新发布了 Qt 库。但新许可证仍然有所限制，QPL 仅适用于 Qt 在开源软件项目中的使用，而非商业项目。因此，自由软件基金会认为 QPL 与 GNU 通用公共许可证（GNU GPL）不兼容。这个许可问题将一直持续到 Trolltech 在 2000 年 GNU GPL 第 2 版下重新发布 Qt 库。\n随着时间的发展 Linux 桌面继续成熟。 KDE 和 GNOME 进入良性竞争状态，互相推动新的发展。到 2004 年，GNOME 和 KDE 都取得了重大进展，但只对用户界面进行了增量更改。\nKDE 2 和 3 继续依赖于屏幕底部的任务栏概念，但包含了用于运行应用程序的按钮。KDE 最明显的变化之一是增加了 Konqueror 浏览器，它最初出现在 KDE 2 中。\n▲KDE 2.2.2 （2001）\n▲Fedora Core 2 上的 KDE 3.2.2（2004）\nGNOME 2 也使用了任务栏概念，但它将栏分成两部分：屏幕顶部用于启动应用程序并响应桌面警报，页面底部显示正在运行的应用程序。除了简化的用户界面外，GNOME 还添加了一个名为 Nautilus 的文件管理器，由 Eazel 开发。\n▲Fedora Core 2 上的 GNOME 2.6.0（2004）\n随着时间的推移，KDE 和 GNOME 采取了不同的发展路径。两者都提供功能丰富、强大且现代化的桌面环境，但它们具有不同的用户界面目标。2011 年可以说是 GNOME 和 KDE 的分水岭。KDE 4.6（2011 年 1 月）和 KDE 4.7（2011 年 7 月）提供了更为传统的桌面，同时继续依赖许多用户熟悉的任务栏概念。从外观上来看，KDE 并没有什么太大的变化。\n▲KDE 4.6\n另一边的 GNOME 则在 2011 年通过新的桌面概念完全改变了方向。 GNOME 3 旨在创建更简化的桌面体验，使用户能够专注于他们正在进行的工作。任务栏消失，取而代之的是屏幕顶部的黑色状态栏，其中包括音量和网络控制，显示时间和电池状态，并允许用户通过重新设计的菜单启动新程序。\n▲GNOME 3.0\n选择合适的桌面 有人喜欢 KDE，有人喜欢 GNOME，选择最适合自己的就好。可以肯定的是，KDE 和 GNOME 都有批评者和支持者。这其中最著名的批评者也许是 Linus Torvalds，他在 2011 年大声谴责 GNOME 为 \u0026ldquo;unholy mess\u0026rdquo; 并放弃了它，两年后却又再度回归。\n其他不少人对 GNOME 3 也提出了类似的批评，以至于一些开发人员将 GNOME 2 源代码分叉并创建 MATE 桌面。MATE 继承了 GNOME 2 的传统任务栏界面。\n无论如何，毫无疑问，今天最流行的两个 Linux 桌面是 KDE 和 GNOME。它们目前的版本都非常成熟，并且功能丰富。KDE 5.16（2019）和 GNOME 3.32（2019）都试图简化 Linux 桌面体验，不过是以不同的方式。GNOME 3.32 继续瞄准最简洁的外观，删除所有令人分心的用户界面元素，以便用户可以专注于应用程序和工作。而 KDE 5.16 仍旧采用了较为熟悉的任务栏方法，但增加了其他视觉改进，特别是改进了图标和小部件处理。\n▲KDE 5.6\n▲GNOME 3.32\n每个主要的 Linux 发行版都提供兼容性库，因此兼容性不会丢失，用户可以在 GNOME 上运行 KDE 应用程序，反之亦然。\nKDE 和 GNOME 之间的良性竞争使两个阵营的开发人员都能够不断突破，这是一件好事。无论你使用的是 KDE 还是 GNOME，你都拥有一个集成度很高的现代化桌面。\n最重要的是，这意味着 Linux 拥有自由软件中的最佳功能：选择。\n本文译自：opensource.com\n   原文链接\n👇         ","title":"Linux 桌面进化史"},{"link":"https://blog.policx.com/posts/knowledge/","text":"作者简介： 豌豆花下猫，生于广东毕业于武大，现为苏漂程序员，有一些极客思维，也有一些人文情怀，有一些温度，还有一些态度。公众号：Python猫\n一、缘起 前不久，我在翻译 Guido van Rossum（Python之父）的文章时，给他留言，申请非商业用途的翻译授权。\n过程中起了点小误会，略去不表，最终的结果是：他的文章以 CC BY-NC-SA 4.0 许可协议进行授权。部分对话如下：\nCC 协议是一种授权许可协议，我曾看到过几次，但了解不多，所以便查阅了相关的内容。\n本文主要是作个记录，既是加深自己的理解，也给有需要的同学一个参考。\n二、著作权、著佐权与自由版权 对于知识产权，通常有如下几种说法：\n All Rights Reserved（保留所有权利） Some Rights Reserved（保留部分权利） All Rights Reversed（撤销所有权利）  注意最后一条的\u0026quot;Reversed\u0026quot;，它长得很像\u0026quot;Reserved\u0026quot;，但意思截然相反。\n它们对权利的诉求由强转弱，从一个极端走向另一个极端。\n有几个与此相关的概念：\n copyright，即版权、著作权 copyleft，即著作传、著佐权 copywrong，即反版权、自由版权  版权制度起源于十五世纪中期，那时西方发明了铅活字印刷术（古登堡，现代印刷术之父），出现了大量盗版，为了保护出版商的利益，政府出台了版权法。\n此后版权法在世界各地普及，演化出了很多门类，它们普遍限定了一个有效期限，在此期限内，版权方受到垄断保护（即 All Rights Reserved ）。超出期限后，知识作品才会进入公共领域（public domain），才变成自由版权。\ncopyright 是一种限制性协议，有利于保护版权方的个体权益，但是也阻碍了知识作品的传播，不利于社会的公共利益。\n我们经常会听到一个词\u0026quot;专利流氓\u0026quot;，说的就是版权被过度使用而造成的社会问题。举个例子，某家商业公司竟然曾\u0026quot;拥有\u0026quot;国旗国徽的版权。\ncopyleft 则是一种较为宽松的协议，对应的思想是 Some Rights Reserved（保留部分权利），使用者只要遵守少数的列明条款即可。\ncopyleft 之所以会译作\u0026quot;著作 传 \u0026ldquo;，因为有\u0026rdquo; 减少屏蔽，自由流传 \u0026ldquo;之义。\n另外还翻译为\u0026quot;著 佐权\u0026rdquo;，也是一字之差，跟英文原词神似，非常有趣。\n最后还有一个 copywrong（还有类似的\u0026quot;copyfree\u0026quot;、\u0026ldquo;copycenter\u0026quot;叫法），它属于另一个极端，无视版权，无拘无束。\ncopyleft 与 copywrong 都是对 copyright 的某种矫正，只是矫正的力度不同，总体而言，它们的目的都是促进知识作品的传播，增进整体的社会利益。\n在互联网时代，它们随处可见（可能不直接用这些叫法），极大地促进了自由软件与开源社区的发展。\n上图中的 6 种主流的开源许可证，你应该有所耳闻吧，在我们免费使用的各种软件或代码库中，很可能就藏着它们的身影。\n右侧的 3 种（BSD、MIT、Apache）属于宽松式许可证（permissive license），对使用者几乎没有限制，接近于极端的 All Rights Reversed（撤销所有权利）。\n左侧的 3 种（LGPL、Mozilla、GPL）则属于 copyleft 许可证，仅保留了少数关键的权利，此外不予限制。\n三、知识共享许可协议 经过一段简要的铺垫，几个概念算是讲清楚了，接着看 Python 之父在本文开头所提到的那种许可协议吧。\nCC 也是 copyleft 的一种，全称为 Creative Commons license ，译作 知识共享许可协议 ，发布于 2002.12.16，目前已发展到 4.0 版本。\n 官网地址：https://creativecommons.org/licenses\n CC 协议是一个统称，它有不同的实指，区别在于所保留的权利不同。\n它声明的基本权利有 4 种：\n 署名（Attribution，简写 BY）：注明原作者 相同方式共享（ShareAlike，简写 SA）：允许演绎，但需以相同许可协议发布 非商业性使用（Noncommercial，简写 NC）：不得用于商业目的 禁止演绎（No Derivative Works，简写 ND）：不得演绎，也作\u0026quot;非衍生\u0026rdquo;  （注：还有一些基本要求，例如，使用者不可添加法律条款或技术手段来限制别人的合理使用。限于篇幅，这些内容就不多介绍了，详见官网。）\n按照是否保留某项权利，它们可以排出 16 种组合，其中 4 种因为同时包含\u0026quot;SA\u0026quot;与\u0026quot;ND\u0026quot;，互斥而无效，还有 5 种不要求署名，基本没人使用。\n所以，只有 7 种常用的 CC 协议：\n上图只列出了 6 种，还有 1 种特殊的是 CC0 协议，它不要求任何权利，是\u0026quot;No Rights Reserved\u0026quot;，无版权要求，属于自由版权。\n这些协议被广泛用于各类互联网产品中（主要是网站、视频、图片或文章），例如：\n CC0：Pexels图片、Unsplash图片、SoundCloud音乐 CC BY-SA：维基百科内容、Stack Overflow内容 CC BY-NC-ND：TED 演讲视频 CC BY-NC-SA：可汗学院视频、斯坦福公开课视频  很多个人网站或文章，基本采用了\u0026quot;CC BY-NC-ND\u0026quot;或者\u0026quot;CC BY-NC-SA\u0026quot;之一。Guido 最初给我回复的是 ND 这种，后来才澄清为 SA。\n这几种权利中，BY（署名）是不言而喻的，也就是我们常见的\u0026quot;转载时请注明作者和出处\u0026quot;，体现了对于原作者的最起码的尊重。\n另外的 3 种权利，值得再细细地辨析一下：\n SA/ND，是否允许演绎。演绎包括\u0026quot;再混合、转换或基于该作品创作\u0026quot;，基本可概括为不允许改动原作品，而且不允许翻译（这点很关键） NC，非商业用途。什么算是商业用途呢？官方笼统地概括为\u0026quot;出于商业利益或金融补偿\u0026quot;的用途，还说这取决于具体情况和使用者的意图  四、关于翻译的几个问题 本文缘起于翻译，快结束了，我再补充几个跟翻译相关的问题吧，并附上我的理解。\n1、翻译别人的文章会导致侵权么？ 翻译权是著作财产权的一种，属于著作人所有，它的基本含义是：著作权人享有自行翻译其作品和允许他人翻译其作品的权利。所以，未经作者授权或者许可的作品，就不要翻译了，翻译了也不应发布，否则就侵权了。\n2、CC 协议下的作品可自由翻译么？ 如果作者许可的是 ND，即禁止演绎，那么，该作品是不允许被翻译的；如果许可的是 SA，即是允许翻译，但注意需\u0026quot;以相同方式共享\u0026quot;，即翻译后的作品需支持他人继续作出演绎；其它情况，对翻译行为不作约束。\n3、译者对翻译的作品拥有版权么？ 根据我国《著作权法》第十二条所述：\n 改编、翻译、注释、整理已有作品而产生的作品，其著作权由改编、翻译、注释、整理人享有，但行使著作权时不得侵犯原作品的著作权。\n 即在不侵犯原作版权的前提下，翻译作品的版权归译者所有。\n4、翻译的作品算是原创么？ 从狭义的概念上看，翻译属于二次创作、属于衍生、其\u0026quot;灵魂\u0026quot;是由原作品所赋予的，所以不能算是原创。原创应指独立创作、全新发明，所以在此含义上看，翻译不算是原创。\n但是，还有一种具体的情境，例如在公众号发文时标注的\u0026quot;原创\u0026quot;，此原创并非是要作概念上的区分，而是要保护作者的版权，防止文章被人侵权转载（甚至是被抢去标注原创），在此情境下，我认为可以标\u0026quot;原创\u0026quot;（有\u0026quot;翻译\u0026quot;标记就更好了）。\n所以，综合来看，翻译作品不是原创，但在特殊情况下，又可以是\u0026quot;原创\u0026quot;。\n5、如何理解非商业用途呢？ 维基百科对于商业行为概括有 4 个要点：（1）以营利为目的（2）发生交易行为（3）出于双方自愿（4）符合法律规范\nCC 协议所约定的 NC 条款，应参照如上解释。所以，基于 NC 条款许可的翻译作品，不应用于知识付费，也不应用于其它买卖交易，此外， 一般而言， 捐助或者赞赏等行为都不算是商业用途，则不受此限制。\n   原文链接 👇          ","title":"关于知识产权、知识共享与文章翻译"},{"link":"https://blog.policx.com/posts/2020dev/","text":"比较编程语言是一件非常复杂的事情，所以有许多图形插图/笑话试图象征编程语言 。\n我发现很少，我正在开始这篇文章。\n简单来说， 编程语言使人类能够指导和控制机器。 因此，很自然会有这么多语言试图使这个过程更加强大和简单。 由于这个原因，有数百种编程语言 ，其中许多编程语言现在已经不再使用，很少有将在未来几年过时，然后有一些语言将继续并证明其在未来几年的使用和然后有新的编程语言争取接受。\n本文将介绍顶级编程语言的趋势，这些趋势将在2020年继续。 为了预测2020年 编程语言的趋势，本文根据编程语言使用来自真实调查 ，各种收集的统计数据 ，搜索结果和薪资趋势的数据。 本文将帮助新学习者选择一种编程语言进行学习和专家学习，这将有助于决定切换到另一种语言或继续使用他的专业语言。\n在下一节中，我准备了两个表，总结了过去五年（2015-19）中编程语言的流行趋势。 该数据来自2015 - 19年的 Stackoverflow 人气调查 。 为了清楚准确地理解，编程语言分为两组，第一组是 2000 年以前诞生的语言，第二组是 2000 年以后诞生的语言。 选择2000作为边界只是随机的，但对于理解这两组的编程趋势非常有帮助。 该表还列出了这些编程/脚本语言的起源年份和主要或记录的目的。\n    语言  起源 2015年  2016 2017年  2018  2019 主要目的     Javascript 1995年 54.4％ 55.4％ 62.5％ 71.5％ 67.8％ Web开发，动态内容，客户端和服务器端   Java 1995年 37.4％ 36.3％ 39.7％ 45.4％ 41.1％ 企业应用   Bash/Shell 1971年至1979年   -  -  - 40.4％ 36.6％ 自动化和系统管理员   Python 1991年 23.8％ 24.9％ 32.0％ 37.9％ 41.7％ 一般用途   PHP 1995年 29.7％ 25.9％ 28.1％ 31.4％ 26.4％ Web开发，服务器端   C ++ 1980至1983年 20.6％ 19.4％ 22.3％ 24.6％ 23.5％ 一般用途   C 1972年 16.4％ 15.5％ 19.0％ 22.1％ 20.6％ 通用，低级编程   Ruby 1995年 8％ 8.9％ 9.1％ 10.3％ 8.4％ Web开发   R 1993年  -  - 4.5％ 6.0％ 5.8％ 统计计算   Objective-C 1986年 7.8％ 6.5％ 6.4％ 7.3％ 4.8％ 一般用途    观察：\n除了Python之外，从2018年到2019年所有语言的流行度都在下降。\nPython Python是自过去五年以来不断上升的唯一语言。 它是一种通用语言，因此有人希望在2020年只学习一门编程，并希望涵盖更多的软件开发领域，然后可以选择Python 。\nJAVA Java正在上升但在2019年下降，原因是Kotlin在Android平台上获得了普及。 Java是编程语言的一个很好的选择，但现在它在Oracle下面 ， 谷歌正在推广Kotlin，因此它处于冲突区域。 事实上，由于其开发人员基础，框架和遗留应用程序，大量公司正在使用Java并继续使用Java 。\nC / C ++ C和C ++仍然保持着大约20％，并且由于其固有的功能和遗留系统，它将会存在。\nJAVASCRIPT JavaScript受欢迎程度可归因于流行的JavaScript库和node.js等框架的增长.JS是动态网站的语言，由于其积极的开发， Mozilla的支持和惩罚，它将成为未来几年的首选。 图书馆和框架 。 所以，如果有人想要进行Web开发，那么javascript是必须的。\nR R近年来越来越受欢迎，原因在于数据分析的增长和普及。 它被数据科学家使用，但与Python相比，它已经成为通用语言，并且拥有大量数据科学库和模块的活跃开发人员。 因此，如果他们必须只选择其中一个，那么人们可以更喜欢Python而不是数据科学中的想要载体，那么学习两者都是一个不错的选择。\nRuby 与PHP一样， Ruby也面临来自JavaScript甚至Python的激烈竞争，以建立后端Web开发编程语言。 所以，再次对于web开发javascript和Python （服务器端（Flask，Django等）将是一个不错的选择，并将提供比Ruby更多的域灵活性。\nPHP 在2019年 ， PHP流行度急剧下降，这可以追溯到服务器端对javascript和Python的接受程度。 因此，如果有人想要进行服务器端Web开发，那么PHP仍然是一个很好的选择，有大量流行的框架，如CakePHP ， Codeigniter等，否则选择通用编程语言会更好。\nOBJECTIVE-C 在Apple迁移到Swift语言之前， Objective-C是Apple软件（如MacOS ， iOS等）的主要语言。 因此，这种转变反映在两种语言的流行中，即Objective-C的受欢迎程度下降，而Swift的普及正在上升。 所以，如果有人想成为Apple产品的开发者，那么Swift应该是首选语言。\n观察：\nSwift Swift取代了Objective-C作为Apple相关软件和应用程序的主要语言。 由于苹果公司支持和推广它，因此自成立以来受欢迎程度越来越高，而Apple将继续使用它，所以如果有人正在寻找特定于Apple的开发平台，那么Swift将成为一种必须知道的编程语言。 这主要是供应商和产品特定的语言，在Apple的生态系统之外使用率非常低。\nGo Go（Golang）越来越受到Google的维护，使用和推广。 Go开发的动机是解决对一些流行语言的批评，并在一个地方保持最佳状态。 自2017年以来， Go的受欢迎程度越来越高，并且在谷歌的支持下，它将在未来几年内享受到这一点。 谷歌也将Go作为新项目的主要语言并用Go取代其他语言，这种趋势在未来几年将变得有用和重要，因此人们可以选择Go作为一种新的编程语言。\nKotlin Kotlin作为Android开发的Java的替代品而被提供，并且它再次得到Google的支持和推广，因此近年来它也受到开发人员的欢迎并越来越受欢迎。 因此，随着Android的增长， Google的支持以及简洁的语法，它将成为Android 应用程序 开发人员的一个选择，是学习Android App 开发人员的不错选择。 Kotlin将成为Android 开发的杰出编程环境。\nScala Scala试图建立Java的替代品，但在开发人员中并没有得到很好的解决。 它没有来自任何跨国公司的大力支持，认为功能语言和对JVM的依赖并没有提供太大的普及范围。 可能会有稳定的增长，但速度很慢，而且肯定不是一种初学者学习的语言。\nJulia Julia旨在提高“C”的速度和Python的简单性，但奇怪的是，在Stackoverflow 调查中没有发现任何受欢迎程度，但在数据科学领域受到欢迎，并且从长远来看被视为R和Python的挑战者。 当然，朱莉娅会有增长，但仍然， Python或R更适合工作和成长。\nC＃ C＃是.NET框架的语言，由Microsoft开发。 它的受欢迎程度在过去几年中基本保持不变，并将继续保持类似的趋势。 这是特定于供应商的语言，因此如果想要在Microsoft开发环境中工作，可以选择此语言。 最近， 微软已开源.NET，因此会出现一些上升趋势，但它又是特定于供应商的，因此不会受到太大影响。\nRUST Rust ， Clojure等是具有用户基础但不那么流行的语言，所以肯定不会有人气的上​​升。\n 一张图片说千言万语 要了解顶级编程语言增长的明显趋势和图景，请通过各种图表来了解它。 图1和图2给出了一个非常清晰的图景，即在旧的语言堆栈中， JavaScript远远领先于其他人，并且信用在网络开发中占据了一席之地，然后C和C ++一起竞争非常接近Java 。 Python在受欢迎程度上越来越高，而且在过去的5年里，只有人气不断增加的语言。 新语言越来越流行，其中大多数语言都受到跨国公司以及微软 ， 谷歌和苹果等IT巨头的支持。\n喜欢和想要的语言 从上面的表格和图中，很少有观察结果非常明显，Love of Rust在过去五年中正在增长，而Swift正在失去开发人员的热爱，而Python正处于这两者之间，过去两年中Python已经获益。 另一个独特的观察结果是，5种喜爱的语言中有4种来自2000后的群体，而只有Python是较旧的语言，而Kotlin的爱则是从2017年开始为Android 开发添加Kotlin开始的。\n从上表可以看出， javascript和Python开发的愿望在过去几年中不断增长，这反映了人们对语言的热爱和热爱。 Java的数量急剧下降，这是因为Kotlin作为Android应用程序开发的替代品，以及现在拥有Java的Oracle改变了政策。\n技术和编程语言 在这个图中，可以看到最大的集群用于Web开发和JavaScript ，其各种框架主导着集群，这是JavaScript增长的USP 。 第二大集群是Microsoft 技术和Python 技术 ，它再次清除了对该语言的欢迎和热爱。 Python集群与数据科学技术相关联，这些技术突出了Python的增长故事。\nTIOBE 指数 TIOBE索引排名编程语言基于搜索引擎搜索结果 。 搜索引擎和编程语言的选择在其页面中定义。 通过计算最受欢迎的搜索引擎的点击来计算评级。 使用的搜索查询是+“ programming”。 在TIOBE索引中， Java在过去二十年中占据主导地位，其中C在过去30年中一直保持着第一和第二的位置。 在过去的二十年里， Python已经走过了漫长的道路，即1999年的第24位，到2019年的第3位。如果有人合并C和C ++，那么它将永远占据第一的位置。\n在新的语言（2000年后）中， Rust的排名上升，即从第33位升至第28位， Julia从第50位升至第39位。 值得注意的是， Kotlin似乎并未接近前20名。\n编程语言（PYPL）索引的流行程度 PYPL索引是通过分析在Google上搜索语言教程的频率创建的。 搜索语言教程越多，该语言就越受欢迎。 这是一个领先的指标。 原始数据来自Google趋势。\n下图验证了前3种语言是Python ， Java和JavaScript 。 C＃，PHP，C / C ++也是安全的顶级位置，这种趋势再次类似于堆栈溢出和TIOBE索引 。 上图显示，在新的编程语言中，即2000年后的Kotlin ， Go ， Rust和Julia在排名中上升。\n就业市场与薪酬 薪酬取决于产品的地理区域和需求，基于编程语言的薪资比较只是预测或估计薪资趋势的工具。 我们根据流行调查的编程语言汇总了工资，即2018年的Dice薪资调查和2018年和2019年的Stack-overflow调查。\n从上表可以看出，从这两项调查中可以看出， Go/Golang 在市场上是一项薪酬非常高的工作，在2019年的Stack-overflow调查和2018年Salary Survey薪资调查中 ，甚至在高薪工作中排名第一。 现在，原因很简单， Go是谷歌支持的语言，主要用于谷歌和谷歌想要推广这种语言，所以高薪可以连接到谷歌工资单。 有一点很清楚，价格弹性是一个经济术语，它提供了不同的场景，例如产品数量增加，价格，奢侈品和品牌产品成本，高产品可用性降低了价格。 很明显，全球平均工资不是选择语言的好选择。 例如，一种接近灭绝的编程语言，但遗留系统很少，因此维护这些公司往往提供非常高的薪酬，但这些语言中的职位数量总是很少。 在其他情况下，主流语言提供了大量的工作岗位，因此平均工资下降。\n因此，作为结束语，很容易预测语言趋势，但只选择一种语言来学习是一个非常困难的选择，完全取决于个人选择和他们未来的计划，例如，如果你想在Web开发中工作不能忽视Javascript ，如果你想使用Apple的产品你现在不能忽视Swift ，如果你的品味是系统级编程，那么C和C ++是你的朋友， Python让你在很多领域跑得更快，目前亲爱的数据科学 。 您会看到每种语言都会带您踏上不同的旅程。 选择目的地，然后使用该路径的语言进行驾驶。\n-END-\n   转载声明：本文转载自「编码无限」         ","title":"2020年顶级编程语言的统计数据和调查结果如何？"},{"link":"https://blog.policx.com/posts/five_a/","text":"上个月，我们曾报道过一篇\u0026quot;Dice 称这 5 种编程语言可能衰落\u0026ldquo;的文章，它基于 RedMonk 和 TIOBE 等公司的数据推测的，结果引起了广泛讨论。Dice Insights 是为北美的科技专业人士提供见解和分析的网站，目的是帮助他们找到工作和发展事业，并且报道就业趋势、新技术等内容。经过了半个月，Dice 依靠更大的数据趋势来做出预测，又发布一个更大胆的预测续集，关于 5 种在未来可能会有更多使用的编程语言。\nSwift 苹果想要放弃 Objective-C，它是一种有着 35 年历史的编程语言，用于为苹果生态系统构建应用程序。苹果想让 Swift 来取代它，Swift 发布与五年前。根据分析公司 RedMonk 的长期语言排名，Swift 自创建以来的使用量迅速上升。\n虽然如此，但 Objective-C 仍然有在使用，这主要归功于过去三十年中产生的大量遗留代码（legacy code）。不过，苹果已经不会对它抱有任何期待，Swift 才是为苹果的应用程序提供动力的主打语言，苹果在跨平台应用上只可能会加速这门编程语言的发展。\nKotlin Kotlin 正在上升。Kotlin 来源于一个岛屿的名字，全称是 Kotlin Island，是英语「科特林岛」之意，十年前，Kotlin 还是俄罗斯岛屿，现在它变成编程语言，JetBrains 公司开发了它，不过它受关注的原因，很大程度上归功于 Google，Google 将它作为 Android 的一流开发语言。\n可以说，通过选择 Kotlin，Google 减少了对 Java 的依赖。而且 Java 与 Oracle 发生了巨大法律纠纷，但是不管谷歌的律师是否在推动该公司对 Kotlin 的支持，毋庸置疑的一点，因为它的功能和灵活性，许多开发人员也开始喜欢这种语言。\n早在 2018 年，Pusher 就发起了一项开发人员调查，发现 Kotlin 的使用量正在天文数字般的增长，这很大程度上是因为 Android。Pusher 补充说明：\n 很大一部分开发人员，他们的工作和其他项目的程序，使用的是 Kotlin。大多数人都喜欢使用它，因为它的特性，80% 以上的开发人员都喜欢它的空安全性，其次是扩展函数、与 Java 的简化互操作性和数据类。\n  对 Kotlin 来说，除了安卓开发之外似乎无路可走了。所以它的最大的问题是，是否能超越 Android 生态系统而开拓新的领域。\nPython Python 是一种强大的语言，为世界各地的开发人员提供了多种用途。但是根据 TIOBE 指数(每月更新一次)，Python 的排名还在继续攀升。并且开发人员和技术专业人员也不断发现 Python 的新用途，包括数据分析和机器学习。\nPython 现在也已经有了庞大的用户基础，并且它深深地嵌入到了众多的业务中，所以 Python 不太可能在短期内消失。唯一的问题是这种编程语言还能够持续增长多少，以及它接下来将还能抓住哪些行业。\nGroovy Groovy 有广泛的 IDE 支持、与 Java 的相似性以及与流行的开源自动化服务器 Jenkins 的集成支持下，在 TIOBE 的排名是上升的。它已经成为相当多的系统中的\u0026quot;编程语言粘合剂\u0026rdquo;，它的未来似乎是光明的。\nTypeScript TypeScript 是 JavaScript 的一个超集，一些开发人员认为它不是一种\u0026quot;完整\u0026quot;的语言，因为它可以转换到 JavaScript。但不管如何说它，RedMonk和 GitHub （如下图，上升至第七名）的十月报告 TypeScript 排名都是严重上升的。去年夏天，TIOBE 就表示，TypeScript 已经开始侵吞 JavaScript 的市场份额。\n不管你是否相信，TypeScript 是一种新的、改进的 JavaScript，它将取代这个更老的语言，而且许多技术专业人士认为 TypeScript 在未来几年里还有发展的空间。\n   原文链接\n👇         ","title":"Dice 称这  5 种编程语言未来可能各自成王"},{"link":"https://blog.policx.com/posts/five_b/","text":"Dice Insights 是为北美的科技专业人士提供见解和分析的网站，目的是帮助他们找到工作和发展事业，并且报道就业趋势、新技术等内容。\n根据 Dice 报道，并不是所有的编程语言都永远存在，因为新一代的开发人员会接受他们觉得更容易使用的其他语言和框架。为了确定哪种编程语言可能在中长期内注定失败，他们查看了 TIOBE 和 RedMonk 的受欢迎程度排名，以及 Dice 自己的职务公告数据库。列出以下语言：\nRuby 很久以前，Ruby 很受欢迎。这是 Tiobe 月刊上的前十名语言，开发人员称赞它学习起来有多么容易。但是在过去的 18 个月里，Tiobe 的排名从第 9 位下降到了第 12 位。\n另外发现，对 Dice 过去一年发布的招聘数据的分析显示，寻找精通 Ruby 的技术专业人员的公司数量大幅下降。2018 年，Ruby 的就业数量下降了 56%。这是一个巨大的警告信号，表明很多公司正在放弃 Ruby，如果是这样的话，该语言的用户基础可能会迅速减少到几乎一无所有。\nHaskell 据说，Haskell 即将在 2020 年进行重大更新。有很多巨头公司和项目（Facebook、GitHub 等）曾经使用 Haskell 开发过一些重要项目。不过，Haskell 在 RedMonk 语言排行榜上的表现一直很平淡，这表明没有更多的开发者在关注这门语言。这意味着它正在死亡还是完全死了？\nObjective-C 苹果的 Object-C 已是 35 岁，很明显，苹果公司想让它自生自灭了。五年前，苹果公司的高管们登上舞台，为其软件生态系统推出 Swift，这是一种新的、经过改进的编程语言。毫无疑问，开发者会很快接受 Swift。\n公平地说，更多的开发人员已经开始使用 Swift (特别是在功能变得更加丰富的情况下)，但是 Object-C 并没有像一些人所期望的那样在流行语言排名中崩溃，可能只是许多开发人员更喜欢使用他们一直使用的语言。\n不过，到某一时刻，Object-C 很可能会完全消失。Swift 正在成为一种非常有效的语言，用于构建 iOS、MacOS 和不久的跨平台应用程序。\nR 早在当时，R 是一种越来越流行的数据分析语言。然而，Python 似乎正在迅速吞噬 R 的市场份额。尽管 R 仍然被学者和数据科学家所使用，但对数据分析感兴趣的公司正转向 Python，因为它的可伸缩性和易用性。因此，R 降低了 TIOBE 的编程语言流行指数，而其他研究显示，R 的使用率下降缓慢，有利于 Python。\n如果 R 要以任何形式存在，那是因为数据分析人员可能最终会将其与 Python 结合使用。首席技术官 Enriko Aryanto 今年早些时候对 Dice 表示（他是加州红木城(Redwood City)的联合创始人之一，总部位于加州的匡蒂明德是一家智能营销数据平台）：\n 把 R 和 Python 结合起来既合理又可行，我们在内部数据科学平台上运行它们，但如果我今天要重新开始我的职业生涯，我可能会考虑专注于 Python 而不是 R。它是一种更通用的语言，有更广泛的应用程序。\n Perl 即使 RedMonk 的 Perl 受欢迎程度下降，考虑到仍然有大量的遗留网站使用它的代码，该语言还需要很长一段时间才能完全变平。尽管如此，开发人员普遍支持其他语言，比如构建网站，这意味着 Perl 将陷入越来越多的废弃状态。\n在本文的早期版本中，我们说过 Perl 几乎没有活跃的开发。正如一些有帮助的评论者指出的那样，事实并非如此：它每年更新一次。然而，鉴于它在 RedMonk 和 TIOBE 上的衰落，他们仍然认为这是一种衰落的语言。\n   原文链接\n👇         ","title":"Dice 称这 5 种编程语言可能衰落"},{"link":"https://blog.policx.com/posts/%E5%96%84%E7%94%A8%E4%BD%B3%E8%BD%AF-%E6%8B%96%E6%94%BE/","text":"个人惯用 Mac 拖放，但每每身边同事看我的操作习惯，都大惊失色，感叹 Mac 还有这种操作，所以决定单独讲一篇 Mac 拖放。\nMac的拖放几乎是全局的，比如你可以将图片文件从应用拖到 Finder，同样可以将文件从 Finder 拖至应用内，甚至从应用A拖拽至应用B。\n总之，基于 Finder 的文件拖拽，让系统和应用、应用和应用协同起来，大大提速。以下是一些示例。\n 应用-\u0026gt;Finder\n 1.微信-\u0026gt;Finder 2.浏览器-\u0026gt;Finder 出于版权安全的考虑，以及前端技术的极速革新，部分网站已不再支持将图片拖拽至 Finder，但多数网站仍然支持。\n3.PDF-\u0026gt;Finder 如果你只需要 PDF 20P中的1P，可以单独拖拽至Finder。\n Finder-\u0026gt;应用\n 1.Finder-\u0026gt;微信 2.Finder-\u0026gt;办公套件 3.Finder-\u0026gt;PDF  应用-\u0026gt;应用\n 1.浏览器-\u0026gt;微信 2.微信-\u0026gt;办公套件 除了以上\u0026quot;应用-\u0026gt;Finder，Finder-\u0026gt;应用，应用-\u0026gt;应用\u0026quot;几种拖放，Mac 还有其他很多地方支持此操作，比如文件拖拽至垃圾桶、应用拖拽至Docker、文件拖拽至 Docker 上应用图标即可打开……\n使用拖拽，还是复制粘贴，或是通过各个应用的菜单完成操作，都没什么问题，如果你知道了 MacOS 的一项新能力，不妨试试。\n   原文链接\n👇         ","title":"「拖放」Mac 的底层能力，也是效率神技"},{"link":"https://blog.policx.com/posts/python-mind/","text":" 推荐：XMind 一个全功能的思维导图和头脑风暴软件。\n Python应用领域和数据结构 *点击图片查看原文  \nPython 系列 (一) 核心知识 *点击图片查看原文\n核心知识 \n计算机基础 \nPython语言基础 \n标准数据类型(一)数值字典集合 \n标准类型补充 \n标准数据类型(二)序列对象 \n标准数据类型(三)字符串 \n条件循环 \n【进阶】条件循环 \n函数模块 \n【进阶】函数 \n模块 \n面向对象编程 \n【进阶】面向对象编程 \n【进阶】补充知识 \n文件对象 \n异常处理 \n测试调试 \nPython系列 (一) 基础编程 *点击图片查看原文\n基础编程 \n基础知识 \n基础知识2 \n数据类型 \n序列 \n字符串 \n列表元组 \n字典集合 \n条件循环 \n文件对象 \n错误＆异常 \n函数一 \n函数二 \n模块 \n面向对象编程 \nPython系列(二)常用标准库及拓展知识 *点击图片查看原文 \n标准库概述 \n正则表达式 \n日期 \u0026amp; 时间 \n系统 \u0026amp; 文件 \n进程 \u0026amp; 线程 \n数据库操作 \n数学运算 \u0026amp; 数据结构 \nPython 爬虫 *点击图片查看原文\n基础知识 \nRequests \nBeautifulSoup \u0026amp; urllib \nScrapy \n","title":"Python导图"},{"link":"https://blog.policx.com/posts/python3-notes01/","text":"写于开始之前 笔者即将开始写一个系列的《Python札记》。本系列的札记主要是自学齐伟老师《跟老齐学Python轻松入门》一书整理而来。书第一遍断断续续花了5个月，第二遍边看边整理，保守3个月。\n在此深深感谢齐伟老师带我入门Python。工欲善其事，必先利其器，本札记的学习环境为：Python3.7.2 + pycharm + jupyter notebook：\n Python3取代了Python2，成为主流 针对Python语言，Pycharm是最好的IDE Jupyter notebook是利用Python进行机器学习的强大利器  本札记一定会在2个月之内完成，主要内容包含：\n 学习笔记整理 代码实战练习 各种练习题 利用Python实现常用算法 机器学习_Python算法  希望对Python感兴趣的朋友有所帮助，自己也在努力学习中，将来主要方向是：机器学习+数据挖掘+量化投资\n良好的开始是成功的一半！Let`s go go go!!!   列表是Python中使用非常广泛的一种对象，用方括号[ ]来表示。括号里面可以是数字，字符串或者True，False的布尔值，或者是多种不同类型的对象，里面也可以嵌套列表。如果列表是空的，用bool()来进行判断，会返回 False。\n  一、索引、切片、反转 列表和字符串一样，都是序列，里面的元素是有序的，也有索引和切片。索引index左边从0开始，右边从-1开始，index()函数可以查看某个元素的索引编号。\n索引\n 左边0开始，右边-1开始 通过index()函数查看索引编号  1 2 3 4 5  # lang = [\u0026#39;python\u0026#39;, \u0026#39;java\u0026#39;, \u0026#39;html\u0026#39;] # lang.index(\u0026#39;python\u0026#39;) 0 # 索引从0开始 # lang.index(\u0026#39;html\u0026#39;) 2   切片\n 索引左边从0开始，右边-1开始 含头不含尾 步长可正可负  1 2 3 4 5 6 7 8 9 10 11 12 13  lst = [1, 2, 3, 4, 5, 6] print(lst[:]) # 相当于是复制 lst [1, 2, 3, 4, 5, 6] print(lst[::2]) # 步长是2 [开始:结束:步长] [1, 3, 5] print(lst[-3:-1]) lst = [1,2,3,4,5,6] print(lst[1:5:2]) # 常规用法 print(lst[-5:-2:2]) # 标号-5代表的是元素2，标号-2代表的是5，步长为2 print(lst[-5:4:2]) print(lst[1:-2:2]) [2,4]   反转\n 通过步长-1进行反转，[::-1] 通过reversed()进行反转，得到的是可迭代对象，并且将迭代对象转为为列表显示  1 2 3 4 5 6 7 8 9 10 11 12  # 反转1 print(lst[::-1]) # 通过步长为-1进行反转 print(lst) # 不影响原来对象 [6, 5, 4, 3, 2, 1] [1, 2, 3, 4, 5, 6] # 反转2 print(list(reversed(lst))) # 通过reversed函数进行反转 [6,5,4,3,2,1] print(list(reversed(\u0026#39;abcde\u0026#39;))) # 对字符串进行反转，列表显示 [\u0026#39;e\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;a\u0026#39;]    二、操作列表 基本操作  len()：求长度 +：连接两个序列 *：复制序列 in：判断元素是否在列表中 max()、min()：按照元素的字典顺序进行排序  1、修改元素\n 列表中的元素可以进行修改，但是字符串中的不能进行修改。列表中修改的时候，直接通过索引号进行指定：\n 1 2 3 4  lst[2] = 7 # 指定第三个元素为7 print(lst) [1, 2, 7, 4, 5, 6]   2、增加元素\n追加元素的方法有两种，都是追加在末尾\n append()函数进行追加 切片的方式进行追加：a[len(a):] = [ x ]  1 2 3 4  lst.append(8) lst[len(lst):] = [8] print(lst) [1, 2, 7, 4, 5, 6, 8] # 例子承接上面，第三个元素为7，不是3   3、列表函数\n   函数 作用     append 将单个元素追加到列表的最右边，即末尾部分；list[len(list):] = [x]，x是待追加的元素； 没有返回值None   extend 将两个列表进行合并，扩充列表的作用； 参数必须是可迭代对象； list[len(list):] = L，L是待并入的列表； 完成追加过程，列表L不变，list发生变化； 没有返回值None   insert 指定位置添加元素 格式：list.insert(i,x)，i是插入的位置，x是待追加元素 ； i如果是0，相当于是插在首位；i如果是len(list)，相当于是插在最后面，则等价于append()函数    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  # extend()函数 lst = [1, 2, 7, 4, 5, 6, 8] print(id(lst)) # 查看lst的内存地址 lst1 = [\u0026#39;python\u0026#39;, \u0026#39;java\u0026#39;, \u0026#39;html\u0026#39;] lst.extend(lst1) print(id(lst)) # 查看追加列表之后的内存地址，与原来系相同的 print(\u0026#34;lst:\u0026#34;, lst) print(\u0026#34;lst1:\u0026#34;, lst1) 2435334264968 2435334264968 lst: [1, 2, 7, 4, 5, 6, 8, \u0026#39;python\u0026#39;, \u0026#39;java\u0026#39;, \u0026#39;html\u0026#39;] lst1: [\u0026#39;python\u0026#39;, \u0026#39;java\u0026#39;, \u0026#39;html\u0026#39;] # append与extend区别 lst1 = [1, 2, 3] lst2 = [\u0026#39;python\u0026#39;, \u0026#39;html\u0026#39;, \u0026#39;java\u0026#39;] lst1.append(lst2) print(lst1) [1, 2, 3, [\u0026#39;python\u0026#39;, \u0026#39;html\u0026#39;, \u0026#39;java\u0026#39;]] # 整建制，将lst2当做一个整体 lst1 = [1, 2, 3] lst2 = [\u0026#39;python\u0026#39;, \u0026#39;html\u0026#39;, \u0026#39;java\u0026#39;] lst1.extend(lst2) print(lst1) [1, 2, 3, \u0026#39;python\u0026#39;, \u0026#39;html\u0026#39;, \u0026#39;java\u0026#39;] # 个体化，将lst2的每个元素进行追加   结论：\n 列表是可以进行修改的，原地修改 append是将一个元素加到列表的末尾，整建制追加 extend将两个列表进行合并，个体化扩编 extend方法执行之后，内存中id不变，只是在该id上的内容发生了变化 insert()函数中的i如果超过最大索引值，则自动追加到末尾，相当于是append()函数的作用 三种方法均是原地修改，无返回值      函数 作用     count 查看元素重复出现的次数 如果不存在，返回0，而不是报错   index 查看索引编号，不存在则报错 检索的是元素第一次出现的位置   remove 删除元素，原地修改，无返回值； list.remove(x)：如果x不存在，则会报错； 如果x出现多次，删除第一个x，剩下不变   pop pop([i]):参数是可选的； 为空，默认删除最后一个，并且将该元素作为返回值； 如果不为空，可删除索引为i的元素，并且将该元素作为返回值   reverse 原地反转，没有生成新的列表，没有返回值   reversed 类似reverse，区别：生成的列表能够用于迭代    remove和pop的区别\n remove 没有返回值，pop有返回值 remove的参数是元素，pop的参数是索引  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  lst1 = [1, 2, 3, 4, 5, 6] lst1.remove(2) print(lst1) # lst1.remove(7) # print(lst1) ValueError: list.remove(x): x not in list lst1.pop(2) print(lst1) [1, 3, 4, 5, 6] # 将元素2删除掉 [1, 3, 5, 6] # 将索引为2的元素3删除掉，本步骤是接在上面的执行，即在列表[1, 3, 4, 5, 6] 中删除4 # 关于反转 lst = [1, 2, 3, 4, 5] print(lst[::-1]) # 反转实现1 print(lst) # 原来的列表对象不改变 lst.reverse() # 反转实现2 print(lst) # 原来的列表变成反转之后的新列表 lst1= reversed(lst) print(lst1) # lst1是一个列表反转迭代器对象：\u0026lt;list_reverseiterator object at 0x00000233C677F320\u0026gt; print(list(lst1)) # 用list函数显示lst1的内容       函数 作用     sort 排序函数，用于列表list中，原地修改没有返回值； 默认从小到大；将reverse=True则变成从大到小排序sort(self, /, *, key=None, reverse=False)   sorted 对所有可迭代对象进行操作，返回一个新的 list，不是在原来的list上进行操作 sorted(iterable[, cmp[, key[, reverse]]])    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  # sort() lst = [1, 4, 5, 8, 2, 6, 3] lst.sort() print(lst) lst1 = [\u0026#39;python\u0026#39;, ‘Java’, \u0026#39;html\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;php\u0026#39;] lst1.sort(key=len) # 列表中的字符串进行排序；如果长度相同，则按照出现的先后顺序 print(lst1) [1, 2, 3, 4, 5, 6, 8] [\u0026#39;c\u0026#39;, \u0026#39;php\u0026#39;, \u0026#39;Java\u0026#39;, \u0026#39;html\u0026#39;, \u0026#39;python\u0026#39;] # sorted() lst = [1, 4, 5, 8, 2, 6, 3] lst1 = sorted(lst) print(lst) # 原对象不变 print(lst1) # 新列表为排序后的对象 lst2 =[(\u0026#39;python\u0026#39;, \u0026#39;A\u0026#39;),(\u0026#39;java\u0026#39;, \u0026#39;C\u0026#39;),(\u0026#39;c\u0026#39;, \u0026#39;D\u0026#39;),(\u0026#39;php\u0026#39;, \u0026#39;B\u0026#39;)] lst3 = sorted(lst2, key=lambda x: x[1]) # 由元组构成的复合列表，按照元组的第二个元素进行排序，通过匿名函数lamba() print(lst3) [(\u0026#39;python\u0026#39;, \u0026#39;A\u0026#39;), (\u0026#39;php\u0026#39;, \u0026#39;B\u0026#39;), (\u0026#39;java\u0026#39;, \u0026#39;C\u0026#39;), (\u0026#39;c\u0026#39;, \u0026#39;D\u0026#39;)] lst4 = sorted(lst2, key=lambda x: len(x[0])) # 通过元组中第一个元素的长度进行排序 print(lst4) [(\u0026#39;c\u0026#39;, \u0026#39;D\u0026#39;), (\u0026#39;php\u0026#39;, \u0026#39;B\u0026#39;), (\u0026#39;java\u0026#39;, \u0026#39;C\u0026#39;), (\u0026#39;python\u0026#39;, \u0026#39;A\u0026#39;)]   自定义类中的元素进行排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  class Student: def __init__(self, name, age, grade): self.name = name self.age = age self.grade = grade def __repr__(self): return repr((self.name, self.grade, self.age)) students_objects = [ Student(\u0026#39;Tom\u0026#39;, \u0026#39;B\u0026#39;, 12), Student(\u0026#39;xiaoming\u0026#39;,\u0026#39;A\u0026#39;,17), Student(\u0026#39;xiaohong\u0026#39;, \u0026#39;C\u0026#39;, 12), Student(\u0026#39;Peter\u0026#39;, \u0026#39;D\u0026#39;, 8), ] lst5 = sorted(students_objects, key=lambda t:t.age) # 自定义类中，按照年龄进行排序 print(lst5) lst6 = sorted(students_objects, key=lambda t:(t.age, t.grade)) # 使用元组，先根据年龄排序，若年龄相同按照grade排序 print(lst6) [(\u0026#39;xiaoming\u0026#39;, 17, \u0026#39;A\u0026#39;), (\u0026#39;Tom\u0026#39;, 12, \u0026#39;B\u0026#39;), (\u0026#39;xiaohong\u0026#39;, 12, \u0026#39;C\u0026#39;), (\u0026#39;Peter\u0026#39;, 8, \u0026#39;D\u0026#39;)] [(\u0026#39;xiaoming\u0026#39;, 17, \u0026#39;A\u0026#39;), (\u0026#39;Tom\u0026#39;, 12, \u0026#39;B\u0026#39;), (\u0026#39;xiaohong\u0026#39;, 12, \u0026#39;C\u0026#39;), (\u0026#39;Peter\u0026#39;, 8, \u0026#39;D\u0026#39;)]      原文链接\n👇         ","title":"《Python札记》1_列表list"},{"link":"https://blog.policx.com/posts/flutter/","text":"前言 最近Flutter已经疯狂的刷屏了各个技术博客、技术网站，完全有一统天下的气势。所以最近也决定开始尝尝鲜，从零开始一步步的来探索Flutter的世界。就从环境搭建开始，记录一下自己探索Flutter的过程。\n安装Flutter 首先我们可以在Flutter官网上面看到一些配置环境的步骤。这里就直接开干了，走起。\n1、配置HomeBrew 我们在去配置Flutter的环境之前，需要先检查一下HomeBrew是不是最新的。\n$ brew update 如果没有brew的话，可以去HomeBrew官网自行下载。这里就不赘述了，这里如果重新下载的话，看到下面的打印信息就说明下载完毕了。\n2、下载SDK 接下来就是去官网下载SDK了。注意，这里下载SDK有两种方法：\n 一是直接git clone -b beta https://github.com/flutter/flutter.git下载 二是自己在官网下载下来，如下图   这里我两种方法都试过了一遍，第一种方法实在是太慢了，在经历了耗费一个半小时下载到94%，最后提示失败了的过程之后，我决定还是用第二种方法，整个过程只用了3分钟的样子，相当满意。下载完之后，是一个名字叫flutter_macos_v1.5.4-hotfix.2-stable.zip的压缩包。 然后我们解压这个zip包，把解压出来的flutter文件放到根目录下即可。\n3、配置环境变量 因为Flutter的SDK中包含了很多的命令行工具。我们就需要配置环境变量，所以我直接就安装到了根目录下了。\n配置镜像\n因为Flutter在运行的时候，就需要去官网下载一些需要的资源，但是因为天国特色的wall的原因，我们就需要镜像服务器，这个在官网上面有写的很明白，而且这是一个临时的镜像，后面还要以官网的镜像地址为准。\n我们跳转到根目录\ncd ~ 就能找到这个.bash_profile隐藏文件，我们用vim打开这个文件\nvim ~/.bash_profile 然后需要输入就把A键按一下进入编辑模式，把下面三个环境变量配置进去\nexport PUB_HOSTED_URL=https://pub.flutter-io.cn export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn export PATH=/Users/xueliheng/flutter/bin:$PATH 注意下，第三个环境变量这里/Users/xueliheng/是我的根目录，然后/flutter/是我们刚刚解压的的zip包里面的flutter文件夹。上面两个环境变量是两个镜像地址，上文中也有说过。 接着shift+：然后输入wq保存并退出vim。输入如下命令：\nsource ~/.bash_profile 最后我们就可以验证一下flutter环境有没有配置成功了。输入：\nflutter -h 看到如下如的打印信息就是配置成功了 4、配置Android Studio 如果没有下载Android Studio的话，就去官网去下载一下。 我们用flutter doctor命令去检查一下flutter的环境配置，我们可以看到如下打印\n这里的每个✗都是我们要去解决的问题。不过他有告诉你应该怎么做。比如第一个提示：\n[✗] Android toolchain - develop for Android devices ✗ Unable to locate Android SDK. 这就是让你去下载Android Studio。我们在下载完成之后，打开AS让他去下载一些应该下载的东西。 如果这里有提示你\n[✗] Android toolchain - develop for Android devices (Android SDK version 24.0.2) ✗ Flutter requires Android SDK 28 and the Android BuildTools 28.0.3 这就是在提示让你去升级一下SDK，然后命令如下\n\u0026quot;/Users/xueliheng/Library/Android/sdk/tools/bin/sdkmanager\u0026quot; \u0026quot;platforms;android-28\u0026quot; \u0026quot;build-tools;28.0.3\u0026quot; 注意一下，这个地方的升级是需要”科学上网“的，如果有的小伙伴没有这个条件的话，我这边百度云上面给大家准备了一个链接，提取码: e48c，大家可以下载下来。下载下来之后解压到/Users/Library/Android/这个文件夹。把原先的SDK直接覆盖就行了，就已经是最新的SDK了。\n接下来我们配置一下安卓的环境变量，还是在根目录下找到.bash_profile文件，并在其中添加四个环境变量\nexport ANDROID_HOME=~/Library/Android/sdk export PATH=${PATH}:${ANDROID_HOME}/emulator export PATH=${PATH}:${ANDROID_HOME}/tools export PATH=${PATH}:${ANDROID_HOME}/platform-tools 分别是：\n 安卓sdk的路径 安卓的模拟器路径 安卓tools路径 安卓平台工具  接下来我们再用flutter doctor检查的时候，显示的信息如下图 意思就是让我们去下载iOS的相关环境，我们先暂时放放，下面还有一个关于Android Studio的没有解决完\n ✗ Flutter plugin not installed; this adds Flutter specific functionality. ✗ Dart plugin not installed; this adds Dart specific functionality. 这个就是缺少Flutter插件的意思，那么我们就去AS里面去配置一下好了。打开AS的Preferences，点击Plugins，在搜索栏中输入flutter，找到相应的插件，然后Install。当跳出安装Dart插件的提示界面时，记得点击Yes进行安装。安装完毕之后restart IDE重启AS。 重启之后就能看到多了一个这个东西 我们再用flutter doctor检测一下 现在终于ok了。我们看到[✓]Android Studio说明，安卓的环境基本上配置成功，接下来我们就配置一下安卓的模拟器就好了。\n5、安卓模拟器配置 在AS中找到模拟器配置如下图并选择 接着就创建设备，选择设备 选择系统 最后点击下载就完成了。\n6、配置iOS环境 我们配置完了安卓的环境，再来flutter doctor检测一下。 情况是这样的。目前1.5.4版本的Flutter需要匹配新版本的Xcode10.2.1。按照他提示的来试试，提示我Xcode版本太低了，需要升级Xcode 更新到最新的之后，继续走下面的步骤依旧会报错。那么我们可以试试下面的这个办法：\n$ brew link pkg-config $ brew install --HEAD usbmuxd $ brew unlink usbmuxd $ brew link usbmuxd $ brew install --HEAD libimobiledevice $ brew install ideviceinstaller 这些执行完之后执行一下flutter doctor 最后还真是没错，全部配置完成了！那么我们就把iOS的也配置完毕了。\n7、VSCode的使用 VSCode上面使用的话，就简单多了，这里我就简答的赘述一下。 只需要将Dart和Flutter插件都下载下来 然后command+shift+p输入flutter，选择Flutter：New Project 输入要创建的项目的名称和存放项目的地址。如果提示需要指明flutter的SDK的路径，那就选择根目录那个经过解压得来的flutter的文件夹就好了。 接下来是这样一个界面 接下来我们选择View-\u0026gt;Start Debugging来运行项目。 当然这个过程需要你把Xcode的模拟器打开。运行完之后就能看到这个界面，也就是你的第一个Flutter工程啦！ 8、Hot reload的使用 我们打开lib/main.dart文件，然后在其中找到\nYou have pushed the button this many times: 并把这个改为\nYou have clicked the button this many times: 那么我们就能看到界面上多了一个小闪电 我们现在如果command+s保存一下更改的话，就能很快的在模拟器上面看到相应的更改，不需要再重新去编译一边。这一点简直是太棒了！解决了iOS开发者一个大痛点啊！！！\n结语 至此，flutter的环境搭建工作基本上就进行完毕了，整个过程大概耗时接近2个小时，这期间包括采坑、查资料、下载、科学上网\u0026hellip;等等很蛋疼的事情。当然网速基本上是最大的障碍，浪费了很多的时间。所以也是需要一定的耐心来完成的。 后面的文章也会持续的更新，最近有点懈怠，OpenGL系列的文章有点拖更的节奏，这个后面会补起来。Flutter我也才刚刚接手，也是慢慢的来采坑，也会以此来记录自己的学习经历，也希望能多多跟大家交流。 再次我附上自己的邮箱coderspr1nghall@gmail.com欢迎讨论交流。\n   原文链接\n👇        ","title":"Flutter的环境配置 for Mac"},{"link":"https://blog.policx.com/posts/spider/","text":"现在Python语言大火，在网络爬虫、人工智能、大数据等领域都有很好的应用。今天我向大家介绍一下Python爬虫的一些知识和常用类库的用法，希望能对大家有所帮助。\n其实爬虫这个概念很简单，基本可以分成以下几个步骤：\n  发起网络请求\n  获取网页\n  解析网页获取数据\n  发起网络请求这个步骤常用的类库有标准库urllib以及Python上常用的requests库。解析网页常用的类库有的BeautifulSoup。另外requests的作者还开发了另一个很好用的库requests-html，提供了发起请求和解析网页的二合一功能，开发小型爬虫非常方便。另外还有一些专业的爬虫类库，其中比较出名的就是scrapy。本文将会简单介绍一下这些类库，之后还会专门写一篇文章介绍scrapy的用法。\n标准库urllib 首先先来看标准库urllib。标准库的优点是Python自带的，不需要安装任何第三方库，缺点就是urllib属于偏底层的库，使用起来比较麻烦。下面是urllib发起请求的一个简单例子，大家看看就好。可以看到为了发起一个简单的请求，我们需要创建opener、request、ProxyHandler等好几个对象，比较麻烦。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  import urllib.request as request import requests proxies = { \u0026#39;https\u0026#39;: \u0026#39;https://127.0.0.1:1080\u0026#39;, \u0026#39;http\u0026#39;: \u0026#39;http://127.0.0.1:1080\u0026#39; } headers = { \u0026#39;user-agent\u0026#39;: \u0026#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:65.0) Gecko/20100101 Firefox/65.0\u0026#39; } print(\u0026#39;--------------使用urllib--------------\u0026#39;) url = \u0026#39;http://www.google.com\u0026#39; opener = request.build_opener(request.ProxyHandler(proxies)) request.install_opener(opener) req = request.Request(url, headers=headers) response = request.urlopen(req) print(response.read().decode())   requests requests是Kenneth Reitz大神的著名作品之一，优点就是极度简单和好用。首先来安装requests。\n1  pip install requests   下面是一个简单的例子，和上面urllib示例代码实现的功能相同，但是代码量少多了，也更易读。\n1 2 3 4  print(\u0026#39;--------------使用requests--------------\u0026#39;) response = requests.get(\u0026#39;https://www.google.com\u0026#39;, headers=headers, proxies=proxies) response.encoding = \u0026#39;utf8\u0026#39; print(response.text)   requests还可以方便的发送表单数据，模拟用户登录。返回的Response对象还包含了状态码、header、raw、cookies等很多有用的信息。\n1 2 3 4 5 6 7 8  data = { \u0026#39;name\u0026#39;: \u0026#39;yitian\u0026#39;, \u0026#39;age\u0026#39;: 22, \u0026#39;friends\u0026#39;: [\u0026#39;zhang3\u0026#39;, \u0026#39;li4\u0026#39;] } response = requests.post(\u0026#39;http://httpbin.org/post\u0026#39;, data=data) pprint(response.__dict__) print(response.text)   关于requests我就不多做介绍了，因为它有中文文档，虽然比官方落后几个小版本号，不过无伤大雅，大家可以放心参阅。\n1  http://cn.python-requests.org/zh_CN/latest/   beautifulsoup 利用前面介绍的requests类库，我们可以轻易地获取HTML代码，但是为了从HTML中找到所需的数据，我们还需要HTML/XML解析库，BeautifulSoup就是这么一个常用的库。首先先来安装它：\npip install beautifulsoup4 这次就用我简书主页作为例子，爬取一下我简书的文章列表。首先先用requests获取到网页内容。\n1 2 3 4 5 6 7 8 9 10 11  from pprint import pprint import bs4 import requests headers = { \u0026#39;user-agent\u0026#39;: \u0026#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:65.0) Gecko/20100101 Firefox/65.0\u0026#39; } url = \u0026#39;https://www.jianshu.com/u/7753478e1554\u0026#39; response = requests.get(url, headers=headers)   然后就是BeautifulSoup的代码了。在使用BeautifulSoup的时候首先需要创建一个HTML树，然后从树中查找节点。BeautifulSoup主要有两种查找节点的办法，第一种是使用find和find_all方法，第二种方法是使用select方法用css选择器。拿到节点之后，用contents去获取它的子节点，如果子节点是文本，就会拿到文本值，注意这个属性返回的是列表，所以要加[0]。\n1 2 3 4 5 6  html = bs4.BeautifulSoup(response.text, features=\u0026#39;lxml\u0026#39;) note_list = html.find_all(\u0026#39;ul\u0026#39;, class_=\u0026#39;note-list\u0026#39;, limit=1)[0] for a in note_list.select(\u0026#39;li\u0026gt;div.content\u0026gt;a.title\u0026#39;): title = a.contents[0] link = f\u0026#39;https://www.jianshu.com{a[\u0026#34;href\u0026#34;]}\u0026#39; print(f\u0026#39;《{title}》,{link}\u0026#39;)   BeautifulSoup也有中文文档，同样也是稍微落后两个小版本，影响不大。\n1  https://www.crummy.com/software/BeautifulSoup/bs4/doc.zh/   requests-html 这个类库是requests的兄弟，同样也是Kenneth Reitz大神的作品。它将请求网页和解析网页结合到了一起。本来如果你用requests的话只能请求网页，为了解析网页还得使用BeautifulSoup这样的解析库。现在只需要requests-html一个库就可以办到。\n首先先来安装。\npip install requests-html 然后我们来看看用requests-html如何重写上面这个例子。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  from requests_html import HTMLSession from pprint import pprint url = \u0026#39;https://www.jianshu.com/u/7753478e1554\u0026#39; headers = { \u0026#39;user-agent\u0026#39;: \u0026#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:65.0) Gecko/20100101 Firefox/65.0\u0026#39; } session = HTMLSession() r = session.get(url, headers=headers) note_list = r.html.find(\u0026#39;ul.note-list\u0026#39;, first=True) for a in note_list.find(\u0026#39;li\u0026gt;div.content\u0026gt;a.title\u0026#39;): title = a.text link = f\u0026#39;https://www.jianshu.com{a.attrs[\u0026#34;href\u0026#34;]}\u0026#39; print(f\u0026#39;《{title}》,{link}\u0026#39;)   requests-html除了可以使用css选择器来搜索以外，还可以使用xpath来查找。\n1 2 3 4  for a in r.html.xpath(\u0026#39;//ul[@class=\u0026#34;note-list\u0026#34;]/li/div[@class=\u0026#34;content\u0026#34;]/a[@class=\u0026#34;title\u0026#34;]\u0026#39;): title = a.text link = f\u0026#39;https://www.jianshu.com{a.attrs[\u0026#34;href\u0026#34;]}\u0026#39; print(f\u0026#39;《{title}》,{link}\u0026#39;)   requests-html还有一个很有用的特性就是浏览器渲染。有些网页是异步加载的，直接用爬虫去爬只能得到一个空页面，因为数据是靠浏览器运行JS脚本异步加载的，这时候就需要浏览器渲染了。而浏览器渲染用requests-html做非常简单，只要多调用一个render函数即可。render函数有两个参数，分别指定页面下滑次数和暂停时间。render函数第一次运行的时候，requests-html会下载一个chromium浏览器，然后用它渲染页面。\n简书的个人文章页面也是一个异步加载的例子，默认只会显示最近几篇文章，通过浏览器渲染模拟页面下滑，我们可以得到所有文章列表。\n1 2 3 4 5 6 7 8  session = HTMLSession() r = session.get(url, headers=headers) # render函数指示requests-html用chromium浏览器渲染页面 r.html.render(scrolldown=50, sleep=0.2) for a in r.html.xpath(\u0026#39;//ul[@class=\u0026#34;note-list\u0026#34;]/li/div[@class=\u0026#34;content\u0026#34;]/a[@class=\u0026#34;title\u0026#34;]\u0026#39;): title = a.text link = f\u0026#39;https://www.jianshu.com{a.attrs[\u0026#34;href\u0026#34;]}\u0026#39; print(f\u0026#39;《{title}》,{link}\u0026#39;)   类似的，今日头条的个人页面也是异步加载的，所以也得调用render函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  from requests_html import HTMLSession headers = { \u0026#39;user-agent\u0026#39;: \u0026#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:65.0) Gecko/20100101 Firefox/65.0\u0026#39; } session = HTMLSession() r = session.get(\u0026#39;https://www.toutiao.com/c/user/6662330738/#mid=1620400303194116\u0026#39;, headers=headers) r.html.render() for i in r.html.find(\u0026#39;div.rbox-inner a\u0026#39;): title = i.text link = f\u0026#39;https://www.toutiao.com{i.attrs[\u0026#34;href\u0026#34;]}\u0026#39; print(f\u0026#39;《{title}》 {link}\u0026#39;)   最后是requests-html的官网地址以及中文文档。\n1 2 3 4 5 6 7 8 9 10 11  https://html.python-requests.org/ https://cncert.github.io/requests-html-doc-cn/``` ## **scrapy** 以上介绍的几个框架都是各自有各自的作用，把它们结合起来可以达到编写爬虫的目的，但是要说专业的爬虫框架，还是得谈谈scrapy。作为一个著名的爬虫框架，scrapy将爬虫模型框架化和模块化，利用scrapy，我们可以迅速生成功能强大的爬虫。 不过scrapy概念众多，要仔细说还得专门开篇文章，这里就只简单演示一下。首先安装scrapy，如果是Windows系统，还需要安装pypiwin32。 ```pip pip install scrapy pip install pypiwin32   然后创建scrapy项目并添加一个新爬虫。\n1 2 3  scrapy startproject myproject cd myproject scrapy genspider my jianshu.com   打开配置文件settings.py，设置用户代理，否则会遇到403错误。\n1 2  USER_AGENT = \u0026#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:65.0) Gecko/20100101 Firefox/65.0\u0026#39;   然后修改一下爬虫。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  # -*- coding: utf-8 -*- import scrapy class JianshuSpider(scrapy.Spider): name = \u0026#39;jianshu\u0026#39; allowed_domains = [\u0026#39;jianshu.com\u0026#39;] start_urls = [\u0026#39;https://www.jianshu.com/u/7753478e1554\u0026#39;] def parse(self, response): for article in response.css(\u0026#39;div.content\u0026#39;): yield { \u0026#39;title\u0026#39;: article.css(\u0026#39;a.title::text\u0026#39;).get(), \u0026#39;link\u0026#39;: \u0026#39;https://www.jianshu.com\u0026#39; + article.xpath(\u0026#39;a[@class=\u0026#34;title\u0026#34;]/@href\u0026#39;).get() }   最后运行一下爬虫。\n1  scrapy crawl my   \n   👇         ","title":"Python爬虫"},{"link":"https://blog.policx.com/posts/ddos/","text":"“\nDDOS？\n一言难尽啊！\n”\n先说结论，DDoS是近年来网络攻击中的一棵“常青树”，的确很难缠，但说它是无解的，那也有点太看得起它了。虽然DDoS在对很多大平台的攻击中出尽了风头，但在现在互联网的解决方案中，并不缺乏应对DDoS的解决方案。\n说起DDoS攻击，我脑海里能够想到的全都是中国民间俗语，什么“双拳难敌四手，好汉架不住人多”，什么“千斤拨四两”，什么“乱拳打死老师傅”等等等等。\n之前有朋友跑来问我DDoS是个什么东西，为什么这么多互联网巨头都被搞得没有脾气，我记得我当时我是这么举的例子：\n我们这一代人小的时候，自助餐开始在中国内地风行，那会儿这个行业里为了打击竞争对手，对手最惯常使用的阴招是雇佣很多五大三粗的人，给他们钱去对方的店里一通猛吃，杯盘狼藉之下，用不了几天这家自助餐就能给吃黄了。\n而DDoS攻击比这种还阴损，如果你开了一家餐馆，你的对手如果想搞你，最好的办法就是找一堆地痞流氓到你的店里坐的满满一屋子，你如果上前问，他们就一直跟你扯淡找麻烦，导致真正想吃饭的顾客一看这个情形，掉头就走了。\n用不了多久，你的餐馆就会开不下去，而你的竞争对手就会趁机蚕食掉你的市场份额，而放在网络语境里，这就是DDoS攻击的最基本原理。\n而这件事之所以难缠在于，一两个无赖根本成不了气候，想要耍流氓必须要有很多个无赖集结在一起。所以和现实世界中的无赖一样，DDoS真正的杀手锏在于利用能够发动的汹涌的流量，可以瞬间冲垮被攻击网站的服务器。\n如果我们回溯一下历史的话，会发现黑客组织之所以会有组织有预谋的发起DDoS攻击，基本上都是基于以下几个原因：\n  有些行业如果网站被恶意攻击，会造成很难估量的损失，这个时候黑客发动DDoS攻击的初衷一般是出于敲诈勒索，为了保证企业的正常运转，他们通常愿意向黑客付高额的赎金；\n  行业内血海一片，DDoS是恶意竞争的屠刀。这个现象从逻辑上，其实雇佣无赖去占领对手餐馆的原理是一毛一样的，而且DDOS攻击早已产业化，现在中国的DDOS黑市，出钱请黑客打1G的流量到一个网吧或网站，市场价只要不到50块钱，但对于一个创业公司或者干脆就是一个小网吧来说，这已经算是可以灭顶的无妄之灾了。\n  DDoS攻击往往成为掩盖真实网络攻击的烟雾弹，在遭受DDoS攻击的企业中，部分企业还伴随数据丢失的现象，黑客利用DDoS攻击掩盖其窃取用户隐私的真实目的，这种攻击行为在社交网站、金融领域等用户隐私高价值的行业尤为高发。\n  比如说，去年年初的时候，荷兰第一大银行荷兰商业银行于2018年1月28日晚间遭到DDoS攻击；第二大银行荷兰合作银行的网银服务29日早晨遭到攻击；第三大银行荷兰银行在那一周内共遭到7次网络攻击，仅周末就有3次。\n不过这一次发生在荷兰的针对银行系统的攻击并没有造成用户隐私的泄露，原因在于这仅仅是一次来自俄罗斯一个网络间谍组织Cozy Bear对荷兰情报组织AIVD侵犯其计算机的“单纯”的报复行为。但并不是所有黑客组织发起的DDoS攻击都如此单纯。\n2018年年底时万豪酒店发布了一则公告，称其旗下喜达屋酒店的5亿人次的信息被泄露，共计3.27亿人，泄露信息包括姓名、邮寄地址、电话号码、电子邮件昂面地址、护照号码、出生日期、性别等等入住信息，更糟糕的是万豪无法确定，侵入酒店系统的第三方黑客，在窃取的信息中是否包含客人的银行卡号和密码。（此案例和DDOS攻击无关，建议采用其他案例，比如2011年4月20日至26日，索尼遭受DDoS攻击，目的是为了掩盖盗取索尼PS的用户数据。）\n而游戏领域，则是DDoS攻击的另一个重灾区，不光是刚才前文中提到的暴雪，包括索尼、金山、网易在内的众多知名游戏公司都曾数次遭受攻击，可以说DDoS攻击是游戏企业的噩梦。\n许多刚创业的游戏公司，可能刚上线就被打死，而一些处在融资阶段的游戏公司，由于遭遇攻击而被迫停服，则很大程度上会调低投资人的预期，甚至导致融资失败。\n而这些因素，都是竞对打压或者敲诈勒索的绝对软肋。\n从以上的几个案例我们不难看出，和现实中的耍流氓和敲诈勒索相比，通过网络手段进行攻击的风险和成本更低，坏蛋的嘴脸也更穷凶极恶一点，无论是政府机构还是企业平台，无论你是巨头还是小蚂蚁，只要你身上有羊毛可以薅，你都时刻面临着被洗劫的风险\n不过刚在开头我也讲了，虽然DDoS很难缠很让人头痛，但本质上图并不是无解的。\n回到我最开始讲的那个例子。\n你是一个餐馆老板，过去三十年一直是个老老实实的厨子，突然面对五十个臭流氓到你店里耍无赖的时候，你最好的应对方法，应该是什么？\n自己组建一支人马，和这些臭流氓正面刚？这恐怕不行，因为你不是臭流氓，你没有相应的作战经验。\n报警请人民警察来帮忙处理？这恐怕也不行，人家在你店里没有打砸抢，只是“温和的”非暴力不合作，警察来了也只能当民事调解，并且人家马仔众多，明天再换一拨新面孔来，玩的你一点脾气都没有。\n这就是面对DDoS时，无论是巨头还是小蚂蚁，他们的实实在在的困境。\n但正所谓“道高一尺魔高一丈”，你在云上和我耍流氓，那我就在云上回击。\n**“云”的事儿，不如还交还给云来处理。**我认为就目前DDoS的在攻击量级上的疯狂进击的前提下，云计算服务厂商或许是狙击它们的最有效手段。\n2018年年初，峰值1.35TB/秒的流量冲击了开发者平台 GitHub。这是第一次TB量级的DDoS攻击。GitHub 受到攻击后，服务器断断续续，无法访问。攻击发生 10 分钟后，GitHub 向CDN 服务商 Akamai 请求协助，访问 GitHub 的流量已经由后者接管并在15分钟之内完成了防御。\nAkamai的相关负责人在接受采访时说，我们是基于迄今为止最大规模 DDoS 攻击五倍的峰值而做的相应准备，所以 1.3T 对我们来说是小意思。\n在关于流量峰值这一点上，我认为饱受双11、双12、618等全民购物狂欢的电商巨头们更有发言权，就拿京东举例子好了。\n京东云在之前发布的高防版的DDoS服务中，展示出了非常明确的信心是，在多年的电商狂欢流量对抗中，京东云已经在实战中建立了一套完备的防御机制，无论是在流量峰值的建模上，还是在DDoS的防御算法上，它的部署都远远不是纸上谈兵，而是拳拳到肉的经受住了实战的洗礼。要知道，全世界每年有超过5成的DDoS攻击都来自中国，而我们的国家也是全世界超过美国的第一大“肉鸡”市场，由电商大数据加持演化而来的京东云，它在云安全的理解上可以说是非常深刻了。\n所以说，如果说一定要有一个结论，我想说“上帝的归上帝，而云上的归云上”，像京东云这样的基于电商大数据考验的云计算平台，或许才是对抗DDoS的最终答案。\n   原文链接\n👇         ","title":"DDoS（分布式拒绝服务）攻击是无解的吗？"},{"link":"https://blog.policx.com/posts/five_c/","text":"【CSDN 编者按】技术圈里一直倡导一句话，那便是“拥抱变化”，因为技术始终在飞速地更新迭代，过去掌握的技能可能突然之间就过时了。在近几年，移动开发逐渐趋于稳定，而人工智能、区块链等技术开始甚嚣尘上，客户端开发者们不由得开始迷茫，曾经如此吃香，未来又该怎么走？也许本文会有一点思路上的帮助。\n 作者 | David O. 译者 | 罗昭成 责编 | 沭七 出品 | CSDN（ID：CSDNnews）  以下为译文：\n近十年，10~15 年前不存在的技术，让这个世界变得黯然失色。有趣的是，这些概念正在构建未来的生活方式。如果你认为你在现在已经上线的 App 中看到了这些变化，并且也在着手开发自己的 App，在未来五年，你依然会对 iOS 程序开发的发展方式感到异常震惊。\n以下四点，你可以重点关注：\n 人工智能\n人工智能（AI）是一个独特的范式转换器（Paradigm Shifter）[1]。iOS 应用程序开发领域中，睿智的开发者无时无刻都在创建基于 AI 的应用程序。例如星巴克，发布了一个名叫 My Starbucks Barista 的 iOS 应用，它会根据你当天的需要，为你订购咖啡和零食。在金融领域，也有很多 iOS 的人工智能应用程序，根据你的指示，自动进行交易。\n在不久的将来，在 iOS 平台，你将会看到越来越多的 AI 应用程序，它们将以全新的方式，逐渐替换传统方式为我们提供服务。这些 AI 应用程序将代替你做选择。这个领域，有无限可能。\n 增强现实 增强现实（AR）与 AI 一样神奇。几年前， Pokémon GO 将虚拟怪兽带到我们的世界，让全世界的人对 AR 趋之若鹜。这个游戏，在 2016 年收入约 9.5 亿美元，到 2017 年，就接近了 9 亿美元。\n在未来几年，AR 将在游戏和其它应用中产生更加惊人的影响。这些变化，你将在未来几年的 iOS 应用程序中看到。\n 物联网（IoT）\n随着时间的推移，物联网（IoT）正在逐渐壮大。现如今，你可以看到，灯、门铃、智能门锁、家庭安防系统、音箱、电视、电视盒子、手表、平板、冰箱都连接到互联网上，你可以随时随地控制它们。虽然 iOS 应用程序不能让你看到冰箱中还剩多少食物，还不能改善物联网的体验，但是 IoT 设备获取到越多的数据，越能帮助你作出正确的选择。\nIoT 正在优化酒店、汽车、零售等多种行业，这几年的变化，甚是有趣。此外，当人工智能与 IoT 相结合，IoT 将有可能彻底改变全球人的生活方式。\n 基于云的应用程序\n很多 iOS 应用程序开发专家预测，基于云的 iOS 应用程序将是下一个行业重点。在未来几年内，将有超过一半的企业与组织拥有至少一个基于云的原生应用程序[2]。\n上面的预测里，有一个奇怪的事情，这个市场，80% 的份额将由 Google、微软、亚马逊占据，而苹果则只剩下 20% 左右。这意味着，如果你的 iOS 应用程序要在这 1780 亿美元的市场中占据一席之地，你需要好好磨练你的 iOS 开发技能。\n此外，苹果可能会在未来几年，像其它领域一样，通过创新来抢回市场。苹果今天的成绩，我们相信它有那个能力。\n 结论\n总之，上面提到的领域，并非只有这些领域。在 iOS 开发中，可穿戴设备，跨平台应用、移动支付和区块链技术等领域，都能开发出令人惊叹程序。\n这篇文章并不是预测未来，而是告诉你一些潜在的领域，在前期发展的时候抓住机会。\n谨以抛砖引玉，期待更多探讨。\n 相关资料：  [1] https://wiki.mbalib.com/wiki/范式转换\n[2] https://go.forrester.com/blogs/predictions-2018-cloud-computing-accelerates-enterprise-transformation-everywhere/\n 原文链接：hackernoon\n本文为 CSDN 翻译，如需转载，请注明来源出处。\n ","title":"未来五年，iOS 开发如何前行？"},{"link":"https://blog.policx.com/posts/bittorrent/","text":" 链接：回形针PaperClip\n ","title":"BT 种子和磁力链接是如何工作的？"},{"link":"https://blog.policx.com/posts/partner/","text":" 利益小的时候，什么都好说。利益大到一定程度，就超越了人性。\n 记：539天，失败的创业  ⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️  ","title":"中国合伙人"},{"link":"https://blog.policx.com/posts/harddisk/","text":" 链接：回形针PaperClip\n ","title":"你的硬盘是如何存储数据的？"},{"link":"https://blog.policx.com/posts/git-del/","text":"在上传项目到github时,忘记忽略了某个文件夹.idea,就直接push上去了, 最后意识到了此问题,决定删除掉远程仓库中的.idea文件夹\n在github上只能删除仓库,却无法删除文件夹或文件, 所以只能通过命令来解决\n首先进入你的master文件夹下, Git Bash Here ,打开命令窗口\n1 2 3 4 5 6 7 8 9 10 11  git --help # 帮助命令 git pull origin master # 将远程仓库里面的项目拉下来 ls # 查看有哪些文件夹 git rm -r --cached .idea # 删除.idea文件夹 git commit -m \u0026#39;删除.idea\u0026#39; # 提交,添加操作说明 git push -u origin master # 将本次更改更新到github项目上去    作者： 皮皮今\n","title":"git如何删除已经提交的文件夹"},{"link":"https://blog.policx.com/posts/xian/","text":" 合作公司项目\n  ","title":"西安"},{"link":"https://blog.policx.com/posts/python-excel/","text":"自动化的工作是为了从繁琐重复的劳动中挣脱出来，把精力用在数据分析上。自动化方面python是在好不过了，不过既然要提交报表， 就不免要美观什么的。pandas虽然很强大，但是无法对Excel完全操作，现学vba有点来不及。于是就找到这个openpyxl包，用python来修改Excel。\n如下所示：\n1 2 3 4 5 6  from openpyxl import load_workbook from openpyxl.styles import colors, Font, Fill, NamedStyle from openpyxl.styles import PatternFill, Border, Side, Alignment # 加载文件 wb = load_workbook(\u0026#39;./5a.xlsx\u0026#39;)    workbook： 工作簿，一个excel文件包含多个sheet。 worksheet：工作表，一个workbook有多个，表名识别，如“sheet1”,“sheet2”等。 cell： 单元格，存储数据对象 文章所用表格为：   操作sheet # 读取sheetname print('输出文件所有工作表名：\\n', wb.sheetnames) ws = wb['5a'] # 或者不知道名字时 sheet_names = wb.sheetnames # 返回一个列表 ws2 = wb[sheet_names[0]] # index为0为第一张表 print(ws is ws2) # 两者是一样的 输出文件所有工作表名： [\u0026lsquo;5a\u0026rsquo;] True\n# 修改sheetname ws.title = '5a_' print('修改sheetname：\\n', wb.sheetnames) 修改sheetname： [\u0026lsquo;5a_']\n# 创建新的sheet # 创建的新表必须要赋值给一个对象，不然只有名字但是没有实际的新表 ws4 = wb.create_sheet(index=0, title='newsheet') # 什么参数都不写的话，默认插入到最后一个位置且名字为sheet,sheet1...按照顺序排列 ws5 = wb.create_sheet() print('创建新的sheet:\\n', wb.sheetnames) 创建新的sheet: [\u0026lsquo;newsheet\u0026rsquo;, \u0026lsquo;5a_\u0026rsquo;, \u0026lsquo;Sheet\u0026rsquo;]\n# 删除sheet wb.remove(ws4) # 这里只能写worksheet对象，不能写sheetname print('删除sheet：\\n', wb.sheetnames) 删除sheet： [\u0026lsquo;5a_\u0026rsquo;, \u0026lsquo;Sheet\u0026rsquo;]\n# 修改sheet选项卡背景色，默认为白色，设置为RRGGBB模式 ws.sheet_properties.tabColor = \u0026quot;FFA500\u0026quot; # 读取有效区域 print('最大列数为：', ws.max_column) print('最大行数为：', ws.max_row) 最大列数为： 5 最大行数为： 17\n# 插入行和列 ws.insert_rows(1) # 在第一行插入一行 ws.insert_cols(2, 4) # 从第二列开始插入四列 # 删除行和列 ws.delete_cols(6, 3) # 从第六列（F列）开始，删除3列即（F:H） ws.delete_rows(3) # 删除第三行 单元格操作 # 读取 c = ws['A1'] c1 = ws.cell(row=1, column=2) print(c, c1) print(c.value, c1.value) \u0026lt;Cell \u0026lsquo;5a_'.A1\u0026gt; \u0026lt;Cell \u0026lsquo;5a_'.B1\u0026gt;\ndth_title Province\n# 修改 ws['A1'] = '景区名称' ws.cell(1, 2).value = '省份' print(c.value, c1.value) 景区名称 省份\n# 读取多个单元格 cell_range = ws['A1':'D5'] colC = ws['C'] col_range = ws['C:D'] row10 = ws[10] row_range = ws[5:10] # 其返回的结果都是一个包含单元格的元组 print(type(cell_range)) for i in row10: print(i) # row10只有有效单元格 \u0026lt;class \u0026lsquo;tuple\u0026rsquo;\u0026gt;\n\u0026lt;Cell \u0026lsquo;5a_'.A10\u0026gt; \u0026lt;Cell \u0026lsquo;5a_'.B10\u0026gt; \u0026lt;Cell \u0026lsquo;5a_'.C10\u0026gt; \u0026lt;Cell \u0026lsquo;5a_'.D10\u0026gt; \u0026lt;Cell \u0026lsquo;5a_'.E10\u0026gt;\n# 按照行列操作 for row in ws.iter_rows(min_row=1, max_row=3, min_col=1, max_col=2): for cell in row: print(cell) # 也可以用worksheet.iter_col(),用法都一样 \u0026lt;Cell \u0026lsquo;5a_'.A1\u0026gt; \u0026lt;Cell \u0026lsquo;5a_'.B1\u0026gt; \u0026lt;Cell \u0026lsquo;5a_'.A2\u0026gt; \u0026lt;Cell \u0026lsquo;5a_'.B2\u0026gt; \u0026lt;Cell \u0026lsquo;5a_'.A3\u0026gt; \u0026lt;Cell \u0026lsquo;5a_'.B3\u0026gt;\n# 合并单元格 ws.merge_cells('F1:G1') ws['F1'] = '合并两个单元格' # 或者 ws.merge_cells(start_row=2, start_column=6, end_row=3, end_column=8) ws.cell(2, 6).value = '合并三个单元格' # 取消合并单元格 ws.unmerge_cells('F1:G1') # 或者 ws.unmerge_cells(start_row=2, start_column=6, end_row=3, end_column=8) wb.save('./5a.xlsx') # 保存之前的操作,保存文件时，文件必须是关闭的！！！ 注意！！！，openpyxl对Excel的修改并不像是xlwings包一样是实时的，他的修改是暂时保存在内存中的，所以当 后面的修改例如我接下来要在第一行插入新的一行做标题，那么当我对新的A1单元格操作的时候，还在内存中的原A1(现在是A2)的单元格 原有的修改就会被覆盖。所以要先保存，或者从一开始就计划好更改操作避免这样的事情发生。\n样式修改 单个单元格样式 wb = load_workbook('./5a.xlsx') # 读取修改后的文件 ws = wb['5a_'] # 我们来设置一个表头 ws.insert_rows(1) # 在第一行插入新的一行 ws.merge_cells('A1:E1') # 合并单元格 a1 = ws['A1'] ws['A1'] = '5A级风景区名单' # 设置字体 ft = Font(name='微软雅黑', color='000000', size=15, b=True) \u0026quot;\u0026quot;\u0026quot; name:字体名称 color:颜色通常是RGB或aRGB十六进制值 b(bold):加粗（bool） i(italic):倾斜(bool) shadow：阴影（bool） underline：下划线（‘doubleAccounting’, ‘single’, ‘double’, ‘singleAccounting’） charset:字符集(int) strike:删除线(bool) \u0026quot;\u0026quot;\u0026quot; a1.font = ft # 设置文本对齐 ali = Alignment(horizontal='center', vertical='center') \u0026quot;\u0026quot;\u0026quot; horizontal:水平对齐('centerContinuous', 'general', 'distributed', 'left', 'fill', 'center', 'justify', 'right') vertical:垂直对齐（'distributed', 'top', 'center', 'justify', 'bottom'） \u0026quot;\u0026quot;\u0026quot; a1.alignment = ali # 设置图案填充 fill = PatternFill('solid', fgColor='FFA500') # 颜色一般使用十六进制RGB # 'solid'是图案填充类型，详细可查阅文档 a1.fill = fill openpyxl.styles.fills模块参数文档\n# 设置边框 bian = Side(style='medium', color='000000') # 设置边框样式 \u0026quot;\u0026quot;\u0026quot; style:边框线的风格{'dotted','slantDashDot','dashDot','hair','mediumDashDot', 'dashed','mediumDashed','thick','dashDotDot','medium', 'double','thin','mediumDashDotDot'} \u0026quot;\u0026quot;\u0026quot; border = Border(top=bian, bottom=bian, left=bian, right=bian) \u0026quot;\u0026quot;\u0026quot; top（上）,bottom（下）,left（左）,right（右）:必须是 Side类型 diagonal: 斜线 side类型 diagonalDownd: 右斜线 bool diagonalDown: 左斜线 bool \u0026quot;\u0026quot;\u0026quot; # a1.border = border for item in ws['A1:E1'][0]: # 去元组中的每一个cell更改样式 item.border = border wb.save('./5a.xlsx') # 保存更改 再次注意！！！：\n不能使用 a1.border = border，否则只会如下图情况，B1：E1单元格没有线。我个人认为是因为线框涉及到相邻单元格边框的改动所以需要单独对每个单元格修改才行。 不能使用ws[\u0026lsquo;A1:E1\u0026rsquo;].border = border,由前面的内容可知，openpyxl的多个单元格其实是一个元组，而元组是没有style的方法的,所以必须一个一个改！！其实官方有其他办法，后面讲。\n按列或行设置样式 # 现在我们对整个表进行设置 # 读取 wb = load_workbook('./5a.xlsx') ws = wb['5a_'] # 读取数据表格范围 rows = ws.max_row cols = ws.max_column # 字体 font1 = Font(name='微软雅黑', size=11, b=True) font2 = Font(name='微软雅黑', size=11) # 边框 line_t = Side(style='thin', color='000000') # 细边框 line_m = Side(style='medium', color='000000') # 粗边框 border1 = Border(top=line_m, bottom=line_t, left=line_t, right=line_t) # 与标题相邻的边设置与标题一样 border2 = Border(top=line_t, bottom=line_t, left=line_t, right=line_t) # 填充 fill = PatternFill('solid', fgColor='CFCFCF') # 对齐 alignment = Alignment(horizontal='center', vertical='center') # 将样式打包命名 sty1 = NamedStyle(name='sty1', font=font1, fill=fill, border=border1, alignment=alignment) sty2 = NamedStyle(name='sty2', font=font2, border=border2, alignment=alignment) for r in range(2, rows+1): for c in range(1, cols): if r == 2: ws.cell(r, c).style = sty1 else: ws.cell(r, c).style = sty2 wb.save('./5a.xlsx') 最后： ","title":"Python利用openpyxl来操作Excel"},{"link":"https://blog.policx.com/posts/python-writer/","text":"现在支持python操作excel的包有下列这些 官网上最推荐的是openpyxl，其他包支持较老的excel版本。 xlsxwriter无法对打开的excel进行写操作，excel必须处于关闭状态才能写成功。\nxlswriter 基本代码： import xlsxwriter workbook = xlsxwriter.Workbook('hello.xlsx') worksheet = workbook.add_worksheet() worksheet.write('A1', 'Hello world') workbook.close() openpyxl基本代码： from openpyxl import Workbook wb = Workbook() ws = wb.active #设置单元格值 ws['A1'] = 42 #加入一行数据 ws.append([1, 2, 3]) import datetime #python 类型数据会被自动转换 ws['A2'] = datetime.datetime.now() #保存修改 wb.save(\u0026quot;sample.xlsx\u0026quot;) 来源:脚本之家\n","title":"python操作excel的包(openpyxl、xlsxwriter)"},{"link":"https://blog.policx.com/posts/2018/","text":"Being the richest man in the cemetery doesn\u0026rsquo;t matter to me \u0026hellip; Going to bed at night saying we\u0026rsquo;ve done something wonderful\u0026hellip; that\u0026rsquo;s what matters to me。\n是否能成为墓地里最富有的人，对我而言无足轻重。重要的是，当我晚上睡觉时，我可以说：我们今天完成了一些美妙的事。\n","title":"WWDC 2018"},{"link":"https://blog.policx.com/posts/pymongo/","text":"MongoDB是由C++语言编写的非关系型数据库，是一个基于分布式文件存储的开源数据库系统，其内容存储形式类似JSON对象，它的字段值可以包含其他文档、数组及文档数组，非常灵活。在这一节中，我们就来看看Python 3下MongoDB的存储操作。\n1. 准备工作 在开始之前，请确保已经安装好了MongoDB并启动了其服务，并且安装好了Python的PyMongo库。\n2. 连接MongoDB 连接MongoDB时，我们需要使用PyMongo库里面的MongoClient。一般来说，传入MongoDB的IP及端口即可，其中第一个参数为地址host，第二个参数为端口port（如果不给它传递参数，默认是27017）：\nimport pymongo client = pymongo.MongoClient(host='localhost', port=27017) 这样就可以创建MongoDB的连接对象了。\n另外，MongoClient的第一个参数host还可以直接传入MongoDB的连接字符串，它以mongodb开头，例如：\nclient = MongoClient('mongodb://localhost:27017/') 这也可以达到同样的连接效果。\n3. 指定数据库 MongoDB中可以建立多个数据库，接下来我们需要指定操作哪个数据库。这里我们以test数据库为例来说明，下一步需要在程序中指定要使用的数据库：\ndb = client.test 这里调用client的test属性即可返回test数据库。当然，我们也可以这样指定：\ndb = client['test'] 这两种方式是等价的。\n4. 指定集合 MongoDB的每个数据库又包含许多集合（collection），它们类似于关系型数据库中的表。\n下一步需要指定要操作的集合，这里指定一个集合名称为students。与指定数据库类似，指定集合也有两种方式： collection = db.students\ncollection = db['students'] 这样我们便声明了一个Collection对象。\n5. 插入数据 接下来，便可以插入数据了。对于students这个集合，新建一条学生数据，这条数据以字典形式表示：\nstudent = { 'id': '20170101', 'name': 'Jordan', 'age': 20, 'gender': 'male' } 这里指定了学生的学号、姓名、年龄和性别。接下来，直接调用collection的insert()方法即可插入数据，代码如下：\nresult = collection.insert(student) print(result) 在MongoDB中，每条数据其实都有一个_id属性来唯一标识。如果没有显式指明该属性，MongoDB会自动产生一个ObjectId类型的_id属性。insert()方法会在执行后返回_id值。\n运行结果如下：\n5932a68615c2606814c91f3d 当然，我们也可以同时插入多条数据，只需要以列表形式传递即可，示例如下：\nstudent1 = { 'id': '20170101', 'name': 'Jordan', 'age': 20, 'gender': 'male' } student2 = { 'id': '20170202', 'name': 'Mike', 'age': 21, 'gender': 'male' } result = collection.insert([student1, student2]) print(result) 返回结果是对应的_id的集合：\n[ObjectId('5932a80115c2606a59e8a048'), ObjectId('5932a80115c2606a59e8a049')] 实际上，在PyMongo 3.x版本中，官方已经不推荐使用insert()方法了。当然，继续使用也没有什么问题。官方推荐使用insert_one()和insert_many()方法来分别插入单条记录和多条记录，示例如下：\nstudent = { 'id': '20170101', 'name': 'Jordan', 'age': 20, 'gender': 'male' } result = collection.insert_one(student) print(result) print(result.inserted_id) 运行结果如下：\n\u0026lt;pymongo.results.InsertOneResult object at 0x10d68b558\u0026gt; 5932ab0f15c2606f0c1cf6c5 与insert()方法不同，这次返回的是InsertOneResult对象，我们可以调用其inserted_id属性获取_id。\n对于insert_many()方法，我们可以将数据以列表形式传递，示例如下：\n student1 = { 'id': '20170101', 'name': 'Jordan', 'age': 20, 'gender': 'male' } student2 = { 'id': '20170202', 'name': 'Mike', 'age': 21, 'gender': 'male' } result = collection.insert_many([student1, student2]) print(result) print(result.inserted_ids) 运行结果如下：\n\u0026lt;pymongo.results.InsertManyResult object at 0x101dea558\u0026gt; [ObjectId('5932abf415c2607083d3b2ac'), ObjectId('5932abf415c2607083d3b2ad')] 该方法返回的类型是InsertManyResult，调用inserted_ids属性可以获取插入数据的_id列表。\n6. 查询 插入数据后，我们可以利用find_one()或find()方法进行查询，其中find_one()查询得到的是单个结果，find()则返回一个生成器对象。示例如下：\nresult = collection.find_one({'name': 'Mike'}) print(type(result)) print(result) 这里我们查询name为Mike的数据，它的返回结果是字典类型，运行结果如下：\n\u0026lt;class 'dict'\u0026gt; {'_id': ObjectId('5932a80115c2606a59e8a049'), 'id': '20170202', 'name': 'Mike', 'age': 21, 'gender': 'male'} 可以发现，它多了_id属性，这就是MongoDB在插入过程中自动添加的。\n此外，我们也可以根据ObjectId来查询，此时需要使用bson库里面的objectid：\nfrom bson.objectid import ObjectId result = collection.find_one({'_id': ObjectId('593278c115c2602667ec6bae')}) print(result) 其查询结果依然是字典类型，具体如下：\n{'_id': ObjectId('593278c115c2602667ec6bae'), 'id': '20170101', 'name': 'Jordan', 'age': 20, 'gender': 'male'} 当然，如果查询结果不存在，则会返回None。\n对于多条数据的查询，我们可以使用find()方法。例如，这里查找年龄为20的数据，示例如下：\nresults = collection.find({'age': 20}) print(results) for result in results: print(result) 运行结果如下：\n\u0026lt;pymongo.cursor.Cursor object at 0x1032d5128\u0026gt; {'_id': ObjectId('593278c115c2602667ec6bae'), 'id': '20170101', 'name': 'Jordan', 'age': 20, 'gender': 'male'} {'_id': ObjectId('593278c815c2602678bb2b8d'), 'id': '20170102', 'name': 'Kevin', 'age': 20, 'gender': 'male'} {'_id': ObjectId('593278d815c260269d7645a8'), 'id': '20170103', 'name': 'Harden', 'age': 20, 'gender': 'male'} 返回结果是Cursor类型，它相当于一个生成器，我们需要遍历取到所有的结果，其中每个结果都是字典类型。\n如果要查询年龄大于20的数据，则写法如下：\nresults = collection.find({'age': {'$gt': 20}}) 这里查询的条件键值已经不是单纯的数字了，而是一个字典，其键名为比较符号$gt，意思是大于，键值为20。\n这里将比较符号归纳为下表。 腾讯云自媒体分享计划\n","title":"python3 与 MongoDB 之间的交互"},{"link":"https://blog.policx.com/posts/mongodb/","text":"MongoDB是一个跨平台，面向文档的数据库，提供高性能，高可用性和易于扩展。MongoDB是工作在集合和文档上一种概念。\n数据库  数据库是一个集合的物理容器。每个数据库获取其自己设定在文件系统上的文件。一个单一的MongoDB服务器通常有多个数据库。\n 集合  集合是一组MongoDB的文件。它与一个RDBMS表是等效的。一个集合存在于数据库中。集合不强制执行模式。集合中的文档可以有不同的字段。通常情况下，在一个集合中的所有文件都是类似或相关目的。\n 文档  文档是一组键值对。文档具有动态模式。动态模式是指，在同一个集合的文件不必具有相同一组集合的文档字段或结构，并且相同的字段可以保持不同类型的数据。 下面给出的示例显示了一个博客网站，仅仅是一个逗号分隔的键值对的文档结构。\n { _id: ObjectId(7df78ad8902c) title: 'MongoDB Overview', description: 'MongoDB is no sql database', by: 'yiibai tutorial', url: 'https://www.yiibai.com', tags: ['mongodb', 'database', 'NoSQL'], likes: 100, comments: [\t{ user:'user1', message: 'My first comment', dateCreated: new Date(2011,1,20,2,15), like: 0 }, { user:'user2', message: 'My second comments', dateCreated: new Date(2011,1,25,7,45), like: 5 } ] } 创建数据库  MongoDB use DATABASE_NAME 用于创建数据库。该命令如果数据库不存在，将创建一个新的数据库， 否则将返回现有的数据库。\n 语法 use DATABASE语句的基本语法如下： use DATABASE_NAME\n例子： 如果想创建一个数据库名称为 \u0026lt;mydb\u0026gt;, 那么 use DATABASE 语句应该如下： \u0026gt;use mydb switched to db mydb 要检查当前选择的数据库使用命令 db \u0026gt;db mydb 如果想查询数据库列表，那么使用命令 show dbs. \u0026gt;show dbs local 0.78125GB test 0.23012GB 所创建的数据库（mydb）不存在于列表中。要显示的数据库，需要至少插入一个文档进去。 \u0026gt;db.movie.insert({\u0026quot;name\u0026quot;:\u0026quot;yiibai tutorials\u0026quot;}) \u0026gt;show dbs local 0.78125GB mydb 0.23012GB test 0.23012GB MongoDB的默认数据库是test。 如果没有创建任何数据库，那么集合将被保存在测试数据库。\n删除数据库 MongoDB db.dropDatabase() 命令用于删除现有的数据库。\n语法 dropDatabase()指令的基本语法如下： db.dropDatabase()\n这将删除选定的数据库。如果没有选择任何数据库，那么它会删除默认的“test”数据库\n例子： 如果想删除新的数据库 , 那么 dropDatabase() 命令将如下所示：\n\u0026gt;use mydb switched to db mydb \u0026gt;db.dropDatabase() \u0026gt;{ \u0026quot;dropped\u0026quot; : \u0026quot;mydb\u0026quot;, \u0026quot;ok\u0026quot; : 1 } \u0026gt; 创建集合 MongoDB 的 db.createCollection(name, options) 用于创建集合。 在命令中, name 是要创建集合的名称。 Options 是一个文档，用于指定集合的配置\n   参数 类型 描述     Name String 要创建的集合的名称   Options Document （可选）指定有关内存大小和索引选项    选项参数是可选的，所以需要指定集合的唯一名字。\n语法 createCollection()方法的基本语法如下\n\u0026gt;use test switched to db test \u0026gt;db.createCollection(\u0026quot;mycollection\u0026quot;) { \u0026quot;ok\u0026quot; : 1 } \u0026gt; 可以通过使用 show collections 命令来检查创建的集合\n\u0026gt;show collections mycollection system.indexes 选项列表    字段 类型 描述     capped Boolean （可选）如果为true，它启用上限集合。上限集合是一个固定大小的集合，当它达到其最大尺寸会自动覆盖最老的条目。 如果指定true，则还需要指定参数的大小。   autoIndexID Boolean （可选）如果为true，自动创建索引_id字段。默认的值是 false.   size number （可选）指定的上限集合字节的最大尺寸。如果capped 是true，那么还需要指定这个字段。   max number （可选）指定上限集合允许的最大文件数。    尽管插入文档，MongoDB首先检查字段集合的上限大小，那么它会检查最大字段。\n语法 : \u0026gt;db.createCollection(\u0026quot;mycol\u0026quot;, { capped : true, autoIndexID : true, size : 6142800, max : 10000 } ) { \u0026quot;ok\u0026quot; : 1 } \u0026gt; 在MongoDB中并不需要创建集合。 当插入一些文档 MongoDB 会自动创建集合。\n\u0026gt;db.yiibai.insert({\u0026quot;name\u0026quot; : \u0026quot;yiibai\u0026quot;}) \u0026gt;show collections mycol mycollection system.indexes yiibai \u0026gt; 删除集合 MongoDB 的 db.collection.drop() 用于从数据库中删除集合。\n语法 drop() 命令的基本语法如下 db.COLLECTION_NAME.drop()\n例子： 下面给出的例子将删除给定名称的集合：mycollection\n\u0026gt;use mydb switched to db mydb \u0026gt;db.mycollection.drop() true \u0026gt; 插入文档 将数据插入到MongoDB集合，需要使用MongoDB 的 insert() 方法。\n语法 insert()命令的基本语法如下： \u0026gt;db.COLLECTION_NAME.insert(document)\n例子 \u0026gt;db.mycol.insert({ _id: ObjectId(7df78ad8902c), title: 'MongoDB Overview', description: 'MongoDB is no sql database', by: 'yiibai tutorials', url: 'https://www.yiibai.com', tags: ['mongodb', 'database', 'NoSQL'], likes: 100 }) 这里 mycol 是我们的集合名称，它是在之前的教程中创建。如果集合不存在于数据库中，那么MongoDB创建此集合，然后插入文档进去。\n在如果我们不指定_id参数插入的文档，那么 MongoDB 将为文档分配一个唯一的ObjectId。\n_id 是12个字节十六进制数在一个集合的每个文档是唯一的。 12个字节被划分如下： _id: ObjectId(4 bytes timestamp, 3 bytes machine id, 2 bytes process id, 3 bytes incrementer)\n要以单个查询插入多个文档，可以通过文档 insert() 命令的数组方式。\n例子 \u0026gt;db.post.insert([ { title: 'MongoDB Overview', description: 'MongoDB is no sql database', by: 'yiibai tutorials', url: 'https://www.yiibai.com', tags: ['mongodb', 'database', 'NoSQL'], likes: 100 }, { title: 'NoSQL Database', description: 'NoSQL database doesn't have tables', by: 'yiibai tutorials', url: 'https://www.yiibai.com', tags: ['mongodb', 'database', 'NoSQL'], likes: 20, comments: [\t{ user:'user1', message: 'My first comment', dateCreated: new Date(2013,11,10,2,35), like: 0 } ] } ]) 查询文档 要从集合查询MongoDB数据，需要使用MongoDB的 find()方法。\n语法 find()方法的基本语法如下 \u0026gt;db.COLLECTION_NAME.find() find() 方法将在非结构化的方式显示所有的文件。 如果显示结果是格式化的，那么可以用pretty() 方法。\n语法 \u0026gt;db.mycol.find().pretty()\n例子 \u0026gt;db.mycol.find().pretty() { \u0026quot;_id\u0026quot;: ObjectId(7df78ad8902c), \u0026quot;title\u0026quot;: \u0026quot;MongoDB Overview\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;MongoDB is no sql database\u0026quot;, \u0026quot;by\u0026quot;: \u0026quot;yiibai tutorials\u0026quot;, \u0026quot;url\u0026quot;: \u0026quot;https://www.yiibai.com\u0026quot;, \u0026quot;tags\u0026quot;: [\u0026quot;mongodb\u0026quot;, \u0026quot;database\u0026quot;, \u0026quot;NoSQL\u0026quot;], \u0026quot;likes\u0026quot;: \u0026quot;100\u0026quot; } \u0026gt; 除了find()方法还有findOne()方法，仅返回一个文档。\nRDBMS Where子句等效于MongoDB 查询文档在一些条件的基础上，可以使用下面的操作\n   操作 语法 示例 RDBMS等效语句     Equality {\u0026lt;key\u0026gt;:\u0026lt;value\u0026gt;} db.mycol.find({\u0026ldquo;by\u0026rdquo;:\u0026ldquo;yiibai tutorials\u0026rdquo;}).pretty() where by = \u0026lsquo;yiibai tutorials\u0026rsquo;   Less Than {\u0026lt;key\u0026gt;:{$lt:\u0026lt;value\u0026gt;}} db.mycol.find({\u0026ldquo;likes\u0026rdquo;:{$lt:50}}).pretty() where likes \u0026lt; 50   Less Than Equals {\u0026lt;key\u0026gt;:{$lte:\u0026lt;value\u0026gt;}} db.mycol.find({\u0026ldquo;likes\u0026rdquo;:{$lte:50}}).pretty() where likes \u0026lt;= 50   Greater Than {\u0026lt;key\u0026gt;:{$gt:\u0026lt;value\u0026gt;}} db.mycol.find({\u0026ldquo;likes\u0026rdquo;:{$gt:50}}).pretty() where likes \u0026gt; 50   Greater Than Equals {\u0026lt;key\u0026gt;:{$gte:\u0026lt;value\u0026gt;}} db.mycol.find({\u0026ldquo;likes\u0026rdquo;:{$gte:50}}).pretty() where likes \u0026gt;= 50   Not Equals {\u0026lt;key\u0026gt;:{$ne:\u0026lt;value\u0026gt;}} db.mycol.find({\u0026ldquo;likes\u0026rdquo;:{$ne:50}}).pretty() where likes != 50    AND 在 MongoDB 语法 在 find()方法，如果您传递多个键通过\u0026quot;,\u0026ldquo;将它们分开，那么MongoDB对待它就如AND条件一样。基本语法如下所示： \u0026gt;db.mycol.find({key1:value1, key2:value2}).pretty()\n例子 下面给出的例子将显示所有教程含“yiibai tutorials”和其标题是“MongoDB Overview”\n\u0026gt;db.mycol.find({\u0026quot;by\u0026quot;:\u0026quot;yiibai tutorials\u0026quot;,\u0026quot;title\u0026quot;: \u0026quot;MongoDB Overview\u0026quot;}).pretty() { \u0026quot;_id\u0026quot;: ObjectId(7df78ad8902c), \u0026quot;title\u0026quot;: \u0026quot;MongoDB Overview\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;MongoDB is no sql database\u0026quot;, \u0026quot;by\u0026quot;: \u0026quot;yiibai tutorials\u0026quot;, \u0026quot;url\u0026quot;: \u0026quot;https://www.yiibai.com\u0026quot;, \u0026quot;tags\u0026quot;: [\u0026quot;mongodb\u0026quot;, \u0026quot;database\u0026quot;, \u0026quot;NoSQL\u0026quot;], \u0026quot;likes\u0026quot;: \u0026quot;100\u0026quot; } \u0026gt; 对于上面给出的例子相当于where子句：' where by=\u0026lsquo;yiibai tutorials\u0026rsquo; AND title=\u0026lsquo;MongoDB Overview\u0026rsquo; \u0026lsquo;。可以传递任何数目的键-值对在find子句。\nOR 在 MongoDB 语法 要查询基于OR条件的文件，需要使用$or关键字。OR的基本语法如下所示：\n\u0026gt;db.mycol.find( { $or: [ {key1: value1}, {key2:value2} ] } ).pretty() 例子 下面给出的例子将显示所有撰写含有 \u0026lsquo;yiibai tutorials\u0026rsquo; 或是标题为 \u0026lsquo;MongoDB Overview\u0026rsquo; 的教程\n\u0026gt;db.mycol.find({$or:[{\u0026quot;by\u0026quot;:\u0026quot;tutorials point\u0026quot;},{\u0026quot;title\u0026quot;: \u0026quot;MongoDB Overview\u0026quot;}]}).pretty() { \u0026quot;_id\u0026quot;: ObjectId(7df78ad8902c), \u0026quot;title\u0026quot;: \u0026quot;MongoDB Overview\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;MongoDB is no sql database\u0026quot;, \u0026quot;by\u0026quot;: \u0026quot;yiibai tutorials\u0026quot;, \u0026quot;url\u0026quot;: \u0026quot;https://www.yiibai.com\u0026quot;, \u0026quot;tags\u0026quot;: [\u0026quot;mongodb\u0026quot;, \u0026quot;database\u0026quot;, \u0026quot;NoSQL\u0026quot;], \u0026quot;likes\u0026quot;: \u0026quot;100\u0026quot; } \u0026gt; 使用 AND 和 OR 在一起 例子 下面给出的例子显示有喜欢数大于100 的文档，其标题要么是 \u0026lsquo;MongoDB Overview\u0026rsquo; 或 \u0026lsquo;yiibai tutorials\u0026rsquo;. 等效于SQL的where子句：\u0026lsquo;where likes\u0026gt;10 AND (by = \u0026lsquo;yiibai tutorials\u0026rsquo; OR title = \u0026lsquo;MongoDB Overview\u0026rsquo;)\u0026rsquo;\n\u0026gt;db.mycol.find(\u0026quot;likes\u0026quot;: {$gt:10}, $or: [{\u0026quot;by\u0026quot;: \u0026quot;yiibai tutorials\u0026quot;}, {\u0026quot;title\u0026quot;: \u0026quot;MongoDB Overview\u0026quot;}] }).pretty() { \u0026quot;_id\u0026quot;: ObjectId(7df78ad8902c), \u0026quot;title\u0026quot;: \u0026quot;MongoDB Overview\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;MongoDB is no sql database\u0026quot;, \u0026quot;by\u0026quot;: \u0026quot;yiibai tutorials\u0026quot;, \u0026quot;url\u0026quot;: \u0026quot;https://www.yiibai.com\u0026quot;, \u0026quot;tags\u0026quot;: [\u0026quot;mongodb\u0026quot;, \u0026quot;database\u0026quot;, \u0026quot;NoSQL\u0026quot;], \u0026quot;likes\u0026quot;: \u0026quot;100\u0026quot; } \u0026gt; 更新文档 MongoDB的update()和save()方法用于更新文档到一个集合。 update()方法将现有的文档中的值更新，而save()方法使用传递到save()方法的文档替换现有的文档。\nMongoDB Update() 方法 语法 update()方法的基本语法如下\n\u0026gt;db.COLLECTION_NAME.update(SELECTIOIN_CRITERIA, UPDATED_DATA) 例子 考虑mycol集合有如下数据。\n{ \u0026quot;_id\u0026quot; : ObjectId(5983548781331adf45ec5), \u0026quot;title\u0026quot;:\u0026quot;MongoDB Overview\u0026quot;} { \u0026quot;_id\u0026quot; : ObjectId(5983548781331adf45ec6), \u0026quot;title\u0026quot;:\u0026quot;NoSQL Overview\u0026quot;} { \u0026quot;_id\u0026quot; : ObjectId(5983548781331adf45ec7), \u0026quot;title\u0026quot;:\u0026quot;Yiibai Yiibai Overview\u0026quot;} 下面的例子将设置其标题“MongoDB Overview”的文件为新标题为“New MongoDB Tutorial”\n\u0026gt;db.mycol.update({'title':'MongoDB Overview'},{$set:{'title':'New MongoDB Tutorial'}}) \u0026gt;db.mycol.find() { \u0026quot;_id\u0026quot; : ObjectId(5983548781331adf45ec5), \u0026quot;title\u0026quot;:\u0026quot;New MongoDB Tutorial\u0026quot;} { \u0026quot;_id\u0026quot; : ObjectId(5983548781331adf45ec6), \u0026quot;title\u0026quot;:\u0026quot;NoSQL Overview\u0026quot;} { \u0026quot;_id\u0026quot; : ObjectId(5983548781331adf45ec7), \u0026quot;title\u0026quot;:\u0026quot;Yiibai Tutorial Overview\u0026quot;} \u0026gt; 默认情况下，MongoDB将只更新单一文件，更新多，需要一个参数 \u0026lsquo;multi\u0026rsquo; 设置为 true。\n\u0026gt;db.mycol.update({'title':'MongoDB Overview'},{$set:{'title':'New MongoDB Tutorial'}},{multi:true}) MongoDB Save() 方法 save() 方法取代，通过新文档到 save()方法\n语法 mongodb 的 save()方法如下所示的基本语法： \u0026gt;db.COLLECTION_NAME.save({_id:ObjectId(),NEW_DATA})\n例子 下面的例子将替换该文件_id \u0026lsquo;5983548781331adf45ec7\u0026rsquo;\n\u0026gt;db.mycol.save( { \u0026quot;_id\u0026quot; : ObjectId(5983548781331adf45ec7), \u0026quot;title\u0026quot;:\u0026quot;Yiibai Yiibai New Topic\u0026quot;, \u0026quot;by\u0026quot;:\u0026quot;Yiibai Yiibai\u0026quot; } ) \u0026gt;db.mycol.find() { \u0026quot;_id\u0026quot; : ObjectId(5983548781331adf45ec5), \u0026quot;title\u0026quot;:\u0026quot;Yiibai Yiibai New Topic\u0026quot;, \u0026quot;by\u0026quot;:\u0026quot;Yiibai Yiibai\u0026quot;} { \u0026quot;_id\u0026quot; : ObjectId(5983548781331adf45ec6), \u0026quot;title\u0026quot;:\u0026quot;NoSQL Overview\u0026quot;} { \u0026quot;_id\u0026quot; : ObjectId(5983548781331adf45ec7), \u0026quot;title\u0026quot;:\u0026quot;Yiibai Yiibai Overview\u0026quot;} \u0026gt; 删除文档 MongoDB 的 remove()方法用于从集合中删除文档。remove()方法接受两个参数。一个是标准缺失，第二是justOne标志 deletion criteria : 根据文件（可选）删除条件将被删除。 justOne : （可选）如果设置为true或1，然后取出只有一个文档。\n语法 remove()方法的基本语法如下 \u0026gt;db.COLLECTION_NAME.remove(DELLETION_CRITTERIA)\n例子 考虑mycol集合有如下数据。\n{ \u0026quot;_id\u0026quot; : ObjectId(5983548781331adf45ec5), \u0026quot;title\u0026quot;:\u0026quot;MongoDB Overview\u0026quot;} { \u0026quot;_id\u0026quot; : ObjectId(5983548781331adf45ec6), \u0026quot;title\u0026quot;:\u0026quot;NoSQL Overview\u0026quot;} { \u0026quot;_id\u0026quot; : ObjectId(5983548781331adf45ec7), \u0026quot;title\u0026quot;:\u0026quot;Yiibai Yiibai Overview\u0026quot;} 下面的例子将删除所有的文件，其标题为 \u0026lsquo;MongoDB Overview\u0026rsquo;\n\u0026gt;db.mycol.remove({'title':'MongoDB Overview'}) \u0026gt;db.mycol.find() { \u0026quot;_id\u0026quot; : ObjectId(5983548781331adf45ec6), \u0026quot;title\u0026quot;:\u0026quot;NoSQL Overview\u0026quot;} { \u0026quot;_id\u0026quot; : ObjectId(5983548781331adf45ec7), \u0026quot;title\u0026quot;:\u0026quot;Yiibai Toturials Overview\u0026quot;} \u0026gt; 只删除一个 如果有多个记录，并要删除仅第一条记录，然后在 remove()方法设置参数 justOne 。 \u0026gt;db.COLLECTION_NAME.remove(DELETION_CRITERIA,1)\n删除所有文件 如果没有指定删除条件，则MongoDB将从集合中删除整个文件。这相当于SQL的 truncate 命令。\n\u0026gt;db.mycol.remove() \u0026gt;db.mycol.find() \u0026gt; MongoDB投影 mongodb投影意义是只选择需要的数据，而不是选择整个一个文档的数据。如果一个文档有5个字段，只需要显示3个，只从中选择3个字段。\nMongoDB的find()方法，解释了MongoDB中查询文档接收的第二个可选的参数是要检索的字段列表。在MongoDB中，当执行find()方法，那么它会显示一个文档的所有字段。要限制这一点，需要设置字段列表值为1或0。1是用来显示字段，而0被用来隐藏字段。\n语法\nfind()方法的基本语法如下 \u0026gt;db.COLLECTION_NAME.find({},{KEY:1})\n例子\n考虑集合 myycol 有下列数据\n{ \u0026quot;_id\u0026quot; : ObjectId(5983548781331adf45ec5), \u0026quot;title\u0026quot;:\u0026quot;MongoDB Overview\u0026quot;} { \u0026quot;_id\u0026quot; : ObjectId(5983548781331adf45ec6), \u0026quot;title\u0026quot;:\u0026quot;NoSQL Overview\u0026quot;} { \u0026quot;_id\u0026quot; : ObjectId(5983548781331adf45ec7), \u0026quot;title\u0026quot;:\u0026quot;Yiibai Yiibai Overview\u0026quot;} 下面的例子将显示文档的标题，在查询文档时。\n\u0026gt;db.mycol.find({},{\u0026quot;title\u0026quot;:1,_id:0}) {\u0026quot;title\u0026quot;:\u0026quot;MongoDB Overview\u0026quot;} {\u0026quot;title\u0026quot;:\u0026quot;NoSQL Overview\u0026quot;} {\u0026quot;title\u0026quot;:\u0026quot;Yiibai Yiibai Overview\u0026quot;} \u0026gt; 请注意在执行find()方法时_id字段始终显示，如果不想要显示这个字段，那么需要将其设置为0\n限制文档 MongoDB Limit() 方法\n要在MongoDB中限制记录，需要使用limit()方法。 limit() 方法接受一个数字类型的参数，这是要显示的文档数量。\n语法 limit()方法的基本语法如下 \u0026gt;db.COLLECTION_NAME.find().limit(NUMBER)\n例子\n考虑集合 myycol 有下列数据\n{ \u0026quot;_id\u0026quot; : ObjectId(5983548781331adf45ec5), \u0026quot;title\u0026quot;:\u0026quot;MongoDB Overview\u0026quot;} { \u0026quot;_id\u0026quot; : ObjectId(5983548781331adf45ec6), \u0026quot;title\u0026quot;:\u0026quot;NoSQL Overview\u0026quot;} { \u0026quot;_id\u0026quot; : ObjectId(5983548781331adf45ec7), \u0026quot;title\u0026quot;:\u0026quot;Yiibai Yiibai Overview\u0026quot;} 下面的例子将只显示2个文档，在查询文档时。\n\u0026gt;db.mycol.find({},{\u0026quot;title\u0026quot;:1,_id:0}).limit(2) {\u0026quot;title\u0026quot;:\u0026quot;MongoDB Overview\u0026quot;} {\u0026quot;title\u0026quot;:\u0026quot;NoSQL Overview\u0026quot;} \u0026gt; 如果不指定 limit()方法的参数数量，然后它会显示集合中的所有文档。\nMongoDB Skip() 方法\n除了 limit()方法还有一个方法 skip()也接受数字类型参数并用于跳过文件数。\n语法\nskip() 方法的基础语法如下所示： \u0026gt;db.COLLECTION_NAME.find().limit(NUMBER).skip(NUMBER)\n例子：\n下面的例子将仅显示第二个文档。\n\u0026gt;db.mycol.find({},{\u0026quot;title\u0026quot;:1,_id:0}).limit(1).skip(1) {\u0026quot;title\u0026quot;:\u0026quot;NoSQL Overview\u0026quot;} \u0026gt; 请注意，skip() 方法的默认值是 0\n文档排序 要排序MongoDB中的文档，需要使用 sort()方法。 sort() 方法接受一个包含字段列表以及排序顺序的文档。 要使用1和-1指定排序顺序。1用于升序，而-1是用于降序。\n语法\nsort()方法的基本语法如下 \u0026gt;db.COLLECTION_NAME.find().sort({KEY:1})\n例子\n考虑集合 myycol 有如下数据\n{ \u0026quot;_id\u0026quot; : ObjectId(5983548781331adf45ec5), \u0026quot;title\u0026quot;:\u0026quot;MongoDB Overview\u0026quot;} { \u0026quot;_id\u0026quot; : ObjectId(5983548781331adf45ec6), \u0026quot;title\u0026quot;:\u0026quot;NoSQL Overview\u0026quot;} { \u0026quot;_id\u0026quot; : ObjectId(5983548781331adf45ec7), \u0026quot;title\u0026quot;:\u0026quot;Yiibai Yiibai Overview\u0026quot;} 下面的例子将显示的文件排序按标题降序排序。\n\u0026gt;db.mycol.find({},{\u0026quot;title\u0026quot;:1,_id:0}).sort({\u0026quot;title\u0026quot;:-1}) {\u0026quot;title\u0026quot;:\u0026quot;Yiibai Yiibai Overview\u0026quot;} {\u0026quot;title\u0026quot;:\u0026quot;NoSQL Overview\u0026quot;} {\u0026quot;title\u0026quot;:\u0026quot;MongoDB Overview\u0026quot;} \u0026gt; 请注意，如果不指定排序类型，那么 sort() 方法将以升序排列文档。\nMongoDB索引 索引支持查询高效率执行。如果没有索引，MongoDB必须扫描集合中的每一个文档，然后选择那些符合查询语句的文档。若需要 mongod 来处理大量数据，扫描是非常低效的。\n索引是特殊的数据结构，存储在一个易于设置遍历形式的数据的一小部分。索引存储在索引中指定特定字段的值或一组字段，并排序字段的值。\n要创建索引，需要使用MongoDB的ensureIndex()方法。\n语法\nensureIndex()方法的基本语法如下 \u0026gt;db.COLLECTION_NAME.ensureIndex({KEY:1})\n这里键是要创建索引字段，1是按名称升序排序。若以按降序创建索引，需要使用 -1.\n例子\n\u0026gt;db.mycol.ensureIndex({\u0026quot;title\u0026quot;:1}) \u0026gt; 在 ensureIndex()方法，可以通过多个字段，来创建多个字段索引。 \u0026gt;db.mycol.ensureIndex({\u0026quot;title\u0026quot;:1,\u0026quot;description\u0026quot;:-1}) \u0026gt; ensureIndex() 方法还接受选项列表（这是可选），其列表如下： MongoDB 聚合 聚合操作处理数据记录并返回计算结果。从多个文档聚合分组操作数值，并可以执行多种对分组数据业务返回一个结果。 在SQL中的count(*)，使用group by 与mongodb的聚合是等效的。 对于MongoDB的聚合，使用的是aggregate()方法。\n语法\naggregate()方法的基本语法如下 \u0026gt;db.COLLECTION_NAME.aggregate(AGGREGATE_OPERATION)\n例子：\n在集合中有以下数据：\n{ _id: ObjectId(7df78ad8902c) title: 'MongoDB Overview', description: 'MongoDB is no sql database', by_user: 'Yiibai Yiibai ', url: 'https://www.yiibai.com', tags: ['mongodb', 'database', 'NoSQL'], likes: 100 }, { _id: ObjectId(7df78ad8902d) title: 'NoSQL Overview', description: 'No sql database is very fast', by_user: 'Yiibai Yiibai', url: 'https://www.yiibai.com', tags: ['mongodb', 'database', 'NoSQL'], likes: 10 }, { _id: ObjectId(7df78ad8902e) title: 'Neo4j Overview', description: 'Neo4j is no sql database', by_user: 'Neo4j', url: 'https://www.neo4j.com', tags: ['neo4j', 'database', 'NoSQL'], likes: 750 }, 现在从上面的集合，如果想知道每一个用户编写的教程是多少，那么使用aggregate()方法，如下图所示的列表：\n\u0026gt; db.mycol.aggregate([{$group : {_id : \u0026quot;$by_user\u0026quot;, num_tutorial : {$sum : 1}}}]) { \u0026quot;result\u0026quot; : [ { \u0026quot;_id\u0026quot; : \u0026quot;Yiibai Yiibai\u0026quot;, \u0026quot;num_tutorial\u0026quot; : 2 }, { \u0026quot;_id\u0026quot; : \u0026quot;Neo4j\u0026quot;, \u0026quot;num_tutorial\u0026quot; : 1 } ], \u0026quot;ok\u0026quot; : 1 } \u0026gt; 用于上述用途将等效于sql查询： select by_user, count(*) from mycol group by by_user  另外，在上述例子中，我们已经使用字段by_user进行分组并计算总和，也就是by_user 出现各个次数。一个列表中可用的聚集表达式。 MongoDB 复制 复制是同步在多个服务器上的数据过程。复制提供了冗余和数据在不同的数据库服务器上的多个副本提高数据的可用性，复制防止在单个服务器上丢失数据库。 复制也可以从硬件故障和服务中断中恢复。带有数据的其他副本，可以选择其中一个灾难恢复，报告或备份。\n为什么要复制？   为了让数据安全 数据的高（24*7）可用性 灾难恢复 无停机维护（如备份，索引重建，压缩） 读取缩放（额外的副本来读取） 副本集是透明的应用   MongoDB复制的工作原理 MongoDB通过使用副本集的复制来实现。副本集是一组承载同一个数据集的mongod实例。在副本的一个节点是接收所有的写操作主节点。所有的实例，次级，应用操作从主以便它们具有相同的数据集。副本集只能有一个主节点。\n  副本集是一组两个或更多个节点（通常至少3节点是必需的）。 在副本集一个节点是主节点和其余的节点都是次要的。 所有的数据复制是从主到次节点。 在自动故障转移或维护时，选建立了主要和一个新的主节点被选择。 故障节点的恢复后，再次加入副本集，并可以作为一个辅助节点。   mongodb复制的典型图如下图，其中客户端应用程序总是与主节点和主节点交互，然后将数据复制到辅助节点。 副本集特征\n   N个节点的集群     任何节点可为原发/主节点     所有的写操作进入到主节点     自动故障转移     自动恢复   ","title":"MongoDB"},{"link":"https://blog.policx.com/posts/pymysql/","text":"什么是 PyMySQL？ PyMySQL 是在 Python3.x 版本中用于连接 MySQL 服务器的一个库，Python2中则使用mysqldb。\nPyMySQL 遵循 Python 数据库 API v2.0 规范，并包含了 pure-Python MySQL 客户端库。\n安装mysql模块 在文件中引入模块\nimport pymysql\n1.Connection对象 • 用于建立与数据库的连接 • 创建对象：调用connect()方法 conn=connect(参数列表) • 参数host：连接的mysql主机，如果本机是\u0026rsquo;localhost' • 参数port：连接的mysql主机的端口，默认是3306 • 参数db：数据库的名称 • 参数user：连接的用户名 • 参数password：连接的密码 • 参数charset：通信采用的编码方式，默认是\u0026rsquo;gb2312'，要求与数据库创建时指定的编码一致，否则中文会乱码\n2.对象的方法 • close()关闭连接 • commit()事务，所以需要提交才会生效 • rollback()事务，放弃之前的操作 • cursor()返回Cursor对象，用于执行sql语句并获得结果\nCursor对象 • 执行sql语句 • 创建对象：调用Connection对象的cursor()方法 cursor1=conn.cursor()\n对象的方法 • close()关闭 • execute(operation [, parameters ])执行语句，返回受影响的行数 • fetchone()执行查询语句时，获取查询结果集的第一个行数据，返回一个元组 • next()执行查询语句时，获取当前行的下一行 • fetchall()执行查询时，获取结果集的所有行，一行构成一个元组，再将这些元组装入一个元组返回 • scroll(value[,mode])将行指针移动到某个位置 • mode表示移动的方式 • mode的默认值为relative，表示基于当前行移动到value，value为正则向下移动，value为负则向上移动。相对的 • mode的值为absolute，表示基于第一条数据的位置，第一条数据的位置为0，绝对的。\n举个例子便于理解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  # 导入python操作mysql的模块 import pymysql # 获取连接对象 conn = pymysql.connect(host=\u0026#39;127.0.0.1\u0026#39;, user=\u0026#39;root\u0026#39;, password=\u0026#39;123456\u0026#39;, database=\u0026#39;python01\u0026#39;, port=3306, charset=\u0026#39;utf8\u0026#39;) # 获取执行工具 cur = conn.cursor() # sql语句,增删改 #sql = \u0026#39;select birthday from t_user\u0026#39; sql = \u0026#39;select id,name,pwd,birthday from t_user\u0026#39; # 执行,返回值。如果是增删改，返回受影响的行数，如果是查询，返回查询的行数 count = cur.execute(sql) print(\u0026#39;查询的结果有%s条数据\u0026#39;%count) #获取第一行 dateOne = cur.fetchone() print(dateOne) #向上移动一行 cur.scroll(-1) #向下移动一行 cur.scroll(1) cur.scroll(1,mode=\u0026#39;absolute\u0026#39;) 绝对的，这里指的是第一行 cur.scroll(1,mode=\u0026#39;relative\u0026#39;) 相对的 #获取所有行的数据 dataAll = cur.fetchall() print(dataAll) for temp in dataAll: print(temp) print(dataAll[-1][2]) #dataAll[-1]得到的是一个用户所有的信息，dataAll[-1][2]获取最后一个人的密码 for temp in cur: print(temp) s = \u0026#39;id:%s,name:%s,pwd:%s,birthday:%s\u0026#39; for temp in dataAll: print(s%(temp[0],temp[1],temp[2],temp[3])) # 关闭 cur.close() conn.close()   3.对象的属性 • rowcount只读属性，表示最近一次execute()执行后受影响的行数 • connection获得当前连接对象\n2.增删改查(CRUD) 1.增 • 创建testInsert.py文件，向学生表中插入一条数据\n#encoding=utf-8 import pymysql try: conn=pymysql.connect(host='localhost',port=3306,db='test1',user='root',passwd='mysql',charset='utf8') cs1=conn.cursor() count=cs1.execute(\u0026quot;insert into students(sname) values('张良')\u0026quot;) print(count) conn.commit() cs1.close() conn.close() except Exception,e: print(e) 2.修改 • 创建testUpdate.py文件，修改学生表的一条数据\n#encoding=utf-8 import pymysql try: conn=pymysql.connect(host='localhost',port=3306,db='test1',user='root',passwd='mysql',charset='utf8') cs1=conn.cursor() count=cs1.execute(\u0026quot;update students set sname='刘邦' where id=6\u0026quot;) print(count) conn.commit() cs1.close() conn.close() except Exception,e: print(e) 3.删除 • 创建testDelete.py文件，删除学生表的一条数据\n#encoding=utf-8 import pymysql try: conn=pymysql.connect(host='localhost',port=3306,db='test1',user='root',passwd='mysql',charset='utf8') cs1=conn.cursor() count=cs1.execute(\u0026quot;delete from students where id=6\u0026quot;) print(count) conn.commit() cs1.close() conn.close() except Exception as e: print(e) 4.查 • 创建testSelectOne.py文件，查询一条学生信息\nimport Pymysql try: conn=Pymysql.connect(host='localhost',port=3306,db='test1',user='root',passwd='mysql',charset='utf8') cur=conn.cursor() cur.execute('select * from students where id=7') result=cur.fetchone() print result cur.close() conn.close() except Exception as e: print(e) • 创建testSelectMany.py文件，查询全部学生信息\n#encoding=utf8 import Pymysql try: conn=Pymysql.connect(host='localhost',port=3306,db='test1',user='root',passwd='mysql',charset='utf8') cur=conn.cursor() cur.execute('select * from students') result=cur.fetchall() print result cur.close() conn.close() except Exception as e: print(e) 实例一：参数  # 导入python操作mysql的模块 import pymysql import time # 获取连接对象 conn = pymysql.connect(host='127.0.0.1', user='root', password='123456', database='python01', port=3306, charset='utf8') # 获取执行工具 cur = conn.cursor() # sql语句,增删改，sql注入 sql = 'insert into t_user(name,pwd,birthday) values(%s,%s,%s)' # 参数列表 name = input('输入姓名:') pwd = input('输入密码:') birthday = input('输入生日:') # 2017年10月01日--\u0026gt;日期struct_time(---\u0026gt;2017-10-01) birthday = time.strptime(birthday,'%Y年%m月%d日') #这里我们就用到了时间与字符串的相互转换(详情见MySQL高级) params = [name,pwd,birthday] # 执行,返回值。如果是增删改，返回受影响的行数，如果是查询，返回查询的行数 count = cur.execute(sql,params) #提交 conn.commit() print('受影响的行数:%s'%count) # 关闭 cur.close() conn.close() 实例二：抛出异常 # 导入python操作mysql的模块 import pymysql try: conn = None cur = None # 获取连接对象 conn = pymysql.connect(host='127.0.0.1', user='root', password='123456', database='python01', port=3306, charset='utf8') # 模拟异常 # a = 1 / 0 # 获取执行工具 cur = conn.cursor() # sql语句,增删改 sql = 'insert into t_user(name,pwd,birthday) values(\u0026quot;小伊\u0026quot;,\u0026quot;123456\u0026quot;,str_to_date(\u0026quot;2017年10月20日\u0026quot;,\u0026quot;%Y年%m月%d日\u0026quot;))' # 执行,返回值。如果是增删改，返回受影响的行数，如果是查询，返回查询的行数 count = cur.execute(sql) # 提交 conn.commit() print('受影响的行数:%s' % count) except Exception as ex: # 打印异常信息，测试时候使用，项目上线，去掉 print(str(ex)) # 将异常继续抛出 # raise finally: if cur != None: cur.close() if conn != None: conn.close() 实例三：  # 导入python操作mysql的模块 import pymysql # 获取连接对象 conn = pymysql.connect(host='127.0.0.1', user='root', password='123456', database='python01', port=3306, charset='utf8') # 获取执行工具 cur = conn.cursor() # sql语句,增删改 #sql = 'select birthday from t_user' sql = 'select id,name,pwd,birthday from t_user' # 执行,返回值。如果是增删改，返回受影响的行数，如果是查询，返回查询的行数 count = cur.execute(sql) print('查询的结果有%s条数据'%count) #获取第一行 # dateOne = cur.fetchone() # print(dateOne) # for temp in cur: # print(temp) s = 'id:%s,name:%s,pwd:%s,birthday:%s' for temp in dataAll: print(s%(temp[0],temp[1],temp[2],temp[3])) # 关闭 cur.close() conn.close() 3.封装 这个库的名字：mySqlHelper\npython操作mysql进行增删改查的封装\n1、增删改，代码类似 2、查询 代码分析 1、获取连接对象 2、sql语句不同，参数不同 3、获取执行对象 增删改 查询 1、fetchone 2、fetchall 4、处理结果 5、关闭  面向对象 建立类，封装属性和函数 import pymysql class MysqlHelper: '''python操作mysql的增删改查的封装''' def __init__(self, host, user, password, database, port=3306, charset='utf8'): ''' 初始化参数 :param host: 主机 :param user: 用户名 :param password: 密码 :param database: 数据库 :param port: 端口号，默认是3306 :param charset: 编码，默认是utf8 ''' self.host = host self.port = port self.database = database self.user = user self.password = password self.charset = charset def connect(self): ''' 获取连接对象和执行对象 :return: ''' self.conn = pymysql.connect(host=self.host, user=self.user, password=self.password, database=self.database, port=self.port, charset=self.charset) self.cur = self.conn.cursor() def fetchone(self, sql, params=None): ''' 根据sql和参数获取一行数据 :param sql: sql语句 :param params: sql语句对象的参数元组，默认值为None :return: 查询的一行数据 ''' dataOne = None try: count = self.cur.execute(sql, params) if count != 0: dataOne = self.cur.fetchone() except Exception as ex: print(ex) finally: self.close() return dataOne def fetchall(self, sql, params=None): ''' 根据sql和参数获取一行数据 :param sql: sql语句 :param params: sql语句对象的参数列表，默认值为None :return: 查询的一行数据 ''' dataall = None try: count = self.cur.execute(sql, params) if count != 0: dataall = self.cur.fetchall() except Exception as ex: print(ex) finally: self.close() return dataall def __item(self, sql, params=None): ''' 执行增删改 :param sql: sql语句 :param params: sql语句对象的参数列表，默认值为None :return: 受影响的行数 ''' count = 0 try: count = self.cur.execute(sql, params) self.conn.commit() except Exception as ex: print(ex) finally: self.close() return count def update(self, sql, params=None): ''' 执行修改 :param sql: sql语句 :param params: sql语句对象的参数列表，默认值为None :return: 受影响的行数 ''' return self.__item(sql, params) def insert(self, sql, params=None): ''' 执行新增 :param sql: sql语句 :param params: sql语句对象的参数列表，默认值为None :return: 受影响的行数 ''' return self.__item(sql, params) def delete(self, sql, params=None): ''' 执行删除 :param sql: sql语句 :param params: sql语句对象的参数列表，默认值为None :return: 受影响的行数 ''' return self.__item(sql, params) def close(self): ''' 关闭执行工具和连接对象 ''' if self.cur != None: self.cur.close() if self.conn != None: self.conn.close() 1.测试查询多条数据 import mysqlHelper # 初始化对象 helper = mysqlHelper.MysqlHelper('127.0.0.1', 'root', '123456', 'python01') # 连接 helper.connect() # sql sql = 'select * from t_user where name = %s and id \u0026gt; %s' # params params = ['小茗',1] # 执行 data = helper.fetchall(sql, params) # 判断 if data: for temp in data: print(temp) else: # None,False,0 print('没有数据.') helper.close() 2.测试查询一条数据 import mysqlHelper # 初始化对象 helper = mysqlHelper.MysqlHelper('127.0.0.1', 'root', '123456', 'python01') # 连接 helper.connect() # sql sql = 'select * from t_user where id = %s' #sql = 'select * from t_user where id = 1' # params params = [2] # 执行 data = helper.fetchone(sql, params) #data = helper.fetchone(sql) # 判断 if data: print(data) else: # None,False,0 print('没有数据.') 3.测试增删改 import mysqlHelper import time # 初始化对象 helper = mysqlHelper.MysqlHelper('127.0.0.1', 'root', '123456', 'python01') # 连接 helper.connect() # sql sql = 'update t_user set name =%s,pwd=%s,birthday=%s where id=%s' # params id = input('输入编号:') name = input('输入姓名:') pwd = input('输入密码:') birthday = time.strptime(input('输入生日:'), '%Y年%m月%d日') params = [name, pwd, birthday,id] # 执行 count = helper.update(sql, params) # 判断 if count: print('操作成功.') else: # None,False,0 print('操作失败.') 4.登录和注册 登录和注册的时候需要对密码进行加密\n注意：\n• 需要对密码进行加密 • 如果使用md5加密，则密码包含32个字符 • 如果使用sha1加密，则密码包含40个字符，这里使用这种方式\ncreate table userinfos( id int primary key auto_increment, uname varchar(20), upwd char(40), isdelete bit default 0 ); /* ret = doPwd('123') print(ret) 结果：40bd001563085fc35165329ea1ff5c5ecbdbbeef */ -- 插入如下数据，用户名为123,密码为123,这是sha1加密后的值 insert into userinfos values(1,'123','40bd001563085fc35165329ea1ff5c5ecbdbbeef',0); 登录与注册  from mysqlHelper import MysqlHelper import hashlib def login(): '''登录''' name = input('输入用户名:') pwd = input('输入密码:') #加密 pwd = doPwd(pwd) helper = MysqlHelper('127.0.0.1', 'root', '123456', 'python01') helper.connect() sql = 'select * from t_user where name=%s and pwd=%s' params = [name, pwd] data = helper.fetchone(sql, params) if data: print('登录成功.') else: # None,False,0 print('登录失败.') def doPwd(pwd): '''sha1编码''' mysha1 = hashlib.sha1() mysha1.update(pwd.encode('utf-8')) pwd = mysha1.hexdigest() return pwd def register(): '''注册''' name = input('输入用户名:') pwd = input('输入密码:') # 加密 pwd = doPwd(pwd) helper = MysqlHelper('127.0.0.1', 'root', '123456', 'python01') helper.connect() sql = 'insert into t_user(name,pwd) values(%s,%s)' params = [name, pwd] count = helper.insert(sql, params) if count: print('操作成功.') else: # None,False,0 print('操作失败.') if __name__ == '__main__': #register() login() ","title":"python3 与 MySQL 之间的交互"},{"link":"https://blog.policx.com/posts/django-bi-ji/","text":"Django是一个开放源代码的Web应用框架，由Python写成。采用了MTV的框架模式，即模型M，视图V和模版T。它最初是被开发来用于管理劳伦斯出版集团旗下的一些以新闻内容为主的网站的，即是CMS（内容管理系统）软件。并于2005年7月在BSD许可证下发布。这套框架是以比利时的吉普赛爵士吉他手Django Reinhardt来命名的。\n一. 版本选择 Django 2.0.x 支持 Python 3.4, 3.5 和 3.6 （注意，不再支持 Python 2）\n二. 安装 Django 2.1. 用 pip 来安装\n2.1.1 需要先安装pip\n(1). Linux, Mac OSX, Windows 下都可用 get-pip.py 来安装 pip：https://pip.pypa.io/en/latest/installing.html 或者直接下载：get-pip.py 然后运行在终端运行 python get-pip.py 就可以安装 pip。\nNote: 也可以下载 pip 源码包，运行 python setup.py install 进行安装\n2.1.2 利用 pip 安装 Django\n（sudo) pip install Django 或者 (sudo) pip install Django==1.8.16 或者 pip install Django==1.11.8\n如果想升级 pip 可以用：\n(sudo) pip install --upgrade pip  2.2. 下载源码安装\nhttps://www.djangoproject.com/download/\n如果是源码包, 比如 django-1.11.8.tar.gz\n2.2.1 Linux 或 Mac 下\ntar -xvf django-1.11.8.tar.gz cd django-1.11.8 (sudo) python setup.py install  三. 检查是否安装成功 终端上输入 python ,点击 Enter，进行 python 环境\n\u0026gt;\u0026gt;\u0026gt; import django \u0026gt;\u0026gt;\u0026gt; django.VERSION (1, 11, 8, 'final', 0) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; django.get_version() '1.11.8'  如果运行后看到版本号，就证明安装成功了！\n四. 搭建多个互不干扰的开发环境（可选） 我们有的时候会发现，一个电脑上有多个项目，一个依赖 Django 1.8，另一个比较旧的项目又要用 Django 1.5，这时候怎么办呢？\n我们需要一个依赖包管理的工具来处理不同的环境。\n4.1 虚拟环境依赖安装 开发会用 virtualenv 来管理多个开发环境\nLinux/MacOS 下\nvirtualenvwrapper 使得virtualenv变得更好用，所以我们一起安装了\n# 安装: (sudo) pip install virtualenv virtualenvwrapper  修改~/.bash_profile或其它环境变量相关文件(如 .bashrc 或用 ZSH 之后的 .zshrc)，添加以下语句\nexport WORKON_HOME=$HOME/.virtualenvs export PROJECT_HOME=$HOME/workspace source /usr/local/bin/virtualenvwrapper.sh  修改后使之立即生效(也可以重启终端使之生效)：\nsource ~/.bash_profile  4.2 虚拟环境使用方法： mkvirtualenv zqxt：创建运行环境zqxt\nworkon zqxt: 工作在 zqxt 环境 或 从其它环境切换到 zqxt 环境\ndeactivate: 退出终端环境\n其它的：\nrmvirtualenv ENV：删除运行环境ENV\nmkproject mic：创建mic项目和运行环境mic\nmktmpenv：创建临时运行环境\nlsvirtualenv: 列出可用的运行环境\nlssitepackages: 列出当前环境安装了的包\n创建的环境是独立的，互不干扰，无需sudo权限即可使用 pip 来进行包的管理。\n","title":"Django笔记"},{"link":"https://blog.policx.com/posts/django/","text":"用Django写了个小网站，只能在自己本地跑一跑！这怎么行？听说可以部署在云服务器上，这样别人就可以访问了!\n环境：\npython3.6 centos 7 Django1.11 1、本地跑起来Django 这里不讲Django项目实施过程，假设你已经写了一个Django项目，并且在本地127.0.0.1:8000能够跑起来。喏，给你个参考，项目大概长这样：  kindle目录为我创建的Django App  2、修改项目配置 也就是项目目录下的settings.py文件，主要强调几个地方：\n①关闭DEBUG模式： ②修改ALLOWED_HOSTS： ③配置静态文件存放路径： 修改好配置之后执行: python manage.py collectstatic 将项目用到的静态文件复制到项目根目录下的static文件中 3、安装uwsgi和Nginx 这个没什么说的。。。在自己的云服务器上装好这两个工具 安装好uwsgi后最好验证一下，验证方法： 创建一个test.py文件：\ndef application(env, start_response): start_response('200 OK', [('Content-Type', 'text/html')]) return [b'Hello world!'] #python3 # return ['Hello world!'] #python2 启动uwsgi服务器：\nuwsgi --http :8000 --wsgi-file test.py 如果可以正常启动而不报错那就应该没问题，不放心的话再在终端验证一下： wget https://127.0.0.1:8000 看一下能否正确获取内容\n4、配置项目的uwsgi 在项目所在文件夹下创建uwsgi.ini配置文件，也就是这里: 在uwsgi.ini里进行如下配置：\n[uwsgi] # Django-related settings # 这里的端口可以根据自己需要设定 socket = 127.0.0.1:8001 # the base directory (full path) # 这个是Django项目的根目录，也就是包含App的那个目录，仔细对照上图 chdir = /home/python/book2kindle # Django s wsgi file # 这里是项目名(不是App名).wsgi module = book2kindle.wsgi # process-related settings # master master = true # maximum number of worker processes processes = 32 # ... with appropriate permissions - may be needed # chmod-socket = 664 # clear environment on exit vacuum = true plugin python = true # 这个是项目的虚拟python环境，如果没用虚拟环境，可以不设定 home = /home/python/book2kindle_env 5、配置项目的nginx 找到nginx的配置文件夹，centos7的nginx配置文件在/etc/nginx下，该路径下有一个nginx.conf总配置文件，还有两个文件夹./conf.d、./default.d，我们将nginx.conf复制一份到conf.d文件夹下，命名为nginx.conf（或者项目名.conf）进行如下修改（根据中文注释进行相应配置即可）：\nhttp { upstream django { # 注意这里的server要和uwsgi.ini配置文件中的socket保持一致 server 127.0.0.1:8002; # for a web port socket } server { listen 80; server_name xxx.com; # 这里填自己的域名或者服务器的ip（决定你今后访问网站的方式） charset utf-8; root /usr/share/nginx/html; location / { root /home/python/book2kindle/kindle; # 这是Django App的路径 uwsgi_pass django; include uwsgi_params; # the uwsgi_params file you installed } location /static { # Django项目静态文件的路径 alias /home/python/book2kindle/static; } } } 6、启动uwsgi和nginx 进入uwsgi.ini文件夹下执行： uwsgi --ini uwsgi.ini 在终端执行： service nginx restart 然后就可以根据域名（前提是要将域名解析到服务器ip地址）或者服务器ip来访问网站了！\nOK，完事！就是这么简单！\n","title":"Django部署——uwsgi+Nginx"},{"link":"https://blog.policx.com/posts/chuangye/","text":"   创业路上危机四伏，如何破局？ 很多朋友在2018年做出了改变，迈出了新的一步。比如身边几位朋友正摩拳擦掌准备创业。然而，看别人创业和自己创业完全是两回事儿，见得再多，自己趟水时也难免有所顾虑。\n在跟他们聊过之后，我们发现了他们普遍面临的一个课题：如何选择合伙人?这是身经百战的连续创业者也很难驾轻就熟的一个课题，今天我们就来一起聊聊。本文将从能不能和朋友一起创业、合伙人应该与我互补还是相似、如何判断双方是否志同道合、如何应对常见的分歧几个部分展开来说。\n风物长宜放眼量，抱持开阔的胸襟、敏锐的判断、坚韧的意志，相信大家能够与志同道合的伙伴一起，越过山丘，携手站上梦想之巅。\n能不能和朋友一起创业？ 在创业初期，创业者选择合伙人往往会从身边的朋友“下手”。\n一起创业可以说是认清一个朋友的最好方式。一篇名为《友谊的代价》的论文，考察了3510个风险投资者，以及他们在1975-2003年间11895个投资项目。\n论文写道，有的人选择与自己能力相当的人合作，比如同是名校毕业；但更多的人选择与自己的熟人合作，比如曾经的同学或同事。结果表明，按能力搭档可以增加投资的成功概率，而找熟人搭档，则会明显降低成功的可能性。\n所有人都喜欢强联系，但关系是关系，工作归工作。现在社会学已经有了足够多的证据说明：对工作来说，同乡会和校友录并不是扩展人脉的好地方。《中国合伙人》这部电影上映后，“千万别跟好朋友合伙开公司”也成了热议话题。电影的最后，三位合伙人分道扬镳，而剧本的原型——新东方的三位创始人也以“分家”收场。\n当然，朋友合伙创业成功的案例也不在少数，况且，长期的伙伴关系更有助于共同面对创业过程中的艰难险阻，团队也更容易在创业初期获得投资人的青睐。如果在寻找合伙人的过程中，你觉得还是某个朋友更适合，那么一定要在合作之前约法三章，考虑到最坏的情况，提前用书面合同的方式确定双方的责权利，用规章制度来约束指导双方的行为，而不是靠人情关系。\n中间一旦觉得发生了问题，你就必须考虑一下能否继续合作下去。其实，很多合作者走不到最后就是因为中间的小问题没有解决，一点一点积累最后爆发出来。\n因此，能否和朋友一起创业这个问题，需要辩证思考。如果朋友间相互了解对方的个性和能力，工作中能做到分工明确，用规章制度来规范双方的行为，及时解决小矛盾，相互照顾，一起分担，共同奋斗，那么创业成功就会成为大概率事件。\n合伙人应该与我互补还是相似？ 一个较为合理的答案是：理念和价值观上要相似，能力和经验上要互补。\n理念和价值观上的相近，可以保证你们在重大原则问题上的判断是比较一致的，不至于出现根本性的冲突。这些重大的原则问题包括企业的战略方向、利益分配机制、做事的基本底线等等。\n在这些问题上出现不同意见，通常很难取得共识。因为个性和价值观的形成，通常都不是一朝一夕的事情，也就是我们常说的“江山易改，本性难移”。如果在创业的艰难环境下，双方还要来磨合这个层面的东西，就会非常痛苦。\n能力和经验上的互补相对更好理解。你擅长产品，他专于研发；你有丰富的运营经验，他则对于商业模式的建立更有心得；你对数字不敏感，他则是投资和财务领域的资深人士。这些都是很好的互补。\n互补可以让你们在具体事情的推进中事半功倍，并建立起对于对方在专业领域的依靠和信任。人不可能是全能的，如果一切未知的领域都需要你自己来摸索，费时费力不说，风险还很大。\n对于相似还是互补这个问题的解读，还可以反向进行。比如你们是能力经验上的相近，而在理念上互补，你可以想象一下是个什么局面，一定是你不会的他也不会，你觉得对的他觉得不对，那就真的很难合作下去了。\n如何判断双方是否志同道合？ 对于这个问题，不同的人可能会给出非常不同的答案。雷军就曾说过，他找人有两个要素：“一要最专业，小米的合伙人都是各管一块，这样能保证整个决策非常快，把业务交给他，要能实打实做出成绩来；二要最合适，主要是指要有创业心态，对所做的事要极度喜欢，有共同的愿景，这样就会有很强的驱动力。”\n雷军说，他在三个月的时间里见了超过100位做硬件的人选，终于找到了负责硬件的联合创始人周光平博士，两人第一次见面就谈了12个小时。\n而周鸿祎表示，他会选择具备这四种素质的合伙人：首先应该有创业精神；其次要有很强的学习能力；第三，要有很好的开放合作心态；此外，还要能自我激励，自我驱动，同样一件事，用打工的心态和用创业的心态做，效果完全不一样。\n虽然答案因人而异，但仍然可以总结出一些判断标准，以下几条可为你选择合伙人时提供参考。\n1、关系有一定的深度和广度，彼此信任 共事且维持朋友关系多年的创业团队关系更深，有可能经受住紧张和冲突的考验。合伙人未必需要成为最要好的朋友，但如果他们相互喜欢的话事情可能会更好办些。更重要的是，创始人之间应该尊重彼此以及他们给团队带来的不同能力。不信任合伙人的能力会导致手伸过头，还可能会导致控制权之争。在这种窝里斗的情况下大部分的合作关系都无法维系。\n2、了解彼此的优势和劣势，分工明确 尊重彼此的技能和优势并不意味着创始人就不需要审视合伙人的弱点了。友谊更久自然也会更了解某人的特长和技能。这些不同的技能有助于创始人团队自然地分清责任、角色，在某些情况下还可以分清头衔。根据每一位合伙人的技能明确划分职责，对创业的帮助很大。做事的时候每个人要有独立的角色，但同时永远要对其他合伙人的反馈持开放态度。\n3、确保所有合伙人对成功和失败的定义一致 韧性最强的创始人不会从财务的角度去衡量自己的初创企业是否成功，相反，他们会从使命的角度去衡量。他们的初创企业只是追求实现使命的手段。但是，并不是所有的创始人都这么看，甚至一开始关注使命的创始人有时候到后面也会转向考虑财务方面的事情。\n有的创始人可能志存高远，为了尽快做大愿意烧很多钱，而有的人希望逐步打磨产品，限制人数规模和保留现金尺度。不仅对成功的认知会影响运营决策，对失败的认知同样会起作用。\n在创业过程中，其中一位合伙人急着退出的故事屡见不鲜，因此这个教训值得一提再提。对于拥有成功企业的创始人来说，避免在这个问题上发生冲突的关键是定期讨论这件事。应该在公司早期就设定好目标，并且对这个话题进行定期复议。\n4、所有合伙人均应对股权分配满意 哈佛教授Wasserman发现，73%的联合创业团队一般在公司成立30天内就确定了如何进行股权分配。股权分配当然是任何共同创业的人都要首先考虑的事情之一，但事实上在那个时候，没人知道谁干活最卖力，谁对初创企业的贡献最有价值。过早确定股权分配会导致后面发生问题。如果可以的话，最好等到你有机会了解大家一起工作会是什么个情况后再正式分蛋糕。话虽如此，这件事情还是不要拖太久，围绕股权的分歧最好在公司早期就解决掉。\n5、永远要相互支持 这话听上去似乎太空泛，但是合伙人的关系也可能会反复无常，尤其是在受到不同观点、董事会成员等的影响下。合伙人之间的相互支持可带来信心，确保合伙人和员工都有共同的使命感。\n团队应该早点理解一件事，任何情况下合伙人之间都应该背靠背相互支持，所以合伙人要尽量避免当着员工、董事会等人的面互相拆台，这样能够让公司其他人感觉到他们友情之牢固，让每一位合伙人都能保持镇定，因为他们知道对方一定会支持自己的。\n如何应对常见的分歧？ 1、公司走向的歧见 在0到1的探索期，公司的走向往往是由合伙人一起决定的。但进入1到100的扩张期，一个年轻企业通常会开始有董事会以及重要的供应、通路伙伴。久而久之，合伙人对于公司未来走向的看法，常常会越来越变得分歧。\n防范这个陷阱要从根源开始：每当CEO有了新的资讯、成长、学习、领悟，应该积极地与合伙人分享，协助他们获得与你类似的成长。同时，你应该把小范围的决策授权出去，让他们也能继续主导公司某一部分的走向。最后，你应该积极管理大家对决策的期望值，新创公司必须在“快”与“好”之间做出平衡，因此决策求的是多数对，而不是样样对。\n2、无法适应制度 0到1的新创团队求快，因此不会有太多制度。进入1到100阶段，公司势必要开始建立一些管理系统，以在风险与发展中间取得平衡。\n有些习惯了说干就干的合伙人，在此时会产生严重的不适应，时间一长甚至会觉得公司背离了创办的初衷。要解决这个问题，除了及早发现及早辅导外，请他们参与、主导制度的设计，也是协助合伙人适应新制度的方法。\n3、越权管理 当公司开始有部门、部门主管，合伙人还是习惯看不顺眼就管，容易造成经理人的困扰。更有甚者，造成合伙人对经理人不信任，反而让经理人没有足够的时间、空间去适应、学习。这个问题通常是惯性使然，重点就是要打破它。所以，看到这样的行为要赶快提醒伙伴们注意。\n4、无法跟上公司成长的需要 在公司快速扩张期，一个3人产品团队可能在一年内成长为30人，而两者之间管理上的不同，常常会让本来擅长技术、产品，但从来没有管理中大型团队经验的合伙人一时间跟不上公司发展的步伐。\n回到扩张前，你应该早早找到好的CTO Mentor，在扩张中，经常鼓励他在管理知识与能力上精进。扩张后，如果他真的无法适应，也比较能够接受去寻找更有经验的CTO，而自己退居部门二把手、三把手。\n5、利益分配 当公司越来越成功、越赚钱、离IPO越近，股权与利益的问题就会越容易产生。尤其当初的股权分配如果没有彰显每个合伙人的相对价值，那团队中可能酝酿出不良情绪。\n比较好的方法当然是早期就把这个问题解决掉，因为到了后期，你的工具会越来越有限。但也不是没有机会修正，如果有合伙人离开，你可以收回他的股权来重新分配。如果有B、C、D轮增资，你可以跟投资人要求“期权池”(ESOP)，通过发放新的选择权来平衡。最后，如果真的过于集中，负责任的CEO，甚至会拿出自己的股权分配给伙伴们。\n选择合伙人未必有一定之规，创业路上可能遇到的危机也远远不止上述这些，希望这篇文章能对你有所裨益，助你在创业路上少走弯路，也祝愿创业者们在2018年博得好彩头，大鹏一日同风起，扶摇直上九万里。\n本文来源：联想之星\n","title":"2018创业记：如何选择合伙人？"},{"link":"https://blog.policx.com/posts/markdown/","text":"Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。\n主要内容  Markdown是什么？ 谁创造了它？ 为什么要使用它？ 怎么使用？ 谁在用？ 尝试一下  正文 1. Markdown是什么？ Markdown是一种轻量级标记语言，它以纯文本形式(易读、易写、易更改)编写文档，并最终以HTML格式发布。 Markdown也可以理解为将以MARKDOWN语法编写的语言转换成HTML内容的工具。\n2. 谁创造了它？ 它由Aaron Swartz和John Gruber共同设计，Aaron Swartz就是那位于（2013年1月11日）自杀,有着开挂一般人生经历的程序员。维基百科对他的介绍是：软件工程师、作家、政治组织者、互联网活动家、维基百科人。\n他有着足以让你跪拜的人生经历：\n 14岁参与RSS 1.0规格标准的制订。 2004年入读斯坦福，之后退学。 2005年创建Infogami，之后与Reddit合并成为其合伙人。 2010年创立求进会（Demand Progress），积极参与禁止网络盗版法案（SOPA）活动，最终该提案被撤回。 2011年7月19日，因被控从MIT和JSTOR下载480万篇学术论文并以免费形式上传于网络被捕。 2013年1月自杀身亡。  天才都有早逝的归途。\n3. 为什么要使用它？  它是易读（看起来舒服）、易写（语法简单）、易更改纯文本。处处体现着极简主义的影子。 兼容HTML，可以转换为HTML格式发布。 跨平台使用。 越来越多的网站支持Markdown。 更方便清晰地组织你的电子邮件。（Markdown-here, Airmail） 摆脱Word（我不是认真的）。  4. 怎么使用？ 如果不算扩展，Markdown的语法绝对简单到让你爱不释手。\nMarkdown语法主要分为如下几大部分： 标题，段落，区块引用，代码区块，强调，列表，分割线，链接，图片，反斜杠 \\，符号'`'。\n4.1 标题 两种形式：\n1）使用=和-标记一级和二级标题。\n 一级标题\n=========\n二级标题 ---------\n 效果：\n 一级标题 二级标题  2）使用#，可表示1-6级标题。\n # 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n 效果：\n 一级标题 二级标题 三级标题 四级标题 五级标题 六级标题  4.2 段落 段落的前后要有空行，所谓的空行是指没有文字内容。若想在段内强制换行的方式是使用两个以上空格加上回车（引用中换行省略回车）。\n4.3 区块引用 在段落的每行或者只在第一行使用符号\u0026gt;,还可使用多个嵌套引用，如：\n \u0026gt; 区块引用\n\u0026gt;\u0026gt; 嵌套引用\n 效果：\n 区块引用\n 嵌套引用\n  4.4 代码区块 代码区块的建立是在每行加上4个空格或者一个制表符（如同写代码一样）。如 普通段落：\nvoid main() { printf(\u0026ldquo;Hello, Markdown.\u0026quot;); }\n代码区块：\nvoid main() { printf(\u0026quot;Hello, Markdown.\u0026quot;); }  注意:需要和普通段落之间存在空行。\n4.5 强调 在强调内容两侧分别加上*或者_，如：\n *斜体*，_斜体_ **粗体**，__粗体__\n 效果：\n 斜体，斜体 粗体，粗体\n 4.6 列表 使用·、+、或-标记无序列表，如：\n -（+*） 第一项 -（+*） 第二项 - （+*）第三项\n 注意：标记后面最少有一个_空格_或_制表符_。若不在引用区块中，必须和前方段落之间存在空行。\n效果：\n  第一项 第二项 第三项   有序列表的标记方式是将上述的符号换成数字,并辅以.，如：\n 1 . 第一项\n2 . 第二项 3 . 第三项\n 效果：\n  第一项 第二项 第三项   4.7 分割线 分割线最常使用就是三个或以上*，还可以使用-和_。\n4.8 链接 链接可以由两种形式生成：行内式和参考式。 行内式：\n [younghz的Markdown库](https:://github.com/younghz/Markdown \u0026ldquo;Markdown\u0026rdquo;)。\n 效果：\n younghz的Markdown库。\n 参考式：\n [younghz的Markdown库1][1] [younghz的Markdown库2][2] [1]:https:://github.com/younghz/Markdown \u0026ldquo;Markdown\u0026rdquo; [2]:https:://github.com/younghz/Markdown \u0026ldquo;Markdown\u0026rdquo;\n 效果：\n younghz的Markdown库1 younghz的Markdown库2\n 注意：上述的[1]:https:://github.com/younghz/Markdown \u0026quot;Markdown\u0026quot;不出现在区块中。\n4.9 图片 添加图片的形式和链接相似，只需在链接的基础上前方加一个！。\n4.10 反斜杠\\ 相当于反转义作用。使符号成为普通符号。\n4.11 符号'`' 起到标记作用。如：\n `ctrl+a`\n 效果：\n ctrl+a\n 4.12 视频 \u0026lt;video src=\u0026quot;http://edge.ivideo.sina.com.cn/141482942.mp4?KID=sina,viask\u0026amp;Expires=1567699200\u0026amp;ssig=%2Fs0kCHwHJQ\u0026quot; width=\u0026quot;320\u0026quot; height=\u0026quot;180\u0026quot; controls=\u0026quot;controls\u0026quot;\u0026gt;\u0026lt;/video\u0026gt; \n4.13 换行: 方法1: 连续两个以上空格+回车 方法2：使用html语言换行标签：\u0026lt;br\u0026gt; 首行缩进两个字符：(每个表示一个空格，连续使用两个即可）\n\u0026amp;ensp; 半角的空格 \u0026amp;emsp; 全角的空格 4.14 字体、字号、颜色和背景色: 1）字体，字号和颜色编辑如下代码  Markdown是一种可以使用普通文本编辑器编写的标记语言，通过类似HTML的标记语法，它可以使普通文本内容具有一定的格式。但是它本身是不支持修改字体、字号与颜色等功能的！\n \u0026lt;font face=\u0026quot;黑体\u0026quot;\u0026gt;我是黑体字\u0026lt;/font\u0026gt; \u0026lt;font face=\u0026quot;微软雅黑\u0026quot;\u0026gt;我是微软雅黑\u0026lt;/font\u0026gt; \u0026lt;font face=\u0026quot;STCAIYUN\u0026quot;\u0026gt;我是华文彩云\u0026lt;/font\u0026gt; \u0026lt;font color=#0099ff size=7 face=\u0026quot;黑体\u0026quot;\u0026gt;color=#0099ff size=72 face=\u0026quot;黑体\u0026quot;\u0026lt;/font\u0026gt; \u0026lt;font color=#00ffff size=72\u0026gt;color=#00ffff\u0026lt;/font\u0026gt; \u0026lt;font color=gray size=72\u0026gt;color=gray\u0026lt;/font\u0026gt; Size：规定文本的尺寸大小。可能的值：从 1 到 7 的数字。浏览器默认值是 3 我是黑体字 我是微软雅黑 我是华文彩云 color=#0099ff size=3 face=\u0026ldquo;黑体\u0026rdquo; color=#00ffff color=gray\n2）背景色:  Markdown本身不支持背景色设置，需要采用内置html的方式实现：借助 table, tr, td 等表格标签的 bgcolor 属性来实现背景色的功能。举例如下：\n \u0026lt;table\u0026gt;\u0026lt;tr\u0026gt;\u0026lt;td bgcolor=AliceBlue\u0026gt;背景色是：AliceBlue\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt;\u0026lt;/table\u0026gt; 背景色是：AliceBlue 具体颜色分类及标记请参照： RGB颜色表  5. 谁在用？ Markdown的使用者：\n GitHub 简书 Stack Overflow Apollo Moodle Reddit 等等  6. 尝试一下  Chrome下的插件诸如stackedit与markdown-here等非常方便，也不用担心平台受限。 在线的dillinger.io评价也不错 Windowns下的MarkdownPad也用过，不过免费版的体验不是很好。 Mac下的Mou是国人贡献的，口碑很好。 Linux下的ReText不错。  当然，最终境界永远都是笔下是语法，心中格式化 :)。\n 注意：不同的Markdown解释器或工具对相应语法（扩展语法）的解释效果不尽相同，具体可参见工具的使用说明。 虽然有人想出面搞一个所谓的标准化的Markdown，[创始人John Gruber] (https://blog.codinghorror.com/standard-markdown-is-now-common-markdown/ )。\n 以上基本是所有traditonal markdown的语法。\n其它： 列表的使用(非traditonal markdown)：\n用|表示表格纵向边界，表头和表内容用-隔开，并可用:进行对齐设置，两边都有:则表示居中，若不加:则默认左对齐。\n   代码库 链接     MarkDown https://github.com/younghz/Markdown   MarkDownCopy https://github.com/younghz/Markdown     \nRGB颜色表     实色效果 英文名称  R.G.B  16色  \u0026nbsp; Snow  255 250 250  #FFFAFA  \u0026nbsp; GhostWhite 248 248 255  #F8F8FF  \u0026nbsp; WhiteSmoke 245 245 245  #F5F5F5  \u0026nbsp; Gainsboro 220 220 220 #DCDCDC  \u0026nbsp; FloralWhite 255 250 240  #FFFAF0  \u0026nbsp; OldLace 253 245 230  #FDF5E6  \u0026nbsp; Linen 250 240 230  #FAF0E6  \u0026nbsp; AntiqueWhite 250 235 215  #FAEBD7  \u0026nbsp; PapayaWhip 255 239 213  #FFEFD5  \u0026nbsp; BlanchedAlmond 255 235 205  #FFEBCD  \u0026nbsp; Bisque 255 228 196  #FFE4C4  \u0026nbsp; PeachPuff 255 218 185  #FFDAB9  \u0026nbsp; NavajoWhite 255 222 173  #FFDEAD  \u0026nbsp; Moccasin 255 228 181  #FFE4B5  \u0026nbsp; Cornsilk 255 248 220  #FFF8DC  \u0026nbsp; Ivory 255 255 240  #FFFFF0  \u0026nbsp; LemonChiffon 255 250 205  #FFFACD  \u0026nbsp; Seashell 255 245 238  #FFF5EE  \u0026nbsp; Honeydew 240 255 240  #F0FFF0  \u0026nbsp; MintCream 245 255 250  #F5FFFA  \u0026nbsp; Azure 240 255 255  #F0FFFF  \u0026nbsp; AliceBlue 240 248 255  #F0F8FF  \u0026nbsp; lavender 230 230 250  #E6E6FA  \u0026nbsp; LavenderBlush 255 240 245  #FFF0F5  \u0026nbsp; MistyRose 255 228 225  #FFE4E1  \u0026nbsp; White 255 255 255  #FFFFFF  \u0026nbsp; Black 0 0 0  #000000  \u0026nbsp; DarkSlateGray 47 79 79  #2F4F4F  \u0026nbsp; DimGrey 105 105 105  #696969  \u0026nbsp; SlateGrey 112 128 144  #708090  \u0026nbsp; LightSlateGray 119 136 153  #778899  \u0026nbsp; Grey 190 190 190  #BEBEBE  \u0026nbsp; LightGray 211 211 211  #D3D3D3  \u0026nbsp; MidnightBlue 25 25 112  #191970  \u0026nbsp; NavyBlue 0 0 128  #000080  \u0026nbsp; CornflowerBlue 100 149 237  #6495ED  \u0026nbsp; DarkSlateBlue 72 61 139  #483D8B  \u0026nbsp; SlateBlue 106 90 205  #6A5ACD  \u0026nbsp; MediumSlateBlue 123 104 238  #7B68EE  \u0026nbsp; LightSlateBlue 132 112 255  #8470FF  \u0026nbsp; MediumBlue 0 0 205  #0000CD  \u0026nbsp; RoyalBlue 65 105 225  #4169E1  \u0026nbsp; Blue  0 0 255  #0000FF  \u0026nbsp; DodgerBlue 30 144 255  #1E90FF  \u0026nbsp; DeepSkyBlue 0 191 255  #00BFFF  \u0026nbsp; SkyBlue 135 206 235  #87CEEB  \u0026nbsp; LightSkyBlue 135 206 250  #87CEFA  \u0026nbsp; SteelBlue 70 130 180  #4682B4  \u0026nbsp; LightSteelBlue 176 196 222  #B0C4DE  \u0026nbsp; LightBlue 173 216 230  #ADD8E6  \u0026nbsp; PowderBlue 176 224 230  #B0E0E6  \u0026nbsp; PaleTurquoise 175 238 238  #AFEEEE  \u0026nbsp; DarkTurquoise 0 206 209  #00CED1  \u0026nbsp; MediumTurquoise 72 209 204  #48D1CC  \u0026nbsp; Turquoise 64 224 208  #40E0D0  \u0026nbsp; Cyan  0 255 255  #00FFFF  \u0026nbsp; LightCyan 224 255 255  #E0FFFF  \u0026nbsp; CadetBlue 95 158 160  #5F9EA0  \u0026nbsp; MediumAquamarine 102 205 170  #66CDAA  \u0026nbsp; Aquamarine 127 255 212  #7FFFD4  \u0026nbsp; DarkGreen 0 100 0  #006400  \u0026nbsp; DarkOliveGreen 85 107 47  #556B2F  \u0026nbsp; DarkSeaGreen 143 188 143  #8FBC8F  \u0026nbsp; SeaGreen 46 139 87  #2E8B57  \u0026nbsp; MediumSeaGreen 60 179 113  #3CB371  \u0026nbsp; LightSeaGreen 32 178 170  #20B2AA  \u0026nbsp; PaleGreen 152 251 152  #98FB98  \u0026nbsp; SpringGreen 0 255 127  #00FF7F  \u0026nbsp; LawnGreen 124 252 0  #7CFC00  \u0026nbsp; Green 0 255 0  #00FF00  \u0026nbsp; Chartreuse 127 255 0  #7FFF00  \u0026nbsp; MedSpringGreen 0 250 154  #00FA9A  \u0026nbsp; GreenYellow 173 255 47  #ADFF2F  \u0026nbsp; LimeGreen 50 205 50  #32CD32  \u0026nbsp; YellowGreen 154 205 50  #9ACD32  \u0026nbsp; ForestGreen 34 139 34  #228B22  \u0026nbsp; OliveDrab 107 142 35  #6B8E23  \u0026nbsp; DarkKhaki 189 183 107  #BDB76B  \u0026nbsp; PaleGoldenrod 238 232 170  #EEE8AA  \u0026nbsp; LtGoldenrodYello 250 250 210  #FAFAD2  \u0026nbsp; LightYellow 255 255 224  #FFFFE0  \u0026nbsp; Yellow 255 255 0  #FFFF00  \u0026nbsp; Gold  255 215 0  #FFD700  \u0026nbsp; LightGoldenrod 238 221 130  #EEDD82  \u0026nbsp; goldenrod 218 165 32  #DAA520  \u0026nbsp; DarkGoldenrod 184 134 11  #B8860B  \u0026nbsp; RosyBrown 188 143 143  #BC8F8F  \u0026nbsp; IndianRed 205 92 92  #CD5C5C  \u0026nbsp; SaddleBrown 139 69 19  #8B4513  \u0026nbsp; Sienna 160 82 45  #A0522D  \u0026nbsp; Peru  205 133 63  #CD853F  \u0026nbsp; Burlywood 222 184 135  #DEB887  \u0026nbsp; Beige 245 245 220  #F5F5DC  \u0026nbsp; Wheat 245 222 179  #F5DEB3  \u0026nbsp; SandyBrown 244 164 96  #F4A460  \u0026nbsp; Tan  210 180 140  #D2B48C  \u0026nbsp; Chocolate 210 105 30  #D2691E  \u0026nbsp; Firebrick 178 34 34  #B22222  \u0026nbsp; Brown 165 42 42  #A52A2A  \u0026nbsp; DarkSalmon 233 150 122  #E9967A  \u0026nbsp; Salmon 250 128 114  #FA8072  \u0026nbsp; LightSalmon 255 160 122  #FFA07A  \u0026nbsp; Orange 255 165 0  #FFA500  \u0026nbsp; DarkOrange 255 140 0  #FF8C00  \u0026nbsp; Coral 255 127 80  #FF7F50  \u0026nbsp; LightCoral 240 128 128  #F08080  \u0026nbsp; Tomato 255 99 71  #FF6347  \u0026nbsp; OrangeRed 255 69 0  #FF4500  \u0026nbsp; Red  255 0 0  #FF0000  \u0026nbsp; HotPink 255 105 180  #FF69B4  \u0026nbsp; DeepPink 255 20 147  #FF1493  \u0026nbsp; Pink  255 192 203  #FFC0CB  \u0026nbsp; LightPink 255 182 193  #FFB6C1  \u0026nbsp; PaleVioletRed 219 112 147  #DB7093  \u0026nbsp; Maroon 176 48 96  #B03060  \u0026nbsp; MediumVioletRed 199 21 133  #C71585  \u0026nbsp; VioletRed 208 32 144  #D02090  \u0026nbsp; Magenta 255 0 255  #FF00FF  \u0026nbsp; Violet 238 130 238  #EE82EE  \u0026nbsp; Plum  221 160 221  #DDA0DD  \u0026nbsp; Orchid 218 112 214  #DA70D6  \u0026nbsp; MediumOrchid 186 85 211  #BA55D3  \u0026nbsp; DarkOrchid 153 50 204  #9932CC  \u0026nbsp; DarkViolet 148 0 211  #9400D3  \u0026nbsp; BlueViolet 138 43 226  #8A2BE2  \u0026nbsp; Purple 160 32 240  #A020F0  \u0026nbsp; MediumPurple 147 112 219  #9370DB  \u0026nbsp; Thistle 216 191 216  #D8BFD8  \u0026nbsp; Snow1 255 250 250  #FFFAFA  \u0026nbsp; Snow2 238 233 233  #EEE9E9  \u0026nbsp; Snow3 205 201 201  #CDC9C9  \u0026nbsp; Snow4 139 137 137  #8B8989  \u0026nbsp; Seashell1 255 245 238  #FFF5EE  \u0026nbsp; Seashell2 238 229 222  #EEE5DE  \u0026nbsp; Seashell3 205 197 191  #CDC5BF  \u0026nbsp; Seashell4 139 134 130  #8B8682  \u0026nbsp; AntiqueWhite1 255 239 219  #FFEFDB  \u0026nbsp; AntiqueWhite2 238 223 204  #EEDFCC  \u0026nbsp; AntiqueWhite3 205 192 176  #CDC0B0  \u0026nbsp; AntiqueWhite4 139 131 120  #8B8378  \u0026nbsp; Bisque1 255 228 196  #FFE4C4  \u0026nbsp; Bisque2 238 213 183  #EED5B7  \u0026nbsp; Bisque3 205 183 158  #CDB79E  \u0026nbsp; Bisque4 139 125 107  #8B7D6B  \u0026nbsp; PeachPuff1 255 218 185  #FFDAB9  \u0026nbsp; PeachPuff2 238 203 173  #EECBAD  \u0026nbsp; PeachPuff3 205 175 149  #CDAF95  \u0026nbsp; PeachPuff4 139 119 101  #8B7765  \u0026nbsp; NavajoWhite1 255 222 173  #FFDEAD  \u0026nbsp; NavajoWhite2 238 207 161  #EECFA1  \u0026nbsp; NavajoWhite3 205 179 139  #CDB38B  \u0026nbsp; NavajoWhite4 139 121 94  #8B795E  \u0026nbsp; LemonChiffon1 255 250 205  #FFFACD  \u0026nbsp; LemonChiffon2 238 233 191  #EEE9BF  \u0026nbsp; LemonChiffon3 205 201 165  #CDC9A5  \u0026nbsp; LemonChiffon4 139 137 112  #8B8970  \u0026nbsp; Cornsilk1 255 248 220  #FFF8DC  \u0026nbsp; Cornsilk2 238 232 205  #EEE8CD  \u0026nbsp; Cornsilk3 205 200 177  #CDC8B1  \u0026nbsp; Cornsilk4 139 136 120  #8B8878  \u0026nbsp; Ivory1 255 255 240  #FFFFF0  \u0026nbsp; Ivory2 238 238 224  #EEEEE0  \u0026nbsp; Ivory3 205 205 193  #CDCDC1  \u0026nbsp; Ivory4 139 139 131  #8B8B83  \u0026nbsp; Honeydew1 240 255 240  #F0FFF0  \u0026nbsp; Honeydew2 224 238 224  #E0EEE0  \u0026nbsp; Honeydew3 193 205 193  #C1CDC1  \u0026nbsp; Honeydew4 131 139 131  #838B83  \u0026nbsp; LavenderBlush1 255 240 245  #FFF0F5  \u0026nbsp; LavenderBlush2 238 224 229  #EEE0E5  \u0026nbsp; LavenderBlush3 205 193 197  #CDC1C5  \u0026nbsp; LavenderBlush4 139 131 134  #8B8386  \u0026nbsp; MistyRose1 255 228 225  #FFE4E1  \u0026nbsp; MistyRose2 238 213 210  #EED5D2  \u0026nbsp; MistyRose3 205 183 181  #CDB7B5  \u0026nbsp; MistyRose4 139 125 123  #8B7D7B  \u0026nbsp; Azure1 240 255 255  #F0FFFF  \u0026nbsp; Azure2 224 238 238  #E0EEEE  \u0026nbsp; Azure3 193 205 205  #C1CDCD  \u0026nbsp; Azure4 131 139 139  #838B8B  \u0026nbsp; SlateBlue1 131 111 255  #836FFF  \u0026nbsp; SlateBlue2 122 103 238  #7A67EE  \u0026nbsp; SlateBlue3 105 89 205  #6959CD  \u0026nbsp; SlateBlue4 71 60 139  #473C8B  \u0026nbsp; RoyalBlue1 72 118 255  #4876FF  \u0026nbsp; RoyalBlue2 67 110 238  #436EEE  \u0026nbsp; RoyalBlue3 58 95 205  #3A5FCD  \u0026nbsp; RoyalBlue4 39 64 139  #27408B  \u0026nbsp; Blue1 0 0 255  #0000FF  \u0026nbsp; Blue2 0 0 238  #0000EE  \u0026nbsp; Blue3 0 0 205  #0000CD  \u0026nbsp; Blue4 0 0 139  #00008B  \u0026nbsp; DodgerBlue1 30 144 255  #1E90FF  \u0026nbsp; DodgerBlue2 28 134 238  #1C86EE  \u0026nbsp; DodgerBlue3 24 116 205  #1874CD  \u0026nbsp; DodgerBlue4 16 78 139  #104E8B  \u0026nbsp; SteelBlue1 99 184 255  #63B8FF  \u0026nbsp; SteelBlue2 92 172 238  #5CACEE  \u0026nbsp; SteelBlue3 79 148 205  #4F94CD  \u0026nbsp; SteelBlue4 54 100 139  #36648B  \u0026nbsp; DeepSkyBlue1 0 191 255  #00BFFF  \u0026nbsp; DeepSkyBlue2 0 178 238  #00B2EE  \u0026nbsp; DeepSkyBlue3 0 154 205  #009ACD  \u0026nbsp; DeepSkyBlue4 0 104 139  #00688B  \u0026nbsp; SkyBlue1 135 206 255  #87CEFF  \u0026nbsp; SkyBlue2 126 192 238  #7EC0EE  \u0026nbsp; SkyBlue3 108 166 205  #6CA6CD  \u0026nbsp; SkyBlue4 74 112 139  #4A708B  \u0026nbsp; LightSkyBlue1 176 226 255  #B0E2FF  \u0026nbsp; LightSkyBlue2 164 211 238  #A4D3EE  \u0026nbsp; LightSkyBlue3 141 182 205  #8DB6CD  \u0026nbsp; LightSkyBlue4 96 123 139  #607B8B  \u0026nbsp; SlateGray1 198 226 255  #C6E2FF  \u0026nbsp; SlateGray2 185 211 238  #B9D3EE  \u0026nbsp; SlateGray3 159 182 205  #9FB6CD  \u0026nbsp; SlateGray4 108 123 139  #6C7B8B  \u0026nbsp; LightSteelBlue1 202 225 255  #CAE1FF  \u0026nbsp; LightSteelBlue2 188 210 238  #BCD2EE  \u0026nbsp; LightSteelBlue3 162 181 205  #A2B5CD  \u0026nbsp; LightSteelBlue4 110 123 139  #6E7B8B  \u0026nbsp; LightBlue1 191 239 255  #BFEFFF  \u0026nbsp; LightBlue2 178 223 238  #B2DFEE  \u0026nbsp; LightBlue3 154 192 205  #9AC0CD  \u0026nbsp; LightBlue4 104 131 139  #68838B  \u0026nbsp; LightCyan1 224 255 255  #E0FFFF  \u0026nbsp; LightCyan2 209 238 238  #D1EEEE  \u0026nbsp; LightCyan3 180 205 205  #B4CDCD  \u0026nbsp; LightCyan4 122 139 139  #7A8B8B  \u0026nbsp; PaleTurquoise1 187 255 255  #BBFFFF  \u0026nbsp; PaleTurquoise2 174 238 238  #AEEEEE  \u0026nbsp; PaleTurquoise3 150 205 205  #96CDCD  \u0026nbsp; PaleTurquoise4 102 139 139  #668B8B  \u0026nbsp; CadetBlue1 152 245 255  #98F5FF  \u0026nbsp; CadetBlue2 142 229 238  #8EE5EE  \u0026nbsp; CadetBlue3 122 197 205  #7AC5CD  \u0026nbsp; CadetBlue4 83 134 139  #53868B  \u0026nbsp; Turquoise1 0 245 255  #00F5FF  \u0026nbsp; Turquoise2 0 229 238  #00E5EE  \u0026nbsp; Turquoise3 0 197 205  #00C5CD  \u0026nbsp; Turquoise4 0 134 139  #00868B  \u0026nbsp; Cyan1 0 255 255  #00FFFF  \u0026nbsp; Cyan2 0 238 238  #00EEEE  \u0026nbsp; Cyan3 0 205 205  #00CDCD  \u0026nbsp; Cyan4 0 139 139  #008B8B  \u0026nbsp; DarkSlateGray1 151 255 255  #97FFFF  \u0026nbsp; DarkSlateGray2 141 238 238  #8DEEEE  \u0026nbsp; DarkSlateGray3 121 205 205  #79CDCD  \u0026nbsp; DarkSlateGray4 82 139 139  #528B8B  \u0026nbsp; Aquamarine1 127 255 212  #7FFFD4  \u0026nbsp; Aquamarine2 118 238 198  #76EEC6  \u0026nbsp; Aquamarine3 102 205 170  #66CDAA  \u0026nbsp; Aquamarine4 69 139 116  #458B74  \u0026nbsp; DarkSeaGreen1 193 255 193  #C1FFC1  \u0026nbsp; DarkSeaGreen2 180 238 180  #B4EEB4  \u0026nbsp; DarkSeaGreen3 155 205 155  #9BCD9B  \u0026nbsp; DarkSeaGreen4 105 139 105  #698B69  \u0026nbsp; SeaGreen1 84 255 159  #54FF9F  \u0026nbsp; SeaGreen2 78 238 148  #4EEE94  \u0026nbsp; SeaGreen3 67 205 128  #43CD80  \u0026nbsp; SeaGreen4 46 139 87  #2E8B57  \u0026nbsp; PaleGreen1 154 255 154  #9AFF9A  \u0026nbsp; PaleGreen2 144 238 144  #90EE90  \u0026nbsp; PaleGreen3 124 205 124  #7CCD7C  \u0026nbsp; PaleGreen4 84 139 84  #548B54  \u0026nbsp; SpringGreen1 0 255 127  #00FF7F  \u0026nbsp; SpringGreen2 0 238 118  #00EE76  \u0026nbsp; SpringGreen3 0 205 102  #00CD66  \u0026nbsp; SpringGreen4 0 139 69  #008B45  \u0026nbsp; Green1 0 255 0  #00FF00  \u0026nbsp; Green2 0 238 0  #00EE00  \u0026nbsp; Green3 0 205 0  #00CD00  \u0026nbsp; Green4 0 139 0  #008B00  \u0026nbsp; Chartreuse1 127 255 0  #7FFF00  \u0026nbsp; Chartreuse2 118 238 0  #76EE00  \u0026nbsp; Chartreuse3 102 205 0  #66CD00  \u0026nbsp; Chartreuse4 69 139 0  #458B00  \u0026nbsp; OliveDrab1 192 255 62  #C0FF3E  \u0026nbsp; OliveDrab2 179 238 58  #B3EE3A  \u0026nbsp; OliveDrab3 154 205 50  #9ACD32  \u0026nbsp; OliveDrab4 105 139 34  #698B22  \u0026nbsp; DarkOliveGreen1 202 255 112  #CAFF70  \u0026nbsp; DarkOliveGreen2 188 238 104  #BCEE68  \u0026nbsp; DarkOliveGreen3 162 205 90  #A2CD5A  \u0026nbsp; DarkOliveGreen4 110 139 61  #6E8B3D  \u0026nbsp; Khaki1 255 246 143  #FFF68F  \u0026nbsp; Khaki2 238 230 133  #EEE685  \u0026nbsp; Khaki3 205 198 115  #CDC673  \u0026nbsp; Khaki4 139 134 78  #8B864E  \u0026nbsp; LightGoldenrod1 255 236 139  #FFEC8B  \u0026nbsp; LightGoldenrod2 238 220 130  #EEDC82  \u0026nbsp; LightGoldenrod3 205 190 112  #CDBE70  \u0026nbsp; LightGoldenrod4 139 129 76  #8B814C  \u0026nbsp; LightYellow1 255 255 224  #FFFFE0  \u0026nbsp; LightYellow2 238 238 209  #EEEED1  \u0026nbsp; LightYellow3 205 205 180  #CDCDB4  \u0026nbsp; LightYellow4 139 139 122  #8B8B7A  \u0026nbsp; Yellow1 255 255 0  #FFFF00  \u0026nbsp; Yellow2 238 238 0  #EEEE00  \u0026nbsp; Yellow3 205 205 0  #CDCD00  \u0026nbsp; Yellow4 139 139 0  #8B8B00  \u0026nbsp; Gold1 255 215 0  #FFD700  \u0026nbsp; Gold2 238 201 0  #EEC900  \u0026nbsp; Gold3 205 173 0  #CDAD00  \u0026nbsp; Gold4 139 117 0  #8B7500  \u0026nbsp; Goldenrod1 255 193 37  #FFC125  \u0026nbsp; Goldenrod2 238 180 34  #EEB422  \u0026nbsp; Goldenrod3 205 155 29  #CD9B1D  \u0026nbsp; Goldenrod4 139 105 20  #8B6914  \u0026nbsp; DarkGoldenrod1 255 185 15  #FFB90F  \u0026nbsp; DarkGoldenrod2 238 173 14  #EEAD0E  \u0026nbsp; DarkGoldenrod3 205 149 12  #CD950C  \u0026nbsp; DarkGoldenrod4 139 101 8  #8B658B  \u0026nbsp; RosyBrown1 255 193 193  #FFC1C1  \u0026nbsp; RosyBrown2 238 180 180  #EEB4B4  \u0026nbsp; RosyBrown3 205 155 155  #CD9B9B  \u0026nbsp; RosyBrown4 139 105 105  #8B6969  \u0026nbsp; IndianRed1 255 106 106  #FF6A6A  \u0026nbsp; IndianRed2 238 99 99  #EE6363  \u0026nbsp; IndianRed3 205 85 85  #CD5555  \u0026nbsp; IndianRed4 139 58 58  #8B3A3A  \u0026nbsp; Sienna1 255 130 71  #FF8247  \u0026nbsp; Sienna2 238 121 66  #EE7942  \u0026nbsp; Sienna3 205 104 57  #CD6839  \u0026nbsp; Sienna4 139 71 38  #8B4726  \u0026nbsp; Burlywood1 255 211 155  #FFD39B  \u0026nbsp; Burlywood2 238 197 145  #EEC591  \u0026nbsp; Burlywood3 205 170 125  #CDAA7D  \u0026nbsp; Burlywood4 139 115 85  #8B7355  \u0026nbsp; Wheat1 255 231 186  #FFE7BA  \u0026nbsp; Wheat2 238 216 174  #EED8AE  \u0026nbsp; Wheat3 205 186 150  #CDBA96  \u0026nbsp; Wheat4 139 126 102  #8B7E66  \u0026nbsp; Tan1  255 165 79  #FFA54F  \u0026nbsp; Tan2  238 154 73  #EE9A49  \u0026nbsp; Tan3  205 133 63  #CD853F  \u0026nbsp; Tan4  139 90 43  #8B5A2B  \u0026nbsp; Chocolate1 255 127 36  #FF7F24  \u0026nbsp; Chocolate2 238 118 33  #EE7621  \u0026nbsp; Chocolate3 205 102 29  #CD661D  \u0026nbsp; Chocolate4 139 69 19  #8B4513  \u0026nbsp; Firebrick1 255 48 48  #FF3030  \u0026nbsp; Firebrick2 238 44 44  #EE2C2C  \u0026nbsp; Firebrick3 205 38 38  #CD2626  \u0026nbsp; Firebrick4 139 26 26  #8B1A1A  \u0026nbsp; Brown1 255 64 64  #FF4040  \u0026nbsp; Brown2 238 59 59  #EE3B3B  \u0026nbsp; Brown3 205 51 51  #CD3333  \u0026nbsp; Brown4 139 35 35  #8B2323  \u0026nbsp; Salmon1 255 140 105  #FF8C69  \u0026nbsp; Salmon2 238 130 98  #EE8262  \u0026nbsp; Salmon3 205 112 84  #CD7054  \u0026nbsp; Salmon4 139 76 57  #8B4C39  \u0026nbsp; LightSalmon1 255 160 122  #FFA07A  \u0026nbsp; LightSalmon2 238 149 114  #EE9572  \u0026nbsp; LightSalmon3 205 129 98  #CD8162  \u0026nbsp; LightSalmon4 139 87 66  #8B5742  \u0026nbsp; Orange1 255 165 0  #FFA500  \u0026nbsp; Orange2 238 154 0  #EE9A00  \u0026nbsp; Orange3 205 133 0  #CD8500  \u0026nbsp; Orange4 139 90 0  #8B5A00  \u0026nbsp; DarkOrange1 255 127 0  #FF7F00  \u0026nbsp; DarkOrange2 238 118 0  #EE7600  \u0026nbsp; DarkOrange3 205 102 0  #CD6600  \u0026nbsp; DarkOrange4 139 69 0  #8B4500  \u0026nbsp; Coral1 255 114 86  #FF7256  \u0026nbsp; Coral2 238 106 80  #EE6A50  \u0026nbsp; Coral3 205 91 69  #CD5B45  \u0026nbsp; Coral4 139 62 47  #8B3E2F  \u0026nbsp; Tomato1 255 99 71  #FF6347  \u0026nbsp; Tomato2 238 92 66  #EE5C42  \u0026nbsp; Tomato3 205 79 57  #CD4F39  \u0026nbsp; Tomato4 139 54 38  #8B3626  \u0026nbsp; OrangeRed1 255 69 0  #FF4500  \u0026nbsp; OrangeRed2 238 64 0  #EE4000  \u0026nbsp; OrangeRed3 205 55 0  #CD3700  \u0026nbsp; OrangeRed4 139 37 0  #8B2500  \u0026nbsp; Red1  255 0 0  #FF0000  \u0026nbsp; Red2  238 0 0  #EE0000  \u0026nbsp; Red3  205 0 0  #CD0000  \u0026nbsp; Red4  139 0 0  #8B0000  \u0026nbsp; DeepPink1 255 20 147  #FF1493  \u0026nbsp; DeepPink2 238 18 137  #EE1289  \u0026nbsp; DeepPink3 205 16 118  #CD1076  \u0026nbsp; DeepPink4 139 10 80  #8B0A50  \u0026nbsp; HotPink1 255 110 180  #FF6EB4  \u0026nbsp; HotPink2 238 106 167  #EE6AA7  \u0026nbsp; HotPink3 205 96 144  #CD6090  \u0026nbsp; HotPink4 139 58 98  #8B3A62  \u0026nbsp; Pink1 255 181 197  #FFB5C5  \u0026nbsp; Pink2 238 169 184  #EEA9B8  \u0026nbsp; Pink3 205 145 158  #CD919E  \u0026nbsp; Pink4 139 99 108  #8B636C  \u0026nbsp; LightPink1 255 174 185  #FFAEB9  \u0026nbsp; LightPink2 238 162 173  #EEA2AD  \u0026nbsp; LightPink3 205 140 149  #CD8C95  \u0026nbsp; LightPink4 139 95 101  #8B5F65  \u0026nbsp; PaleVioletRed1 255 130 171  #FF82AB  \u0026nbsp; PaleVioletRed2 238 121 159  #EE799F  \u0026nbsp; PaleVioletRed3 205 104 137  #CD6889  \u0026nbsp; PaleVioletRed4 139 71 93  #8B475D  \u0026nbsp; Maroon1 255 52 179  #FF34B3  \u0026nbsp; Maroon2 238 48 167  #EE30A7  \u0026nbsp; Maroon3 205 41 144  #CD2990  \u0026nbsp; Maroon4 139 28 98  #8B1C62  \u0026nbsp; VioletRed1 255 62 150  #FF3E96  \u0026nbsp; VioletRed2 238 58 140  #EE3A8C  \u0026nbsp; VioletRed3 205 50 120  #CD3278  \u0026nbsp; VioletRed4 139 34 82  #8B2252  \u0026nbsp; Magenta1 255 0 255  #FF00FF  \u0026nbsp; Magenta2 238 0 238  #EE00EE  \u0026nbsp; Magenta3 205 0 205  #CD00CD  \u0026nbsp; Magenta4 139 0 139  #8B008B  \u0026nbsp; Orchid1 255 131 250  #FF83FA  \u0026nbsp; Orchid2 238 122 233  #EE7AE9  \u0026nbsp; Orchid3 205 105 201  #CD69C9  \u0026nbsp; Orchid4 139 71 137  #8B4789  \u0026nbsp; Plum1 255 187 255  #FFBBFF  \u0026nbsp; Plum2 238 174 238  #EEAEEE  \u0026nbsp; Plum3 205 150 205  #CD96CD  \u0026nbsp; Plum4 139 102 139  #8B668B  \u0026nbsp; MediumOrchid1 224 102 255  #E066FF  \u0026nbsp; MediumOrchid2 209 95 238  #D15FEE  \u0026nbsp; MediumOrchid3 180 82 205  #B452CD  \u0026nbsp; MediumOrchid4 122 55 139  #7A378B  \u0026nbsp; DarkOrchid1 191 62 255  #BF3EFF  \u0026nbsp; DarkOrchid2 178 58 238  #B23AEE  \u0026nbsp; DarkOrchid3 154 50 205  #9A32CD  \u0026nbsp; DarkOrchid4 104 34 139  #68228B  \u0026nbsp; Purple1 155 48 255  #9B30FF  \u0026nbsp; Purple2 145 44 238  #912CEE  \u0026nbsp; Purple3 125 38 205  #7D26CD  \u0026nbsp; Purple4 85 26 139  #551A8B  \u0026nbsp; MediumPurple1 171 130 255  #AB82FF  \u0026nbsp; MediumPurple2 159 121 238  #9F79EE  \u0026nbsp; MediumPurple3 137 104 205  #8968CD  \u0026nbsp; MediumPurple4 93 71 139  #5D478B  \u0026nbsp; Thistle1 255 225 255  #FFE1FF  \u0026nbsp; Thistle2 238 210 238  #EED2EE  \u0026nbsp; Thistle3 205 181 205  #CDB5CD  \u0026nbsp; Thistle4 139 123 139  #8B7B8B  \u0026nbsp; grey11 28 28 28  #1C1C1C  \u0026nbsp; grey21 54 54 54  #363636  \u0026nbsp; grey31 79 79 79  #4F4F4F  \u0026nbsp; grey41 105 105 105  #696969  \u0026nbsp; grey51 130 130 130  #828282  \u0026nbsp; grey61 156 156 156  #9C9C9C  \u0026nbsp; grey71 181 181 181  #B5B5B5  \u0026nbsp; gray81 207 207 207  #CFCFCF  \u0026nbsp; gray91 232 232 232  #E8E8E8  \u0026nbsp; DarkGrey 169 169 169  #A9A9A9  \u0026nbsp; DarkBlue 0 0 139  #00008B  \u0026nbsp; DarkCyan 0 139 139  #008B8B  \u0026nbsp; DarkMagenta 139 0 139  #8B008B  \u0026nbsp; DarkRed 139 0 0  #8B0000  \u0026nbsp; LightGreen 144 238 144  #90EE90 ","title":"Markdown 的设计哲学"},{"link":"https://blog.policx.com/posts/python-type/","text":"Python 数据类型和变量\n数据类型 计算机顾名思义就是可以做数学计算的机器，因此，计算机程序理所当然地可以处理各种数值。但是，计算机能处理的远不止数值，还可以处理文本、图形、音频、视频、网页等各种各样的数据，不同的数据，需要定义不同的数据类型。在Python中，能够直接处理的数据类型有以下几种：\n整数 Python可以处理任意大小的整数，当然包括负整数，在程序中的表示方法和数学上的写法一模一样，例如：1，100，-8080，0，等等。\n计算机由于使用二进制，所以，有时候用十六进制表示整数比较方便，十六进制用0x前缀和0-9，a-f表示，例如：0xff00，0xa5b4c3d2，等等。\n浮点数 浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，比如，1.23x109和12.3x108是完全相等的。浮点数可以用数学写法，如1.23，3.14，-9.01，等等。但是对于很大或很小的浮点数，就必须用科学计数法表示，把10用e替代，1.23x109就是1.23e9，或者12.3e8，0.000012可以写成1.2e-5，等等。\n整数和浮点数在计算机内部存储的方式是不同的，整数运算永远是精确的（除法难道也是精确的？是的！），而浮点数运算则可能会有四舍五入的误差。\n字符串 字符串是以单引号\u0026rsquo;或双引号\u0026quot;括起来的任意文本，比如\u0026rsquo;abc'，\u0026ldquo;xyz\u0026quot;等等。请注意，\u0026lsquo;\u0026lsquo;或\u0026quot;\u0026ldquo;本身只是一种表示方式，不是字符串的一部分，因此，字符串\u0026rsquo;abc\u0026rsquo;只有a，b，c这3个字符。如果\u0026rsquo;本身也是一个字符，那就可以用\u0026quot;\u0026ldquo;括起来，比如\u0026quot;I\u0026rsquo;m OK\u0026quot;包含的字符是I，'，m，空格，O，K这6个字符。\n如果字符串内部既包含\u0026rsquo;又包含\u0026quot;怎么办？可以用转义字符\\来标识，比如：\n'I\\'m \\\u0026quot;OK\\\u0026quot;!' 表示的字符串内容是：\nI'm \u0026quot;OK\u0026quot;! 转义字符\\可以转义很多字符，比如\\n表示换行，\\t表示制表符，字符\\本身也要转义，所以\\表示的字符就是\\，可以在Python的交互式命令行用print()打印字符串看看：\n \u0026gt;\u0026gt;\u0026gt; print('I\\'m ok.') I'm ok. \u0026gt;\u0026gt;\u0026gt; print('I\\'m learning\\nPython.') I'm learning Python. \u0026gt;\u0026gt;\u0026gt; print('\\\\\\n\\\\') \\ \\ 如果字符串里面有很多字符都需要转义，就需要加很多\\，为了简化，Python还允许用r'\u0026lsquo;表示'\u0026lsquo;内部的字符串默认不转义，可以自己试试：\n\u0026gt;\u0026gt;\u0026gt; print('\\\\\\t\\\\') \\ \\ \u0026gt;\u0026gt;\u0026gt; print(r'\\\\\\t\\\\') \\\\\\t\\\\ 如果字符串内部有很多换行，用\\n写在一行里不好阅读，为了简化，Python允许用\u0026rsquo;'\u0026rsquo;\u0026hellip;\u0026lsquo;\u0026lsquo;\u0026lsquo;的格式表示多行内容，可以自己试试：\n \u0026gt;\u0026gt;\u0026gt; print('''line1 ... line2 ... line3''') line1 line2 line3 上面是在交互式命令行内输入，注意在输入多行内容时，提示符由\u0026raquo;\u0026gt;变为\u0026hellip;，提示你可以接着上一行输入，注意\u0026hellip;是提示符，不是代码的一部分：\n ┌────────────────────────────────────────────────────────┐ │Command Prompt - python _ □ x │ ├────────────────────────────────────────────────────────┤ │\u0026gt;\u0026gt;\u0026gt; print('''line1 │ │... line2 │ │... line3''') │ │line1 │ │line2 │ │line3 │ │ │ │\u0026gt;\u0026gt;\u0026gt; _ │ │ │ │ │ │ │ └────────────────────────────────────────────────────────┘ 当输入完结束符```和括号)后，执行该语句并打印结果。\n如果写成程序并存为.py文件，就是：\n print('''line1 line2 line3''') 多行字符串\u0026rsquo;'\u0026rsquo;\u0026hellip;\u0026lsquo;\u0026lsquo;\u0026lsquo;还可以在前面加上r使用，请自行测试：\n # -*- coding: utf-8 -*- print(r'''hello,\\n world''') Run\n布尔值 布尔值和布尔代数的表示完全一致，一个布尔值只有True、False两种值，要么是True，要么是False，在Python中，可以直接用True、False表示布尔值（请注意大小写），也可以通过布尔运算计算出来：\n\u0026gt;\u0026gt;\u0026gt; True True \u0026gt;\u0026gt;\u0026gt; False False \u0026gt;\u0026gt;\u0026gt; 3 \u0026gt; 2 True \u0026gt;\u0026gt;\u0026gt; 3 \u0026gt; 5 False 布尔值可以用and、or和not运算。\nand运算是与运算，只有所有都为True，and运算结果才是True： \u0026gt;\u0026gt;\u0026gt; True and True True \u0026gt;\u0026gt;\u0026gt; True and False False \u0026gt;\u0026gt;\u0026gt; False and False False \u0026gt;\u0026gt;\u0026gt; 5 \u0026gt; 3 and 3 \u0026gt; 1 True or运算是或运算，只要其中有一个为True，or运算结果就是True： \u0026gt;\u0026gt;\u0026gt; True or True True \u0026gt;\u0026gt;\u0026gt; True or False True \u0026gt;\u0026gt;\u0026gt; False or False False \u0026gt;\u0026gt;\u0026gt; 5 \u0026gt; 3 or 1 \u0026gt; 3 True not运算是非运算，它是一个单目运算符，把True变成False，False变成True： \u0026gt;\u0026gt;\u0026gt; not True False \u0026gt;\u0026gt;\u0026gt; not False True \u0026gt;\u0026gt;\u0026gt; not 1 \u0026gt; 2 True 布尔值经常用在条件判断中，比如：\nif age \u0026gt;= 18: print('adult') else: print('teenager') 空值 空值是Python里一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。\n此外，Python还提供了列表、字典等多种数据类型，还允许创建自定义数据类型，我们后面会继续讲到。\n变量 变量的概念基本上和初中代数的方程变量是一致的，只是在计算机程序中，变量不仅可以是数字，还可以是任意数据类型。\n变量在程序中就是用一个变量名表示了，变量名必须是大小写英文、数字和_的组合，且不能用数字开头，比如：\na = 1 变量a是一个整数。\nt_007 = 'T007' 变量t_007是一个字符串。\nAnswer = True 变量Answer是一个布尔值True。\n在Python中，等号=是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，例如：\n# -*- coding: utf-8 -*- a = 123 # a是整数 print(a) a = 'ABC' # a变为字符串 print(a) Run 这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。例如Java是静态语言，赋值语句如下（// 表示注释）：\nint a = 123; // a是整数类型变量 a = \u0026quot;ABC\u0026quot;; // 错误：不能把字符串赋给整型变量 和静态语言相比，动态语言更灵活，就是这个原因。\n请不要把赋值语句的等号等同于数学的等号。比如下面的代码：\n x = 10 x = x + 2 如果从数学上理解x = x + 2那无论如何是不成立的，在程序中，赋值语句先计算右侧的表达式x + 2，得到结果12，再赋给变量x。由于x之前的值是10，重新赋值后，x的值变成12。\n最后，理解变量在计算机内存中的表示也非常重要。当我们写：\na = 'ABC' 时，Python解释器干了两件事情：\n在内存中创建了一个\u0026rsquo;ABC\u0026rsquo;的字符串；\n在内存中创建了一个名为a的变量，并把它指向\u0026rsquo;ABC\u0026rsquo;。\n也可以把一个变量a赋值给另一个变量b，这个操作实际上是把变量b指向变量a所指向的数据，例如下面的代码：\n# -*- coding: utf-8 -*- a = 'ABC' b = a a = 'XYZ' print(b) Run 最后一行打印出变量b的内容到底是\u0026rsquo;ABC\u0026rsquo;呢还是\u0026rsquo;XYZ\u0026rsquo;？如果从数学意义上理解，就会错误地得出b和a相同，也应该是\u0026rsquo;XYZ\u0026rsquo;，但实际上b的值是\u0026rsquo;ABC\u0026rsquo;，让我们一行一行地执行代码，就可以看到到底发生了什么事：\n执行a = \u0026lsquo;ABC\u0026rsquo;，解释器创建了字符串\u0026rsquo;ABC\u0026rsquo;和变量a，并把a指向\u0026rsquo;ABC\u0026rsquo;：\n执行b = a，解释器创建了变量b，并把b指向a指向的字符串\u0026rsquo;ABC\u0026rsquo;：\n执行a = \u0026lsquo;XYZ\u0026rsquo;，解释器创建了字符串\u0026rsquo;XYZ'，并把a的指向改为\u0026rsquo;XYZ'，但b并没有更改：\n所以，最后打印变量b的结果自然是\u0026rsquo;ABC\u0026rsquo;了。\n常量 所谓常量就是不能变的变量，比如常用的数学常数π就是一个常量。在Python中，通常用全部大写的变量名表示常量：\nPI = 3.14159265359 但事实上PI仍然是一个变量，Python根本没有任何机制保证PI不会被改变，所以，用全部大写的变量名表示常量只是一个习惯上的用法，如果你一定要改变变量PI的值，也没人能拦住你。\n最后解释一下整数的除法为什么也是精确的。在Python中，有两种除法，一种除法是/：\n\u0026gt;\u0026gt;\u0026gt; 10 / 3 3.3333333333333335 /除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数：\n\u0026gt;\u0026gt;\u0026gt; 9 / 3 3.0 还有一种除法是//，称为地板除，两个整数的除法仍然是整数：\n\u0026gt;\u0026gt;\u0026gt; 10 // 3 3 你没有看错，整数的地板除//永远是整数，即使除不尽。要做精确的除法，使用/就可以。\n因为//除法只取结果的整数部分，所以Python还提供一个余数运算，可以得到两个整数相除的余数：\n\u0026gt;\u0026gt;\u0026gt; 10 % 3 1 无论整数做//除法还是取余数，结果永远是整数，所以，整数运算结果永远是精确的。\n小结 Python支持多种数据类型，在计算机内部，可以把任何数据都看成一个“对象”，而变量就是在程序中用来指向这些数据对象的，对变量赋值就是把数据和变量给关联起来。\n对变量赋值x = y是把变量x指向真正的对象，该对象是变量y所指向的。随后对变量y的赋值不影响变量x的指向。\n注意： Python的整数没有大小限制，而某些语言的整数根据其存储长度是有大小限制的，例如Java对32位整数的范围限制在-2147483648-2147483647。 Python的浮点数也没有大小限制，但是超出一定范围就直接表示为inf（无限大）。\n","title":"数据类型和变量"},{"link":"https://blog.policx.com/posts/python/","text":"Python 字典、列表、数组和字符串\n字典\n1 2 3 4 5 6 7  # -*- coding: UTF-8 -*- dict_1 = {\u0026#39;1\u0026#39;: \u0026#39;a\u0026#39;, \u0026#39;2\u0026#39;: \u0026#39;b\u0026#39;, \u0026#39;3\u0026#39;: \u0026#39;c\u0026#39;} print(dict_1) # 打印字典 print(type(dict_1)) # 打印新赋值的字典的类型 print(str(dict_1), end=\u0026#39;字符串\\n\u0026#39;) # 把字典转化成字符串后打印 print(tuple(dict_1), end=\u0026#39;元组\\n\u0026#39;) # 把字典转化为元组后打印 print(list(dict_1), end=\u0026#39;列表\\n\u0026#39;) # 把字典转化为列表后打印   元组\n1 2 3 4 5 6  # -*- coding: UTF-8 -*- tuple_1 = (1, 2, 3, 4, 5) print(tuple_1) # 打印元组 print(type(tuple_1)) # 打印新赋值的元祖的类型 print(str(tuple_1), end=\u0026#39;字符串\\n\u0026#39;) # 把元组转化成字符串后打印 print(list(tuple_1), end=\u0026#39;列表\\n\u0026#39;) # 把元组转化为列表后打印   元组不可转化为字典 列表\n1 2 3 4 5 6  # -*- coding: UTF-8 -*- list_1 = [1, 2, 3, 4, 5] print(list_1) # 打印列表 print(type(list_1)) # 打印新赋值的列表的类型 print(str(list_1), end=\u0026#39;字符串\\n\u0026#39;) # 把列表转化成字符串后打印 print(tuple(list_1), end=\u0026#39;元组\\n\u0026#39;) # 把列表转化为元组后打印   元组不可转化为字典 字符串\n1 2 3 4 5 6  # -*- coding: UTF-8 -*- string_1 = \u0026#39;(1, 2, 3, 4, 5)\u0026#39; print(string_1) # 打印字符串 print(type(string_1)) # 打印新赋值的字符串 print(tuple(eval(string_1)), end=\u0026#39;元组\\n\u0026#39;) # 把字符串转化成元组后输出 print(list(eval(string_1)), end=\u0026#39;列表\\n\u0026#39;) # 把字符串转化成列表后输出   只有特殊字符串才能转化为字典 1 2 3 4  string_2 = \u0026#39;{\u0026#34;name\u0026#34;:\u0026#34;tom\u0026#34;,\u0026#34;age\u0026#34;:6}\u0026#39; print(string_2) # 打印新赋值的字符串 print(type(string_2)) # 打印新赋值的字符串的类型 print(dict(eval(string_2)), end=\u0026#39;字典\\n\u0026#39;) # 把字符串转化为字典后打印   ","title":"字典、列表、数组和字符串"},{"link":"https://blog.policx.com/posts/http/","text":"HTTP状态码\nHTTP状态码（英语：HTTP Status Code）是用以表示网页服务器超文本传输协议响应状态的3位数字代码。它由 RFC 2616 规范定义的，并得到 RFC 2518、RFC 2817、RFC 2295、RFC 2774 与 RFC 4918 等规范扩展。所有状态码的第一个数字代表了响应的五种状态之一。所示的消息短语是典型的，但是可以提供任何可读取的替代方案。 除非另有说明，状态码是HTTP / 1.1标准（RFC 7231）的一部分。\nHTTP状态码的官方注册表由互联网号码分配局（Internet Assigned Numbers Authority）维护。\n微软互联网信息服务 （Microsoft Internet Information Services）有时会使用额外的十进制子代码来获取更多具体信息，但是这些子代码仅出现在响应有效内容和文档中，而不是代替实际的HTTP状态代码。\n   编号 名称 解释     1️⃣❌❌ 🔴🔴🔴 1xx消息 这一类型的状态码，代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束。由于HTTP/1.0协议中没有定义任何1xx状态码，所以除非在某些试验条件下，服务器禁止向此类客户端发送1xx响应。 这些状态码代表的响应都是信息性的，标示客户应该采取的其他行动。   100 Continue 客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。   101 Switching Protocols 服务器已经理解了客户端的请求，并将通过Upgrade消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade消息头中定义的那些协议。: 只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的HTTP版本比旧版本更有优势，或者切换到一个实时且同步的协议以传送利用此类特性的资源。   102 Processing 由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。   2️⃣❌❌ 🔴🔴🔴 2xx成功 这一类型的状态码，代表请求已成功被服务器接收、理解、并接受。   200 OK 请求已成功，请求所希望的响应头或数据体将随此响应返回。   201 Created 请求已经被实现，而且有一个新的资源已经依据请求的需要而创建，且其URI已经随Location头信息返回。假如需要的资源无法及时创建的话，应当返回'202 Accepted'。   202 Accepted 服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。:返回202状态码的响应的目的是允许服务器接受其他过程的请求（例如某个每天只执行一次的基于批处理的操作），而不必让客户端一直保持与服务器的连接直到批处理操作全部完成。在接受请求处理并返回202状态码的响应应当在返回的实体中包含一些指示处理当前状态的信息，以及指向处理状态监视器或状态预测的指针，以便用户能够估计操作是否已经完成。   203 Non-Authoritative Information 服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超集。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回200 OK的情况下才是合适的。   204 No Content 服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。\n如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。\n由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。   205 Reset Content 服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。\n与204响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。   206 Partial Content 服务器已经成功处理了部分GET请求。类似于FlashGet或者迅雷这类的HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。\n该请求必须包含Range头信息来指示客户端希望得到的内容范围，并且可能包含If-Range来作为请求条件。\n响应必须包含如下的头部域：\nContent-Range用以指示本次响应中返回的内容的范围；如果是Content-Type为multipart/byteranges的多段下载，则每一multipart段中都应包含Content-Range域用以指示本段的内容范围。假如响应中包含Content-Length，那么它的数值必须匹配它返回的内容范围的真实字节数。\nDate ETag和／或Content-Location，假如同样的请求本应该返回200响应。\nExpires, Cache-Control，和／或Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。\n假如本响应请求使用了If-Range强缓存验证，那么本次响应不应该包含其他实体头；假如本响应的请求使用了If-Range弱缓存验证，那么本次响应禁止包含其他实体头；这避免了缓存的实体内容和更新了的实体头信息之间的不一致。否则，本响应就应当包含所有本应该返回200响应中应当返回的所有实体头部域。\n假如ETag或Last-Modified头部不能精确匹配的话，则客户端缓存应禁止将206响应返回的内容与之前任何缓存过的内容组合在一起。\n任何不支持Range以及Content-Range头的缓存都禁止缓存206响应返回的内容。   207 Multi-Status 由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。   3️⃣❌❌ 🔴🔴🔴 3xx重定向 这类状态码代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的Location域中指明。\n当且仅当后续的请求所使用的方法是GET或者HEAD时，用户浏览器才可以在没有用户介入的情况下自动提交所需要的后续请求。客户端应当自动监测无限循环重定向（例如：A→B→C→……→A或A→A），因为这会导致服务器和客户端大量不必要的资源消耗。按照HTTP/1.0版规范的建议，浏览器不应自动访问超过5次的重定向。   300 Multiple Choices 被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。\n除非这是一个HEAD请求，否则该响应应当包括一个资源特性及地址的列表的实体，以便用户或浏览器从中选择最合适的重定向地址。这个实体的格式由Content-Type定义的格式所决定。浏览器可能根据响应的格式以及浏览器自身能力，自动作出最合适的选择。当然，RFC 2616规范并没有规定这样的自动选择该如何进行。\n如果服务器本身已经有了首选的回馈选择，那么在Location中应当指明这个回馈的URI；浏览器可能会将这个Location值作为自动重定向的地址。此外，除非额外指定，否则这个响应也是可缓存的。   301 Moved Permanently 被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个URI之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。\n新的永久性的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。\n如果这不是一个GET或者HEAD请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。\n注意：对于某些使用HTTP/1.0协议的浏览器，当它们发送的POST请求得到了一个301响应的话，接下来的重定向请求将会变成GET方式。   302 Found 请求的资源现在临时从不同的URI响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。\n新的临时性的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。\n如果这不是一个GET或者HEAD请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。\n注意：虽然RFC 1945和RFC 2068规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将302响应视作为303响应，并且使用GET方式访问在Location中规定的URI，而无视原先请求的方法。状态码303和307被添加了进来，用以明确服务器期待客户端进行何种反应。   303 See Other 对应当前请求的响应可以在另一个URI上被找到，而且客户端应当采用GET的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。这个新的URI不是原始资源的替代引用。同时，303响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。\n新的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。\n注意：许多HTTP/1.1版以前的浏览器不能正确理解303状态。如果需要考虑与这些浏览器之间的互动，302状态码应该可以胜任，因为大多数的浏览器处理302响应时的方式恰恰就是上述规范要求客户端处理303响应时应当做的。   304 Not Modified 如果客户端发送了一个带条件的GET请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。\n该响应必须包含以下的头信息：\nDate，除非这个服务器没有时钟。假如没有时钟的服务器也遵守这些规则，那么代理服务器以及客户端可以自行将Date字段添加到接收到的响应头中去（正如RFC 2068中规定的一样），缓存机制将会正常工作。\nETag和／或Content-Location，假如同样的请求本应返回200响应。\nExpires, Cache-Control，和／或Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。\n假如本响应请求使用了强缓存验证，那么本次响应不应该包含其他实体头；否则（例如，某个带条件的GET请求使用了弱缓存验证），本次响应禁止包含其他实体头；这避免了缓存了的实体内容和更新了的实体头信息之间的不一致。\n假如某个304响应指明了当前某个实体没有缓存，那么缓存系统必须忽视这个响应，并且重复发送不包含限制条件的请求。\n假如接收到一个要求更新某个缓存条目的304响应，那么缓存系统必须更新整个条目以反映所有在响应中被更新的字段的值。   305 Use Proxy 被请求的资源必须通过指定的代理才能被访问。Location域中将给出指定的代理所在的URI信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能创建305响应。\n注意：RFC 2068中没有明确305响应是为了重定向一个单独的请求，而且只能被原始服务器创建。忽视这些限制可能导致严重的安全后果。   306 Switch Proxy 在最新版的规范中，306状态码已经不再被使用。   307 Temporary Redirect 请求的资源现在临时从不同的URI响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。\n新的临时性的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。因为部分浏览器不能识别307响应，因此需要添加上述必要信息以便用户能够理解并向新的URI发出访问请求。\n如果这不是一个GET或者HEAD请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。   4️⃣❌❌ 🔴🔴🔴 4xx客户端错误\n这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。除非响应的是一个HEAD请求，否则服务器就应该返回一个解释当前错误状况的实体，以及这是临时的还是永久性的状况。这些状态码适用于任何请求方法。浏览器应当向用户显示任何包含在此类错误响应中的实体内容。\n如果错误发生时客户端正在传送数据，那么使用TCP的服务器实现应当仔细确保在关闭客户端与服务器之间的连接之前，客户端已经收到了包含错误信息的数据包。如果客户端在收到错误信息后继续向服务器发送数据，服务器的TCP栈将向客户端发送一个重置数据包，以清除该客户端所有还未识别的输入缓冲，以免这些数据被服务器上的应用程序读取并干扰后者。   400 Bad Request 由于包含语法错误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。   401 Unauthorized 当前请求需要用户验证。该响应必须包含一个适用于被请求资源的WWW-Authenticate信息头用以询问用户信息。客户端可以重复提交一个包含恰当的Authorization头信息的请求。如果当前请求已经包含了Authorization证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。参见RFC 2617。   402 Payment Required 该状态码是为了将来可能的需求而预留的。   403 Forbidden 服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个HEAD请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个404响应，假如它不希望让客户端获得任何信息。   404 Not Found 请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。   405 Method Not Allowed 请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow头信息用以表示出当前资源能够接受的请求方法的列表。\n鉴于PUT，DELETE方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。   406 Not Acceptable 请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。\n除非这是一个HEAD请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址列表的实体。实体的格式由Content-Type头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。但是，规范中并没有定义任何作出此类自动选择的标准。   407 Proxy Authentication Required 与401响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个Proxy-Authenticate用以进行身份询问。客户端可以返回一个Proxy-Authorization信息头用以验证。参见RFC 2617。   408 Request Timeout 请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。   409 Conflict 由于和被请求的资源的当前状态之间存在冲突，请求无法完成。这个代码只允许用在这样的情况下才能被使用：用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头。\n冲突通常发生于对PUT请求的处理中。例如，在采用版本检查的环境下，某次PUT提交的对特定资源的修改请求所附带的版本信息与之前的某个（第三方）请求向冲突，那么此时服务器就应该返回一个409错误，告知用户请求无法完成。此时，响应实体中很可能会包含两个冲突版本之间的差异比较，以便用户重新提交归并以后的新版本。   410 Gone 被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。这样的状况应当被认为是永久性的。如果可能，拥有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。如果服务器不知道或者无法确定这个状况是否是永久的，那么就应该使用404状态码。除非额外说明，否则这个响应是可缓存的。\n410响应的目的主要是帮助网站管理员维护网站，通知用户该资源已经不再可用，并且服务器拥有者希望所有指向这个资源的远端连接也被删除。这类事件在限时、增值服务中很普遍。同样，410响应也被用于通知客户端在当前服务器站点上，原本属于某个个人的资源已经不再可用。当然，是否需要把所有永久不可用的资源标记为'410 Gone'，以及是否需要保持此标记多长时间，完全取决于服务器拥有者。   411 Length Required 服务器拒绝在没有定义Content-Length头的情况下接受请求。在添加了表明请求消息体长度的有效Content-Length头之后，客户端可以再次提交该请求。   412 Precondition Failed 服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。   413 Request Entity Too Large 服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。\n如果这个状况是临时的，服务器应当返回一个Retry-After的响应头，以告知客户端可以在多少时间以后重新尝试。   414 Request-URI Too Long 请求的URI长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。这比较少见，通常的情况包括：\n本应使用POST方法的表单提交变成了GET方法，导致查询字符串（Query String）过长。\n重定向URI“黑洞”，例如每次重定向把旧的URI作为新的URI的一部分，导致在若干次重定向后URI超长。\n客户端正在尝试利用某些服务器中存在的安全漏洞攻击服务器。这类服务器使用固定长度的缓冲读取或操作请求的URI，当GET后的参数超过某个数值后，可能会产生缓冲区溢出，导致任意代码被执行[1]。没有此类漏洞的服务器，应当返回414状态码。   415 Unsupported Media Type 对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。   416 Requested Range Not Satisfiable 如果请求中包含了Range请求头，并且Range中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义If-Range请求头，那么服务器就应当返回416状态码。\n假如Range使用的是字节范围，那么这种情况就是指请求指定的所有数据范围的首字节位置都超过了当前资源的长度。服务器也应当在返回416状态码的同时，包含一个Content-Range实体头，用以指明当前资源的长度。这个响应也被禁止使用multipart/byteranges作为其Content-Type。   417 Expectation Failed 在请求头Expect中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服务器，它有明显的证据证明在当前路由的下一个节点上，Expect的内容无法被满足。   418 I\u0026rsquo;m a teapot 本操作码是在1998年作为IETF的传统愚人节笑话, 在RFC 2324 超文本咖啡壶控制协议中定义的，并不需要在真实的HTTP服务器中定义。   421 There are too many connections from your internet address 从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。   422 Unprocessable Entity 请求格式正确，但是由于含有语义错误，无法响应。（RFC 4918 WebDAV）   423 Locked 当前资源被锁定。（RFC 4918 WebDAV）   424 Failed Dependency 由于之前的某个请求发生的错误，导致当前请求失败，例如PROPPATCH。（RFC 4918 WebDAV）   425 Unordered Collection 在WebDav Advanced Collections草案中定义，但是未出现在《WebDAV顺序集协议》（RFC 3658）中。   426 Upgrade Required 客户端应当切换到TLS/1.0。（RFC 2817）   449 Retry With 由微软扩展，代表请求应当在执行完适当的操作后进行重试。   5️⃣❌❌ 🔴🔴🔴 5xx服务器错误 这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。除非这是一个HEAD请求，否则服务器应当包含一个解释当前错误状态以及这个状况是临时的还是永久的解释信息实体。浏览器应当向用户展示任何在当前响应中被包含的实体。\n这些状态码适用于任何响应方法。   500 Internal Server Error 服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器的程序码出错时出现。   501 Not Implemented 服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。   502 Bad Gateway 作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。   503 Service Unavailable 由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个Retry-After头用以标明这个延迟时间。如果没有给出这个Retry-After信息，那么客户端应当以处理500响应的方式处理它。   504 Gateway Timeout 作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。 注意：某些代理服务器在DNS查询超时时会返回400或者500错误   505 HTTP Version Not Supported 服务器不支持，或者拒绝支持在请求中使用的HTTP版本。这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。   506 Variant Also Negotiates 由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误：被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。   507 Insufficient Storage 服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。WebDAV（RFC 4918）   509 Bandwidth Limit Exceeded 服务器达到带宽限制。这不是一个官方的状态码，但是仍被广泛使用。   510 Not Extended 获取资源所需要的策略并没有没满足。     Posted by 微博@iOS程序犭袁\n原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | Creative Commons BY-NC-ND 3.0\n ","title":"HTTP状态码汇总"},{"link":"https://blog.policx.com/posts/crash/","text":" 前言 实现原理 优化：降低50%以上误报机率 对原有API设计的几点优化意见   机制状态应当用枚举来做为API透出    关键数值应当做为初始化参数供用户设置    修复、上报逻辑应当支持用户异步操作   什么时候会出现该异常？ 连续启动 crash 自修复技术实现与原理解析  前言   如果 app 连续 crash 两次无法启动，用户往往会选择卸载。\n 连续启动 crash 应该是 crash 类型中最严重的一类，该问题常常与数据库操作有关，比如：数据库损坏、服务端返回数据错误，存入数据库，app 读取时产生数组越界、找不到方法。\n那么除了热修复，能否“自修复”该问题呢？\n在微信读书团队发布的《iOS 启动连续闪退保护方案》 一文中，给出了连续启动crash的自修复技术的思路讲解，并在GitHub上给出了技术实现，并开源了GYBootingProtection。方案思路很好，很轻量级。\n实现原理  在微信读书团队给出的文章中已经有比较详细的阐述，在此不做赘述，实现的流程图如下所示：  但有个实现上可以优化下，可以降低50%以上误报机率，监听用户手动划掉 APP 这个事件，其中一些特定场景，是可以获取的。另外在这里也给出对其 API 设计的建议。最后给出优化后的实现。\n优化：降低50%以上误报机率  用户主动 kill 掉 APP 分为两种情况：\n App在前台时用户手动划掉APP的时候 APP在后台时划掉APP  第一种场景更为常见，可以通过监听 UIApplicationWillTerminateNotification 来捕获该动作，捕获后恢复计数。第二种情况，无法监听到。但也足以降低 50% 以上的误报机率。\n对原有API设计的几点优化意见 1. 机制状态应当用枚举来做为API透出 该机制当前所处的状态，比如：NeedFix 、isFixing，建议用枚举来做为API透出。比如：\n APP 启动正常 正在检测是否会在特定时间内是否会 Crash，注意：检测状态下“连续启动崩溃计数”个数小于或等于上限值 APP 出现连续启动 Crash，需要采取修复措施 APP 出现连续启动 Crash，正在修复中  2. 关键数值应当做为初始化参数供用户设置  当前启动Crash的状态 达到需要执行上报操作的“连续启动崩溃计数”个数。 达到需要执行修复操作的“连续启动崩溃计数”个数。 APP 启动后经过多少秒，可以将“连续启动崩溃计数”清零  3. 修复、上报逻辑应当支持用户异步操作 reportBlock 上报逻辑， repairtBlock 修复逻辑\n比如：\ntypedef void (^BoolCompletionHandler)(BOOL succeeded, NSError *error); typedef void (^RepairBlock)(ABSBoolCompletionHandler completionHandler); 用户执行 BoolCompletionHandler 后即可知道是否执行完毕，并且支持异步操作。\n异步操作带来的问题，可以通过前面提到的枚举API来实时监测状态，来决定各种其他操作。\n什么时候会出现该异常？ 连续启动 crash 自修复技术实现与原理解析 下面给出优化后的代码实现：\n// // CYLBootingProtection.h // // // Created by ChenYilong on 18/01/10. // Copyright © 2018年 ChenYilong. All rights reserved. // #import \u0026lt;Foundation/Foundation.h\u0026gt; typedef void (^ABSBoolCompletionHandler)(BOOL succeeded, NSError *error); typedef void (^ABSRepairBlock)(ABSBoolCompletionHandler completionHandler); typedef void (^ABSReportBlock)(NSUInteger crashCounts); typedef NS_ENUM(NSInteger, BootingProtectionStatus) { BootingProtectionStatusNormal, /**\u0026lt; APP 启动正常 */ BootingProtectionStatusNormalChecking, /**\u0026lt; 正在检测是否会在特定时间内是否会 Crash，注意：检测状态下“连续启动崩溃计数”个数小于或等于上限值 */ BootingProtectionStatusNeedFix, /**\u0026lt; APP 出现连续启动 Crash，需要采取修复措施 */ BootingProtectionStatusFixing, /**\u0026lt; APP 出现连续启动 Crash，正在修复中... */ }; /** * 启动连续 crash 保护。 * 启动后 `_crashOnLaunchTimeIntervalThreshold` 秒内 crash，反复超过 `_continuousCrashOnLaunchNeedToReport` 次则上报日志，超过 `_continuousCrashOnLaunchNeedToFix` 则启动修复操作。 */ @interface CYLBootingProtection : NSObject /** * 启动连续 crash 保护方法。 * 前置条件：在 App 启动时注册 crash 处理函数，在 crash 时调用[CYLBootingProtection addCrashCountIfNeeded]。 * 启动后一定时间内（`crashOnLaunchTimeIntervalThreshold`秒内）crash，反复超过一定次数（`continuousCrashOnLaunchNeedToReport`次）则上报日志，超过一定次数（`continuousCrashOnLaunchNeedToFix`次）则启动修复程序；在一定时间内（`crashOnLaunchTimeIntervalThreshold`秒） 秒后若没有 crash 将“连续启动崩溃计数”计数置零。 `reportBlock` 上报逻辑， `repairtBlock` 修复逻辑，完成后执行 `[self setCrashCount:0]` */ - (void)launchContinuousCrashProtect; /*! * 当前启动Crash的状态 */ @property (nonatomic, assign, readonly) BootingProtectionStatus bootingProtectionStatus; /*! * 达到需要执行上报操作的“连续启动崩溃计数”个数。 */ @property (nonatomic, assign, readonly) NSUInteger continuousCrashOnLaunchNeedToReport; /*! * 达到需要执行修复操作的“连续启动崩溃计数”个数。 */ @property (nonatomic, assign, readonly) NSUInteger continuousCrashOnLaunchNeedToFix; /*! * APP 启动后经过多少秒，可以将“连续启动崩溃计数”清零 */ @property (nonatomic, assign, readonly) NSTimeInterval crashOnLaunchTimeIntervalThreshold; /*! * 借助 context 可以让多个模块注册事件，并且事件 block 能独立执行，互不干扰。 */ @property (nonatomic, copy, readonly) NSString *context; /*! * @details 启动后kCrashOnLaunchTimeIntervalThreshold秒内crash，反复超过continuousCrashOnLaunchNeedToReport次则上报日志，超过continuousCrashOnLaunchNeedToFix则启动修复程序；当所有操作完成后，执行 completion。在 crashOnLaunchTimeIntervalThreshold 秒后若没有 crash 将 kContinuousCrashOnLaunchCounterKey 计数置零。 * @param context 借助 context 可以让多个模块注册事件，并且事件 block 能独立执行，互不干扰。 */ - (instancetype)initWithContinuousCrashOnLaunchNeedToReport:(NSUInteger)continuousCrashOnLaunchNeedToReport continuousCrashOnLaunchNeedToFix:(NSUInteger)continuousCrashOnLaunchNeedToFix crashOnLaunchTimeIntervalThreshold:(NSTimeInterval)crashOnLaunchTimeIntervalThreshold context:(NSString *)context; /*! * 当前“连续启动崩溃“的状态 */ + (BootingProtectionStatus)bootingProtectionStatusWithContext:(NSString *)context continuousCrashOnLaunchNeedToFix:(NSUInteger)continuousCrashOnLaunchNeedToFix; /*! * 设置上报逻辑，参数 crashCounts 为启动连续 crash 次数 */ - (void)setReportBlock:(ABSReportBlock)reportBlock; /*! * 设置修复逻辑 */ - (void)setRepairBlock:(ABSRepairBlock)repairtBlock; + (void)setLogger:(void (^)(NSString *))logger; @end // // CYLBootingProtection.m // // // Created by ChenYilong on 18/01/10. // Copyright © 2018年 ChenYilong. All rights reserved. // #import \u0026quot;CYLBootingProtection.h\u0026quot; #import \u0026lt;UIKit/UIKit.h\u0026gt; static dispatch_queue_t _exceptionOperationQueue = 0; void (^Logger)(NSString *log); @interface CYLBootingProtection () @property (nonatomic, assign) NSUInteger continuousCrashOnLaunchNeedToReport; @property (nonatomic, assign) NSUInteger continuousCrashOnLaunchNeedToFix; @property (nonatomic, assign) NSTimeInterval crashOnLaunchTimeIntervalThreshold; @property (nonatomic, copy) NSString *context; @property (nonatomic, copy) ABSReportBlock reportBlock; @property (nonatomic, copy) ABSRepairBlock repairBlock; /*! * 设置“连续启动崩溃计数”个数 */ - (void)setCrashCount:(NSInteger)count; /*! * 设置“连续启动崩溃计数”个数 */ + (void)setCrashCount:(NSUInteger)count context:(NSString *)context; /*! * “连续启动崩溃计数”个数 */ - (NSUInteger)crashCount; /*! * “连续启动崩溃计数”个数 */ + (NSUInteger)crashCountWithContext:(NSString *)context; @end @implementation CYLBootingProtection + (void)initialize { static dispatch_once_t onceToken; dispatch_once(\u0026amp;onceToken, ^{ _exceptionOperationQueue = dispatch_queue_create(\u0026quot;com.ChenYilong.CYLBootingProtection.fileCacheQueue\u0026quot;, DISPATCH_QUEUE_SERIAL); }); } - (instancetype)initWithContinuousCrashOnLaunchNeedToReport:(NSUInteger)continuousCrashOnLaunchNeedToReport continuousCrashOnLaunchNeedToFix:(NSUInteger)continuousCrashOnLaunchNeedToFix crashOnLaunchTimeIntervalThreshold:(NSTimeInterval)crashOnLaunchTimeIntervalThreshold context:(NSString *)context { if (!(self = [super init])) { return nil; } _continuousCrashOnLaunchNeedToReport = continuousCrashOnLaunchNeedToReport; _continuousCrashOnLaunchNeedToFix = continuousCrashOnLaunchNeedToFix; _crashOnLaunchTimeIntervalThreshold = crashOnLaunchTimeIntervalThreshold; _context = [context copy]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(applicationWillTerminate:) name:UIApplicationWillTerminateNotification object:[UIApplication sharedApplication]]; return self; } /*! * App在前台时用户手动划掉APP的时候，不计入检测。 * 但是APP在后台时划掉APP，无法检测出来。 * 见：https://stackoverflow.com/a/35041565/3395008 */ - (void)applicationWillTerminate:(NSNotification *)note { BOOL isNormalChecking = [self isNormalChecking]; if (isNormalChecking) { [self decreaseCrashCount]; } } - (void)dealloc { [[NSNotificationCenter defaultCenter] removeObserver:self]; } /* 支持同步修复、异步修复，两种修复方式 - 异步修复，不卡顿主UI，但有修复未完成就被再次触发crash、或者用户kill掉的可能。需要用户手动根据修复状态，来选择性地进行操作，应该有回掉。 - 同步修复，最简单直观，在主线程删除或者下载修复包。 */ - (void)launchContinuousCrashProtect { NSAssert(_repairBlock, @\u0026quot;_repairBlock is nil!\u0026quot;); [[self class] Logger:@\u0026quot;CYLBootingProtection: Launch continuous crash report\u0026quot;]; [self resetBootingProtectionStatus]; NSUInteger launchCrashes = [self crashCount]; // 上报 if (launchCrashes \u0026gt;= self.continuousCrashOnLaunchNeedToReport) { NSString *logString = [NSString stringWithFormat:@\u0026quot;CYLBootingProtection: App has continuously crashed for %@ times. Now synchronize uploading crash report and begin fixing procedure.\u0026quot;, @(launchCrashes)]; [[self class] Logger:logString]; if (_reportBlock) { dispatch_async(dispatch_get_main_queue(),^{ _reportBlock(launchCrashes); }); } } // 修复 if ([self isUpToBootingProtectionCount]) { [[self class] Logger:@\u0026quot;need to repair\u0026quot;]; [self setIsFixing:YES]; if (_repairBlock) { ABSBoolCompletionHandler completionHandler = ^(BOOL succeeded, NSError *__nullable error){ if (succeeded) { [self resetCrashCount]; } else { [[self class] Logger:error.description]; } }; dispatch_async(dispatch_get_main_queue(),^{ _repairBlock(completionHandler); }); } } else { [self increaseCrashCount:launchCrashes]; // 正常流程，无需修复 [[self class] Logger:@\u0026quot;need no repair\u0026quot;]; // 记录启动时刻，用于计算启动连续 crash // 重置启动 crash 计数 dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(self.crashOnLaunchTimeIntervalThreshold * NSEC_PER_SEC)), dispatch_get_main_queue(), ^(void){ // APP活过了阈值时间，重置崩溃计数 NSString *logString = [NSString stringWithFormat:@\u0026quot;CYLBootingProtection: long live the app ( more than %@ seconds ), now reset crash counts\u0026quot;, @(self.crashOnLaunchTimeIntervalThreshold)]; [[self class] Logger:logString]; [self resetCrashCount]; }); } } //减少计数的时机：用户手动划掉APP - (void)decreaseCrashCount { NSUInteger oldCrashCount = [self crashCount]; [self decreaseCrashCountWithOldCrashCount:oldCrashCount]; } - (void)decreaseCrashCountWithOldCrashCount:(NSUInteger)oldCrashCount { dispatch_sync(_exceptionOperationQueue, ^{ if (oldCrashCount \u0026gt; 0) { [self setCrashCount:oldCrashCount-1]; } [self resetBootingProtectionStatus]; }); } //重制计数的时机：修复完成、或者用户手动划掉APP - (void)resetCrashCount { [self setCrashCount:0]; [self resetBootingProtectionStatus]; } //只在未达到计数上限时才会增加计数 - (void)increaseCrashCount:(NSUInteger)oldCrashCount { dispatch_sync(_exceptionOperationQueue, ^{ [self setIsNormalChecking:YES]; [self setCrashCount:oldCrashCount+1]; }); } - (void)resetBootingProtectionStatus { [self setIsNormalChecking:NO]; [self setIsFixing:NO]; } - (BootingProtectionStatus)bootingProtectionStatus { return [[self class] bootingProtectionStatusWithContext:_context continuousCrashOnLaunchNeedToFix:_continuousCrashOnLaunchNeedToFix]; } /*! * @attention 注意之所以要检查 `BootingProtectionStatusNormalChecking` 原因如下： `-launchContinuousCrashProtect` 方法与 `-bootingProtectionStatus` 方法，如果 `-launchContinuousCrashProtect` 先执行，那么会造成如下问题： 假设n为上限，但crash（n-1）次，但是用 `-bootingProtectionStatus` 判断出来，当前已经处于n次了。原因如下： crash（n-1）次，正常流程，计数+1，变成n次， 随后在检查 `-bootingProtectionStatus` 时，发现已经处于异常状态了，实际是正常状态。所以需要使用`BootingProtectionStatusNormalChecking` 来进行区分。 */ + (BootingProtectionStatus)bootingProtectionStatusWithContext:(NSString *)context continuousCrashOnLaunchNeedToFix:(NSUInteger)continuousCrashOnLaunchNeedToFix { BOOL isNormalChecking = [self isNormalCheckingWithContext:context]; if (isNormalChecking) { return BootingProtectionStatusNormalChecking; } BOOL isUpToBootingProtectionCount = [self isUpToBootingProtectionCountWithContext:context continuousCrashOnLaunchNeedToFix:continuousCrashOnLaunchNeedToFix]; if (!isUpToBootingProtectionCount) { return BootingProtectionStatusNormal; } BootingProtectionStatus type; BOOL isFixingCrash = [self isFixingCrashWithContext:context]; if (isFixingCrash) { type = BootingProtectionStatusFixing; } else { type = BootingProtectionStatusNeedFix; } return type; } - (NSUInteger)crashCount { return [[self class] crashCountWithContext:_context]; } - (void)setCrashCount:(NSInteger)count { if (count \u0026gt;=0) { [[self class] setCrashCount:count context:_context]; } } - (void)setIsFixing:(BOOL)isFixingCrash { [[self class] setIsFixing:isFixingCrash context:_context]; } /*! * 是否正在修复 */ - (BOOL)isFixingCrash { return [[self class] isFixingCrashWithContext:_context]; } - (void)setIsNormalChecking:(BOOL)isNormalChecking { [[self class] setIsNormalChecking:isNormalChecking context:_context]; } /*! * 是否正在检查 */ - (BOOL)isNormalChecking { return [[self class] isNormalCheckingWithContext:_context]; } + (NSUInteger)crashCountWithContext:(NSString *)context { NSString *continuousCrashOnLaunchCounterKey = [self continuousCrashOnLaunchCounterKeyWithContext:context]; NSUInteger crashCount = [[NSUserDefaults standardUserDefaults] integerForKey:continuousCrashOnLaunchCounterKey]; NSString *logString = [NSString stringWithFormat:@\u0026quot;crashCount:%@\u0026quot;, @(crashCount)]; [[self class] Logger:logString]; return crashCount; } + (void)setCrashCount:(NSUInteger)count context:(NSString *)context { NSString *continuousCrashOnLaunchCounterKey = [self continuousCrashOnLaunchCounterKeyWithContext:context]; NSString *logString = [NSString stringWithFormat:@\u0026quot;setCrashCount:%@\u0026quot;, @(count)]; [[self class] Logger:logString]; NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults]; [defaults setInteger:count forKey:continuousCrashOnLaunchCounterKey]; [defaults synchronize]; } + (void)setIsFixing:(BOOL)isFixingCrash context:(NSString *)context { NSString *continuousCrashFixingKey = [[self class] continuousCrashFixingKeyWithContext:context]; NSString *logString = [NSString stringWithFormat:@\u0026quot;setisFixingCrash:{%@}\u0026quot;, @(isFixingCrash)]; [[self class] Logger:logString]; NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults]; [defaults setBool:isFixingCrash forKey:continuousCrashFixingKey]; [defaults synchronize]; } + (BOOL)isFixingCrashWithContext:(NSString *)context { NSString *continuousCrashFixingKey = [[self class] continuousCrashFixingKeyWithContext:context]; BOOL isFixingCrash = [[NSUserDefaults standardUserDefaults] boolForKey:continuousCrashFixingKey]; NSString *logString = [NSString stringWithFormat:@\u0026quot;isFixingCrash:%@\u0026quot;, @(isFixingCrash)]; [[self class] Logger:logString]; return isFixingCrash; } + (void)setIsNormalChecking:(BOOL)isNormalChecking context:(NSString *)context { NSString *continuousCrashNormalCheckingKey = [[self class] continuousCrashNormalCheckingKeyWithContext:context]; NSString *logString = [NSString stringWithFormat:@\u0026quot;setIsNormalChecking:{%@}\u0026quot;, @(isNormalChecking)]; [[self class] Logger:logString]; NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults]; [defaults setBool:isNormalChecking forKey:continuousCrashNormalCheckingKey]; [defaults synchronize]; } + (BOOL)isNormalCheckingWithContext:(NSString *)context { NSString *continuousCrashFixingKey = [[self class] continuousCrashNormalCheckingKeyWithContext:context]; BOOL isFixingCrash = [[NSUserDefaults standardUserDefaults] boolForKey:continuousCrashFixingKey]; NSString *logString = [NSString stringWithFormat:@\u0026quot;isIsNormalChecking:%@\u0026quot;, @(isFixingCrash)]; [[self class] Logger:logString]; return isFixingCrash; } - (BOOL)isUpToBootingProtectionCount { return [[self class] isUpToBootingProtectionCountWithContext:_context continuousCrashOnLaunchNeedToFix:_continuousCrashOnLaunchNeedToFix]; } + (BOOL)isUpToBootingProtectionCountWithContext:(NSString *)context continuousCrashOnLaunchNeedToFix:(NSUInteger)continuousCrashOnLaunchNeedToFix { BOOL isUpToCount = [self crashCountWithContext:context] \u0026gt;= continuousCrashOnLaunchNeedToFix; if (isUpToCount) { return YES; } return NO; } - (void)setReportBlock:(ABSReportBlock)block { _reportBlock = block; } - (void)setRepairBlock:(ABSRepairBlock)block { _repairBlock = block; } /*! * “连续启动崩溃计数”个数，对应的Key * 默认为 \u0026quot;_CONTINUOUS_CRASH_COUNTER_KEY\u0026quot; */ + (NSString *)continuousCrashOnLaunchCounterKeyWithContext:(NSString *)context { BOOL isValid = [[self class] isValidString:context]; NSString *validContext = isValid ? context : @\u0026quot;\u0026quot;; NSString *continuousCrashOnLaunchCounterKey = [NSString stringWithFormat:@\u0026quot;%@_CONTINUOUS_CRASH_COUNTER_KEY\u0026quot;, validContext]; return continuousCrashOnLaunchCounterKey; } /*! * 是否正在修复记录，对应的Key * 默认为 \u0026quot;_CONTINUOUS_CRASH_FIXING_KEY\u0026quot; */ + (NSString *)continuousCrashFixingKeyWithContext:(NSString *)context { BOOL isValid = [[self class] isValidString:context]; NSString *validContext = isValid ? context : @\u0026quot;\u0026quot;; NSString *continuousCrashFixingKey = [NSString stringWithFormat:@\u0026quot;%@_CONTINUOUS_CRASH_FIXING_KEY\u0026quot;, validContext]; return continuousCrashFixingKey; } /*! * 是否正在检查是否在特定时间内会Crash，对应的Key * 默认为 \u0026quot;_CONTINUOUS_CRASH_CHECKING_KEY\u0026quot; */ + (NSString *)continuousCrashNormalCheckingKeyWithContext:(NSString *)context { BOOL isValid = [[self class] isValidString:context]; NSString *validContext = isValid ? context : @\u0026quot;\u0026quot;; NSString *continuousCrashFixingKey = [NSString stringWithFormat:@\u0026quot;%@_CONTINUOUS_CRASH_CHECKING_KEY\u0026quot;, validContext]; return continuousCrashFixingKey; } #pragma mark - #pragma mark - log and util Methods + (void)setLogger:(void (^)(NSString *))logger { Logger = [logger copy]; } + (void)Logger:(NSString *)log { if (Logger) Logger(log); } + (BOOL)isValidString:(id)notValidString { if (!notValidString) { return NO; } if (![notValidString isKindOfClass:[NSString class]]) { return NO; } NSInteger stringLength = 0; @try { stringLength = [notValidString length]; } @catch (NSException *exception) {} if (stringLength == 0) { return NO; } return YES; } @end 下面是相应的验证步骤：\n等待15秒会有对应计数清零的操作日志输出：\n2018-01-18 16:25:37.162980+0800 BootingProtection[89773:15553277] 🔴类名与方法名：-[AppDelegate onBeforeBootingProtection]_block_invoke（在第45行），描述：CYLBootingProtection: Launch continuous crash report 2018-01-18 16:25:37.163140+0800 BootingProtection[89773:15553277] 🔴类名与方法名：-[AppDelegate onBeforeBootingProtection]_block_invoke（在第45行），描述：setIsNormalChecking:{0} 2018-01-18 16:25:37.165738+0800 BootingProtection[89773:15553277] 🔴类名与方法名：-[AppDelegate onBeforeBootingProtection]_block_invoke（在第45行），描述：setisFixingCrash:{0} 2018-01-18 16:25:37.166883+0800 BootingProtection[89773:15553277] 🔴类名与方法名：-[AppDelegate onBeforeBootingProtection]_block_invoke（在第45行），描述：crashCount:0 2018-01-18 16:25:37.167102+0800 BootingProtection[89773:15553277] 🔴类名与方法名：-[AppDelegate onBeforeBootingProtection]_block_invoke（在第45行），描述：crashCount:0 2018-01-18 16:25:37.167253+0800 BootingProtection[89773:15553277] 🔴类名与方法名：-[AppDelegate onBeforeBootingProtection]_block_invoke（在第45行），描述：setIsNormalChecking:{1} 2018-01-18 16:25:37.167938+0800 BootingProtection[89773:15553277] 🔴类名与方法名：-[AppDelegate onBeforeBootingProtection]_block_invoke（在第45行），描述：setCrashCount:1 2018-01-18 16:25:37.168806+0800 BootingProtection[89773:15553277] 🔴类名与方法名：-[AppDelegate onBeforeBootingProtection]_block_invoke（在第45行），描述：need no repair 2018-01-18 16:25:52.225197+0800 BootingProtection[89773:15553277] 🔴类名与方法名：-[AppDelegate onBeforeBootingProtection]_block_invoke（在第45行），描述：CYLBootingProtection: long live the app ( more than 15 seconds ), now reset crash counts 2018-01-18 16:25:52.225378+0800 BootingProtection[89773:15553277] 🔴类名与方法名：-[AppDelegate onBeforeBootingProtection]_block_invoke（在第45行），描述：setCrashCount:0 2018-01-18 16:25:52.226234+0800 BootingProtection[89773:15553277] 🔴类名与方法名：-[AppDelegate onBeforeBootingProtection]_block_invoke（在第45行），描述：setIsNormalChecking:{0} 2018-01-18 16:25:52.226595+0800 BootingProtection[89773:15553277] 🔴类名与方法名：-[AppDelegate onBeforeBootingProtection]_block_invoke（在第45行），描述：setisFixingCrash:{0}  Posted by 微博@iOS程序犭袁\n原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | Creative Commons BY-NC-ND 3.0\n","title":"连续启动 crash 自修复技术实现与原理解析"},{"link":"https://blog.policx.com/posts/nginx/","text":"什么是Nginx? Nginx (engine x) 是一款轻量级的Web 服务器 、反向代理服务器及电子邮件（IMAP/POP3）代理服务器。\n什么是反向代理？ 反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。 安装与使用 安装 nginx官网下载地址：https://nginx.org，发布版本分为 Linux 和 windows 版本。\n也可以下载源码，编译后运行。\n从源代码编译 Nginx\n把源码解压缩之后，在终端里运行如下命令：\n默认情况下，Nginx 会被安装在 /usr/local/nginx。通过设定编译选项，你可以改变这个设定。\nWindows 安装\n为了安装 Nginx / Win32，需先下载它。然后解压之，然后运行即可。下面以 C 盘根目录为例说明下： Nginx / Win32 是运行在一个控制台程序，而非 windows 服务方式的。服务器方式目前还是开发尝试中。\n使用 nginx 的使用比较简单，就是几条命令。\n常用到的命令如下：\nnginx -s stop ：快速关闭Nginx，可能不保存相关信息，并迅速终止web服务。 nginx -s quit ：平稳关闭Nginx，保存相关信息，有安排的结束web服务。 nginx -s reload ：因改变了Nginx相关配置，需要重新加载配置而重载。 nginx -s reopen ：重新打开日志文件。 nginx -c filename ：为 Nginx 指定一个配置文件，来代替缺省的。 nginx -t ：不运行，而仅仅测试配置文件。nginx 将检查配置文件的语法的正确性，并尝试打开配置文件中所引用到的文件。 nginx -v：显示 nginx 的版本。 nginx -V：显示 nginx 的版本，编译器版本和配置参数。 如果不想每次都敲命令，可以在nginx安装目录下新添一个启动批处理文件startup.bat，双击即可运行。内容如下：\n如果是运行在 Linux 下，写一个 shell 脚本，大同小异。\nnginx 配置实战 我始终认为，各种开发工具的配置还是结合实战来讲述，会让人更易理解。\nhttp反向代理配置\n我们先实现一个小目标：不考虑复杂的配置，仅仅是完成一个 http 反向代理。\nnginx.conf 配置文件如下：\n注：conf / nginx.conf 是 nginx 的默认配置文件。你也可以使用 nginx -c 指定你的配置文件 好了，让我们来试试吧：\n启动 webapp，注意启动绑定的端口要和nginx中的 upstream 设置的端口保持一致。\n更改 host：\n在 C:Windows\\System32\\drivers\\etc 目录下的host文件中添加一条DNS 记录127.0.0.1 www.javastack.cn 启动前文中 startup.bat 的命令\n在浏览器中访问 www.javastack.cn，不出意外，已经可以访问了。\n负载均衡配置\n上一个例子中，代理仅仅指向一个服务器。\n但是，网站在实际运营过程中，多半都是有多台服务器运行着同样的app，这时需要使用负载均衡来分流。\nnginx也可以实现简单的负载均衡功能。\n假设这样一个应用场景：将应用部署在 192.168.1.11:80、192.168.1.12:80、192.168.1.13:80 三台linux环境的服务器上。网站域名叫 www.javastack.cn，公网IP为 192.168.1.11。在公网IP所在的服务器上部署 nginx，对所有请求做负载均衡处理。\nnginx.conf 配置如下： 网站有多个webapp的配置\n当一个网站功能越来越丰富时，往往需要将一些功能相对独立的模块剥离出来，独立维护。这样的话，通常，会有多个 webapp。\n举个例子：假如 www.javastack.cn 站点有好几个webapp，finance（金融）、product（产品）、admin（用户中心）。访问这些应用的方式通过上下文(context)来进行区分:\nwww.javastack.cn/finance/\nwww.javastack.cnproduct/\nwww.javastack.cn/admin/\n我们知道，http的默认端口号是80，如果在一台服务器上同时启动这3个 webapp 应用，都用80端口，肯定是不成的。所以，这三个应用需要分别绑定不同的端口号。\n那么，问题来了，用户在实际访问 www.javastack.cn 站点时，访问不同 webapp，总不会还带着对应的端口号去访问吧。所以，你再次需要用到反向代理来做处理。\n配置也不难，来看看怎么做吧： https反向代理配置\n一些对安全性要求比较高的站点，可能会使用 HTTPS（一种使用ssl通信标准的安全HTTP协议）。\n这里不科普 HTTP 协议和 SSL 标准。但是，使用 nginx 配置 https 需要知道几点：\nHTTPS 的固定端口号是 443，不同于 HTTP 的 80 端口\nSSL 标准需要引入安全证书，所以在 nginx.conf 中你需要指定证书和它对应的 key\n其他和 http 反向代理基本一样，只是在 Server 部分配置有些不同。 静态站点配置\n有时候，我们需要配置静态站点(即 html 文件和一堆静态资源)。\n举例来说：如果所有的静态资源都放在了 /app/dist 目录下，我们只需要在 nginx.conf 中指定首页以及这个站点的 host 即可。\n配置如下： 然后，添加 HOST：\n127.0.0.1 static.zp.cn，此时，在本地浏览器访问 static.zp.cn ，就可以访问静态站点了。\n跨域解决方案\nweb 领域开发中，经常采用前后端分离模式。这种模式下，前端和后端分别是独立的 web 应用程序，例如：后端是 Java 程序，前端是 React 或 Vue 应用\n各自独立的 web app 在互相访问时，势必存在跨域问题。解决跨域问题一般有两种思路：\nCORS\n在后端服务器设置 HTTP 响应头，把你需要运行访问的域名加入加入 Access-Control-Allow-Origin 中。\njsonp\n把后端根据请求，构造json数据，并返回，前端用 jsonp 跨域。\n这两种思路，本文不展开讨论。\n需要说明的是，nginx 根据第一种思路，也提供了一种解决跨域的解决方案。\n举例：www.javastack.cn 网站是由一个前端 app ，一个后端 app 组成的。前端端口号为 9000， 后端端口号为 8080。\n前端和后端如果使用 http 进行交互时，请求会被拒绝，因为存在跨域问题。来看看，nginx 是怎么解决的吧：\n首先，在 enable-cors.conf 文件中设置 cors ： 接下来，在你的服务器中 include enable-cors.conf 来引入跨域配置： 到此，就完成了。\n","title":"Nginx"},{"link":"https://blog.policx.com/posts/bye/","text":"告别工作多年的公司，我要有自己公司了。\n","title":"告别"},{"link":"https://blog.policx.com/posts/gcd-global/","text":"本文对应 Demo 以及 Markdown 文件在仓库中，文中的错误可以提 PR 到这个文件，我会及时更改。\n 目录  避免使用 GCD Global队列创建Runloop常驻线程  GCD Global队列创建线程进行耗时操作的风险 避免使用 GCD Global 队列创建 Runloop 常驻线程  单一 Runloop 常驻线程 多个 Runloop 常驻线程      GCD Global队列创建线程进行耗时操作的风险 先思考下如下几个问题：\n 新建线程的方式有哪些？各自的优缺点是什么？ dispatch_async 函数分发到全局队列一定会新建线程执行任务么？ 如果全局队列对应的线程池如果满了，后续的派发的任务会怎么处置？有什么风险？  答案大致是这样的：dispatch_async 函数分发到全局队列不一定会新建线程执行任务，全局队列底层有一个的线程池，如果线程池满了，那么后续的任务会被 block 住，等待前面的任务执行完成，才会继续执行。如果线程池中的线程长时间不结束，后续堆积的任务会越来越多，此时就会存在 APP crash的风险。\n比如：\n1 2 3 4 5 6 7 8 9 10 11 12 13  - (void)dispatchTest1 { for (NSInteger i = 0; i\u0026lt; 10000 ; i++) { dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ [self dispatchTask:i]; }); } } - (void)dispatchTask:(NSInteger)index { //模拟耗时操作，比如DB,网络，文件读写等等  sleep(30); NSLog(@\u0026#34;----:%ld\u0026#34;,index); }   以上逻辑用真机测试会有卡死的几率，并非每次都会发生，但多尝试几次就会复现，伴随前后台切换，crash几率增大。\n下面做一下分析：\n参看 GCD 源码我们可以看到全局队列的相关源码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87  DISPATCH_NOINLINE static void _dispatch_queue_wakeup_global_slow(dispatch_queue_t dq, unsigned int n) { dispatch_root_queue_context_t qc = dq-\u0026gt;do_ctxt; uint32_t i = n; int r; _dispatch_debug_root_queue(dq, __func__); dispatch_once_f(\u0026amp;_dispatch_root_queues_pred, NULL, _dispatch_root_queues_init); #if HAVE_PTHREAD_WORKQUEUES #if DISPATCH_USE_PTHREAD_POOL  if (qc-\u0026gt;dgq_kworkqueue != (void*)(~0ul)) #endif  { _dispatch_root_queue_debug(\u0026#34;requesting new worker thread for global \u0026#34; \u0026#34;queue: %p\u0026#34;, dq); #if DISPATCH_USE_LEGACY_WORKQUEUE_FALLBACK  if (qc-\u0026gt;dgq_kworkqueue) { pthread_workitem_handle_t wh; unsigned int gen_cnt; do { r = pthread_workqueue_additem_np(qc-\u0026gt;dgq_kworkqueue, _dispatch_worker_thread4, dq, \u0026amp;wh, \u0026amp;gen_cnt); (void)dispatch_assume_zero(r); } while (--i); return; } #endif // DISPATCH_USE_LEGACY_WORKQUEUE_FALLBACK #if HAVE_PTHREAD_WORKQUEUE_SETDISPATCH_NP  if (!dq-\u0026gt;dq_priority) { r = pthread_workqueue_addthreads_np(qc-\u0026gt;dgq_wq_priority, qc-\u0026gt;dgq_wq_options, (int)i); (void)dispatch_assume_zero(r); return; } #endif #if HAVE_PTHREAD_WORKQUEUE_QOS  r = _pthread_workqueue_addthreads((int)i, dq-\u0026gt;dq_priority); (void)dispatch_assume_zero(r); #endif  return; } #endif // HAVE_PTHREAD_WORKQUEUES #if DISPATCH_USE_PTHREAD_POOL  dispatch_pthread_root_queue_context_t pqc = qc-\u0026gt;dgq_ctxt; if (fastpath(pqc-\u0026gt;dpq_thread_mediator.do_vtable)) { while (dispatch_semaphore_signal(\u0026amp;pqc-\u0026gt;dpq_thread_mediator)) { if (!--i) { return; } } } uint32_t j, t_count; // seq_cst with atomic store to tail \u0026lt;rdar://problem/16932833\u0026gt;  t_count = dispatch_atomic_load2o(qc, dgq_thread_pool_size, seq_cst); do { if (!t_count) { _dispatch_root_queue_debug(\u0026#34;pthread pool is full for root queue: \u0026#34; \u0026#34;%p\u0026#34;, dq); return; } j = i \u0026gt; t_count ? t_count : i; } while (!dispatch_atomic_cmpxchgvw2o(qc, dgq_thread_pool_size, t_count, t_count - j, \u0026amp;t_count, acquire)); pthread_attr_t *attr = \u0026amp;pqc-\u0026gt;dpq_thread_attr; pthread_t tid, *pthr = \u0026amp;tid; #if DISPATCH_ENABLE_PTHREAD_ROOT_QUEUES  if (slowpath(dq == \u0026amp;_dispatch_mgr_root_queue)) { pthr = _dispatch_mgr_root_queue_init(); } #endif  do { _dispatch_retain(dq); while ((r = pthread_create(pthr, attr, _dispatch_worker_thread, dq))) { if (r != EAGAIN) { (void)dispatch_assume_zero(r); } _dispatch_temporary_resource_shortage(); } } while (--j); #endif // DISPATCH_USE_PTHREAD_POOL }   对于执行的任务来说，所执行的线程具体是哪个线程，则是通过 GCD 的线程池（Thread Pool）来进行调度，正如Concurrent Programming: APIs and Challenges文章里给的示意图所示：\n上面贴的源码，我们关注如下的部分：\n其中有一个用来记录线程池大小的字段 dgq_thread_pool_size。这个字段标记着GCD线程池的大小。摘录上面源码的一部分：\n1 2 3 4 5 6 7 8 9 10 11 12 13  uint32_t j, t_count; // seq_cst with atomic store to tail \u0026lt;rdar://problem/16932833\u0026gt;  t_count = dispatch_atomic_load2o(qc, dgq_thread_pool_size, seq_cst); do { if (!t_count) { _dispatch_root_queue_debug(\u0026#34;pthread pool is full for root queue: \u0026#34; \u0026#34;%p\u0026#34;, dq); return; } j = i \u0026gt; t_count ? t_count : i; } while (!dispatch_atomic_cmpxchgvw2o(qc, dgq_thread_pool_size, t_count, t_count - j, \u0026amp;t_count, acquire));   从源码中我们可以对应到官方文档 ：Getting the Global Concurrent Dispatch Queues里的说法：\n A concurrent dispatch queue is useful when you have multiple tasks that can run in parallel. A concurrent queue is still a queue in that it dequeues tasks in a first-in, first-out order; however, a concurrent queue may dequeue additional tasks before any previous tasks finish. The actual number of tasks executed by a concurrent queue at any given moment is variable and can change dynamically as conditions in your application change. Many factors affect the number of tasks executed by the concurrent queues, including the number of available cores, the amount of work being done by other processes, and the number and priority of tasks in other serial dispatch queues.\n 也就是说：\n全局队列的底层是一个线程池，向全局队列中提交的 block，都会被放到这个线程池中执行，如果线程池已满，后续再提交 block 就不会再重新创建线程。这就是为什么 Demo 会造成卡顿甚至冻屏的原因。\n避免使用 GCD Global 队列创建 Runloop 常驻线程 在做网路请求时我们常常创建一个 Runloop 常驻线程用来接收、响应后续的服务端回执，比如NSURLConnection、AFNetworking等等，我们可以称这种线程为 Runloop 常驻线程。\n正如上文所述，用 GCD Global 队列创建线程进行耗时操作是存在风险的。那么我们可以试想下，如果这个耗时操作变成了 runloop 常驻线程，会是什么结果？下面做一下分析：\n先介绍下 Runloop 常驻线程的原理，在开发中一般有两种用法：\n 单一 Runloop 常驻线程：在 APP 的生命周期中开启了唯一的常驻线程来进行网络请求，常用于网络库，或者有维持长连接需求的库，比如： AFNetworking 、 SocketRocket。 多个 Runloop 常驻线程：每进行一次网络请求就开启一条 Runloop 常驻线程，这条线程的生命周期的起点是网络请求开始，终点是网络请求结束，或者网络请求超时。  单一 Runloop 常驻线程 先说第一种用法：\n以 AFNetworking 为例，AFURLConnectionOperation 这个类是基于 NSURLConnection 构建的，其希望能在后台线程接收 Delegate 回调。为此 AFNetworking 单独创建了一个线程，并在这个线程中启动了一个 RunLoop：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  + (void)networkRequestThreadEntryPoint:(id)__unused object { @autoreleasepool { [[NSThread currentThread] setName:@\u0026#34;AFNetworking\u0026#34;]; NSRunLoop *runLoop = [NSRunLoop currentRunLoop]; [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode]; [runLoop run]; } } + (NSThread *)networkRequestThread { static NSThread *_networkRequestThread = nil; static dispatch_once_t oncePredicate; dispatch_once(\u0026amp;oncePredicate, ^{ _networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil]; [_networkRequestThread start]; }); return _networkRequestThread; }   多个 Runloop 常驻线程 第二种用法，我写了一个小 Demo 来模拟这种场景，\n我们模拟了一个场景：假设所有的网络请求全部超时，或者服务端根本不响应，然后网络库超时检测机制的做法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51  #import \u0026#34;Foo.h\u0026#34;  @interface Foo() { NSRunLoop *_runloop; NSTimer *_timeoutTimer; NSTimeInterval _timeoutInterval; dispatch_semaphore_t _sem; } @end @implementation Foo - (instancetype)init { if (!(self = [super init])) { return nil; } _timeoutInterval = 1 ; _sem = dispatch_semaphore_create(0); // Do any additional setup after loading the view, typically from a nib.  return self; } - (id)test { // 第一种方式：  // NSThread *networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint0:) object:nil];  // [networkRequestThread start];  //第二种方式:  dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^(void) { [self networkRequestThreadEntryPoint0:nil]; }); dispatch_semaphore_wait(_sem, DISPATCH_TIME_FOREVER); return @(YES); } - (void)networkRequestThreadEntryPoint0:(id)__unused object { @autoreleasepool { [[NSThread currentThread] setName:@\u0026#34;CYLTest\u0026#34;]; _runloop = [NSRunLoop currentRunLoop]; [_runloop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode]; _timeoutTimer = [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(stopLoop) userInfo:nil repeats:NO]; [_runloop addTimer:_timeoutTimer forMode:NSRunLoopCommonModes]; [_runloop run];//在实际开发中最好使用这种方式来确保能runloop退出，做双重的保障[runloop runUntilDate:[NSDate dateWithTimeIntervalSinceNow:(timeoutInterval+5)]];  } } - (void)stopLoop { CFRunLoopStop([_runloop getCFRunLoop]); dispatch_semaphore_signal(_sem); } @end   如果\n1 2 3 4 5 6  for (int i = 0; i \u0026lt; 300 ; i++) { dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^(void) { [[Foo new] test]; NSLog(@\u0026#34;🔴类名与方法名：%@（在第%@行），描述：%@\u0026#34;, @(__PRETTY_FUNCTION__), @(__LINE__), @\u0026#34;\u0026#34;); }); }   以上逻辑用真机测试会有卡死的几率，并非每次都会发生，但多尝试几次就会复现，伴随前后台切换，crash几率增大。\n其中我们采用了 GCD 全局队列的方式来创建常驻线程，因为在创建时可能已经出现了全局队列的线程池满了的情况，所以 GCD 派发的任务，无法执行，而且我们把超时检测的逻辑放进了这个任务中，所以导致的情况就是，有很多任务的超时检测功能失效了。此时就只能依赖于服务端响应来结束该任务（服务端响应能结束该任务的逻辑在 Demo 中未给出），但是如果再加之服务端不响应，那么任务就永远不会结束。后续的网络请求也会就此 block 住，造成 crash。\n如果我们把 GCD 全局队列换成 NSThread 的方式，那么就可以保证每次都会创建新的线程。\n注意：文章中只演示的是超时 cancel runloop 的操作，实际项目中一定有其他主动 cancel runloop 的操作，就比如网络请求成功或失败后需要进行cancel操作。代码中没有展示网络请求成功或失败后的 cancel 操作。\nDemo 的这种模拟可能比较极端，但是如果你维护的是一个像 AFNetworking 这样的一个网络库，你会放心把创建常驻线程这样的操作交给 GCD 全局队列吗？因为整个 APP 是在共享一个全局队列的线程池，那么如果 APP 把线程池沾满了，甚至线程池长时间占满且不结束，那么 AFNetworking 就自然不能再执行任务了，所以我们看到，即使是只会创建一条常驻线程， AFNetworking 依然采用了 NSThread 的方式而非 GCD 全局队列这种方式。\n注释：以下方法存在于老版本AFN 2.x 中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  + (void)networkRequestThreadEntryPoint:(id)__unused object { @autoreleasepool { [[NSThread currentThread] setName:@\u0026#34;AFNetworking\u0026#34;]; NSRunLoop *runLoop = [NSRunLoop currentRunLoop]; [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode]; [runLoop run]; } } + (NSThread *)networkRequestThread { static NSThread *_networkRequestThread = nil; static dispatch_once_t oncePredicate; dispatch_once(\u0026amp;oncePredicate, ^{ _networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil]; [_networkRequestThread start]; }); return _networkRequestThread; }   正如你所看到的，没有任何一个库会用 GCD 全局队列来创建常驻线程，而你也应该\n 避免使用 GCD Global 队列来创建 Runloop 常驻线程。\n  Posted by 微博@iOS程序犭袁\n原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | Creative Commons BY-NC-ND 3.0\n ","title":"避免使用 GCD Global队列创建Runloop常驻线程"},{"link":"https://blog.policx.com/posts/%E5%96%84%E7%94%A8%E4%BD%B3%E8%BD%AF-%E9%A2%84%E8%A7%88/","text":"「预览」作为 Mac 自带的 PDF\u0026amp;图片 应用，大都数用户只是拿来当 图像查看器 使用，而并不了解它的诸多功能。Mac 很多系统级应用都有很好的体验，比如截图、提醒事项、录屏等等，它们满足硬性需求，且和 iPhone 能更好的协同，虽然部分不如第三方软件功能丰富，但也十分简洁。\n我使用「预览」最频繁的功能就是 PDF 创建、合并和排序了。 比如要做上个月的报销凭证，所有凭证拍照、收集完毕后，在 Finder 中全选-右键，可以创建 PDF。打开该 PDF 文件，可以通过上下拖拽进行排序，如果要加入新的凭证，可以从 Finder 将图片或 PDF 文件拖拽至「预览」左侧缩略图列表中。\n除了这个，「预览」还有很多功能，随便讲几个：\n1.签名\n需要给文件签名，没有打印机，只需要用「预览」打开需要签名的文件，点击签名菜单，可以通过 触摸板书写、摄像头获取两种方式生成签名，附加在需要签名的文件上。\n2.加密\n如果你的 PDF 文件涉及机密，可以点击「预览」的导出，选择 PDF 格式，选择密码选项，设置需要的密码即可。\n3.格式转换 「预览」可以将图像文件转换为许多文件类型，包括 HEIC、JPEG、JPEG 2000、PDF、PNG 和 TIFF 等，只需要在导出时选择需要的格式。其中，JPEG、JPEG 2000支持调节质量大小，PDF 支持加密和滤镜选项，Quartz 滤镜还包括了减小文件尺寸的子选项。\n4.图片处理\n调整尺寸、颜色、即时 Alpha抠图、速写、形状…… 能够满足简单的图片处理需求。\n还有其他一些功能就不一一介绍了，有兴趣的同学可以查看这「预览」的官方使用手册，不妨挖掘下。\n\n","title":"善用佳软 预览"},{"link":"https://blog.policx.com/posts/3year/","text":"三周年庆典🎉\n","title":"融贝三周年"},{"link":"https://blog.policx.com/posts/applesupport/","text":"🤔\n","title":"王者荣耀"},{"link":"https://blog.policx.com/posts/xue/","text":"雪下的那么深，下的那么认真。\n  \n","title":"下雪了"},{"link":"https://blog.policx.com/posts/block-callback/","text":"iOS10推送部分的API，大量使用了 CompletionHandler 这种命名方式，那么本文我们将对比下这种 Block 的特殊性，以便更好的理解和在自己的项目中实践 CompletionHandler 样式的 Blcok。\n我们作为开发者去集成一个 Lib （也可以叫轮子、SDK、下文统一叫 Lib）时，我们会发现我们遇到的 Block， 按照功能的角度划分，其实可以分为这几种：\n Lib 通知开发者，Lib操作已经完成。一般命名为 Callback 开发者通知 Lib，开发者的操作已经完成。一般可以命名为 CompletionHandler。  这两处的区别： 前者是 “Block 的执行”，后者是 “Block 的填充”。\nCallback vs CompletionHandler 命名与功能的差别，Apple 也没有明确的编码规范指出过，只不过如果按照“执行与填充”的功能划分的话，callback 与 completionHandler 的命名可以区分开来对待。同时也方便调用者理解 block 的功能。但总体来说，Apple 官方的命名中，“Block 填充“这个功能一般都会命名为 “completionHandler”，“Block 执行”这个功能大多命名为了“callback” ，也有少部分命名为了 “completionHandler”。\n比如：\nNSURLSession 中，下面的函数将 “callback” 命名为了 “completionHandler”：\n- (NSURLSessionDataTask *)dataTaskWithURL:(NSURL *)url completionHandler:(void (^)(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error))completionHandler; 我们常常见到 CompletionHandler 被用到了第一种场景，而第一种场景“Block 执行”命名为 Callback 则更合适。\n 不是所有 Block 都适合叫做 CompletionHandler\n 一般情况下，CompletionHandler 的设计往往考虑到多线程操作，于是，你就完全可以异步操作，然后在线程结束时执行该 CompletionHandler，下文的例子中会讲述下 CompletionHandler 方式在多线程场景下的一些优势。\nCompletionHandler + Delegate 组合 在 iOS10 中新增加的 UserNotificaitons 中大量使用了这种 Block，比如：\n- (void)userNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse:(UNNotificationResponse *)response withCompletionHandler:(void (^)(void))completionHandler; 文档 对 completionHandler 的注释是这样的：\nThe block to execute when you have finished processing the user’s response. You must execute this block from your method and should call it as quickly as possible. The block has no return value or parameters. 同样在这里也有应用：\n- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential * __nullable credential))completionHandler; 还有另外一个也非常普遍的例子（Delegate 方式使用URLSession 时候必不可少的 4个代理函数之一 ）\n- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveResponse:(NSURLResponse *)response completionHandler:(void (^)(NSURLSessionResponseDisposition disposition))completionHandler; 在代理方法实现代码里面，若是不执行 completionHandler(NSURLSessionResponseAllow) 话，http请求就终止了。\nCompletionHandler + Block 组合 函数中将函数作为参数或者返回值，就叫做高阶函数。\n按照这种定义，Block 中将 Block 作为参数，这也就是高阶函数。\n结合实际的应用场景来看一个例子：\n如果有这样一个需求：\n拿我之前的一个 IM 项目 ChatKit-OC （开源的，下面简称 ChatKit）为例，当你的应用想要集成一个 IM 服务时，可能这时候，你的 APP 已经上架了，已经有自己的注册、登录等流程了。用 ChatKit 进行聊天很简单，只需要给 ChatKit 一个 id 就够了。聊天是正常了，但是双方只能看到一个id，这样体验很不好。但是如何展示头像、昵称呢？于是就设计了这样一个接口，-setFetchProfilesBlock: 。\n这是上层（APP）提供用户信息的 Block，由于 ChatKit 并不关心业务逻辑信息，比如用户昵称，用户头像等。用户可以通过 ChatKit 单例向 ChatKit 注入一个用户信息内容提供 Block，通过这个用户信息提供 Block，ChatKit 才能够正确的进行业务逻辑数据的绘制。\n示意图如下： 具体实现如下：\n方法定义如下：\n/*! * @brief The block to execute with the users' information for the userIds. Always execute this block at some point when fetching profiles completes on main thread. Specify users' information how you want ChatKit to show. * @attention If you fetch users fails, you should reture nil, meanwhile, give the error reason. */ typedef void(^LCCKFetchProfilesCompletionHandler)(NSArray\u0026lt;id\u0026lt;LCCKUserDelegate\u0026gt;\u0026gt; *users, NSError *error); /*! * @brief When LeanCloudChatKit wants to fetch profiles, this block will be invoked. * @param userIds User ids * @param completionHandler The block to execute with the users' information for the userIds. Always execute this block at some point during your implementation of this method on main thread. Specify users' information how you want ChatKit to show. */ typedef void(^LCCKFetchProfilesBlock)(NSArray\u0026lt;NSString *\u0026gt; *userIds, LCCKFetchProfilesCompletionHandler completionHandler); @property (nonatomic, copy) LCCKFetchProfilesBlock fetchProfilesBlock; /*! * @brief Add the ablitity to fetch profiles. * @attention You must get peer information by peer id with a synchronous implementation. * If implemeted, this block will be invoked automatically by LeanCloudChatKit for fetching peer profile. */ - (void)setFetchProfilesBlock:(LCCKFetchProfilesBlock)fetchProfilesBlock; 用法如下所示：\n#warning 注意：setFetchProfilesBlock 方法必须实现，如果不实现，ChatKit将无法显示用户头像、用户昵称。以下方法循环模拟了通过 userIds 同步查询 users 信息的过程，这里需要替换为 App 的 API 同步查询 [[LCChatKit sharedInstance] setFetchProfilesBlock:^(NSArray\u0026lt;NSString *\u0026gt; *userIds, LCCKFetchProfilesCompletionHandler completionHandler) { if (userIds.count == 0) { NSInteger code = 0; NSString *errorReasonText = @\u0026quot;User ids is nil\u0026quot;; NSDictionary *errorInfo = @{ @\u0026quot;code\u0026quot;:@(code), NSLocalizedDescriptionKey : errorReasonText, }; NSError *error = [NSError errorWithDomain:NSStringFromClass([self class]) code:code userInfo:errorInfo]; !completionHandler ?: completionHandler(nil, error); return; } NSMutableArray *users = [NSMutableArray arrayWithCapacity:userIds.count]; #warning 注意：以下方法循环模拟了通过 userIds 同步查询 users 信息的过程，这里需要替换为 App 的 API 同步查询 [userIds enumerateObjectsUsingBlock:^(NSString *_Nonnull clientId, NSUInteger idx, BOOL *_Nonnull stop) { NSPredicate *predicate = [NSPredicate predicateWithFormat:@\u0026quot;peerId like %@\u0026quot;, clientId]; //这里的LCCKContactProfiles，LCCKProfileKeyPeerId都为事先的宏定义， NSArray *searchedUsers = [LCCKContactProfiles filteredArrayUsingPredicate:predicate]; if (searchedUsers.count \u0026gt; 0) { NSDictionary *user = searchedUsers[0]; NSURL *avatarURL = [NSURL URLWithString:user[LCCKProfileKeyAvatarURL]]; LCCKUser *user_ = [LCCKUser userWithUserId:user[LCCKProfileKeyPeerId] name:user[LCCKProfileKeyName] avatarURL:avatarURL clientId:clientId]; [users addObject:user_]; } else { //注意：如果网络请求失败，请至少提供 ClientId！ LCCKUser *user_ = [LCCKUser userWithClientId:clientId]; [users addObject:user_]; } }]; // 模拟网络延时，3秒 // sleep(3); #warning 重要：completionHandler 这个 Bock 必须执行，需要在你**获取到用户信息结束**后，将信息传给该Block！ !completionHandler ?: completionHandler([users copy], nil); }]; 对于以上 Fetch 方法的这种应用场景，其实用方法的返回值也可以实现，但是与 CompletionHandler 相比，无法自由切换线程是个弊端。\n Posted by 微博@iOS程序犭袁\n原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | Creative Commons BY-NC-ND 3.0\n ","title":"有一种 Block 叫 Callback，有一种 Callback 叫 CompletionHandler"},{"link":"https://blog.policx.com/posts/jianpan/","text":"工欲善其事必先利其器!\n 废话不多说, 总结下XCode快捷键:\n关于以上技术符号是如何打出来的, 也有一个快捷键: ⌃⌘spacing 即可唤出\n特殊符号界面\n也可以参考下面链接中的方法: 链接   偏好设置: ⌘, 隐藏Xcode: ⌘H 隐藏其他应用: ⌥⌘H 退出Xcode:⌘Q 新的表单: ⌘T  新的表单\n 新的窗口: ⇧⌘T 新的文件: ⌘N 新的工程: ⇧⌘N 新的组文件夹: ⌥⌘N  新的组文件夹\n 添加文件: ⌥⌘A 打开: ⌘O 快速打开: ⇧⌘O 关闭窗口: ⌘W 关闭所有窗口: ⌥⌘W 关闭表单: ⌃⌘W 保存: ⌘S 保存所有: ⌥⌘S 另存为: ⇧⌘S 提交: ⌥⌘C 更新: ⌥⌘X 更新全部: ⌃⌥⌘X 撤销: ⌘Z 恢复: ⇧⌘Z 剪切: ⌘X 赋值: ⌘C 粘贴: ⌘V 全选: ⌘A 在工作空间查找: ⇧⌘F 在工作空间查找并替换: ⌥⇧⌘F 查找: ⌘F 查找并替换: ⌥⌘F 查找下一个: ⌘G 查找上一个: ⇧⌘G  视图\n 工程: ⌘1 结构: ⌘2 查找: ⌘3 事务: ⌘4 测试: ⌘5 状态: ⌘6 断点: ⌘7 日志: ⌘8 显示或者隐藏导航条: ⌘0  显示或者隐藏导航条\n 标准视图: ⌘↩︎ 辅助视图: ⌥⌘↩︎ 版本视图: ⌥⇧⌘↩︎ 显示相关项目: ⌃1  显示相关项目\n 显示浏览历史: ⌃2  显示浏览历史\n 显示顶层项目: ⌃4  显示顶层项目\n 显示组内文件: ⌃5  显示组内文件\n 显示文件项目(查看属性, 方法, 函数等): ⌃6  14.gif\n 显示或隐藏控制台: ⇧⌘Y 在导航栏中显示: ⇧⌘J\n常常配合⇧⌘O使用, 先用⇧⌘O查找相关文件, 然后使用⇧⌘J定位到文件相应的位置  在导航栏中显示\n 在辅助窗口打开当前文件: ⌥⌘, 光标焦点移动: ⌘J 翻到下一页: ⌃⌘→ 辅助窗口翻到下一页: ⌃⌥⌘→ 复杂的翻到下一页: ⌃⌥⇧⌘→  复杂的翻到下一页\n 翻到上一页: ⌃⌘← 辅助窗口翻到上一页: ⌃⌥⌘← 复杂的翻到上一页: ⌃⌥⇧⌘← 跳转到光标所在位置: ⇧⌘L 跳转到定义: ⌃⌘D\n先将光标放在需要跳转的类, 方法, 函数等上面, 然后按⌃⌘D, 跳进去看, 相当于按住⌘键点击鼠标左键 跳转到.h或者.m文件: ⌃⌘↑, ⌃⌘↓ 跳转到具体哪一行: ⌘L 跳转到下一个占位: ⌃/ 跳转到上一个占位: ⌃?  跳转到上一个占位\n Xcode全屏: ⌃⌘F 代码右移: ⌘] 代码左移: ⌘[ 代码上移:⌥⌘[ 代码下移:⌥⌘] 注释光标所在行: ⌘/ 折叠当前代码块: ⌥⌘← 打开当前代码块: ⌥⌘→ 折叠所有代码块:⌥⇧⌘← 打开所有代码块: ⌥⇧⌘→ 折叠所有注释: ⌃⇧⌘← 打开所有知识: ⌃⇧⌘→ 运行: ⌘R 条件运行: ⌥⌘R  条件运行\n 测试: ⌘U 条件测试: ⌥⌘U  条件测试\n 配置测试: ⌘I 条件配置测试  条件配置测试\n 分析: ⇧⌘B 条件分析: ⌥⇧⌘B 运行编译: ⇧⌘R 测试编译: ⇧⌘U 配置编译: ⇧⌘I 编译: ⌘B 清除缓存: ⇧⌘K 清除编译文件夹中内容: ⌥⇧⌘K 停止: ⌘. 暂停: ⌃⌘Y 在当前行添加断点: ⌘\\ 激活所有断点: ⌘Y 清除控制台所有打印: ⌘K 条件编辑: ⌘\u0026lt; 最小化: ⌘M 选择下一个表单: ⌘} 选择上一个表单:⌘{ 欢迎来到XCode界面: ⇧⌘1 来到设备界面: ⇧⌘2 API文档: ⇧⌘0 帮助查询: ⌘⇧? 查询选中: ⌃⌥⌘/ 快速查看选中: ⇧⌃⌘? 代码补全列表: ⎋ 移动到文本最顶端: ⌘↑ 移动到文本最末端: ⌘↓ 左移: ← 向右逐字移动并选中: ⇧→ 向左逐字移动并选中: ⌃⇧B, ⇧← 向上: ⌃P, ↑ 向下: ⌃N, ↓ 移动到段首并选中: ⌃⇧A 向右逐词移动并选中: ⌃⇧→ 向左逐词移动并选中: ⌃⇧← 向右节点选中: ⌥⇧→ 向左节点选中: ⌥⇧← 移动到文档最顶端并选中: ⇧⌘↑, ⇧↖︎ 向下移动并选中: ⌃⇧N, ⇧↓ 向前逐词选中: ⌃⌥⇧F 向后逐词选中: ⌃⌥⇧B 向前逐词移动: ⌥→, ⌃⌥F 向后逐词移动: ⌥←, ⌃⌥B 移动到行首: ⌃A 移动到行尾: ⌃E 移动到文档最末端并选中: ⇧⌘↓, ⇧↘︎ 向上分页选中: ⇧⇞ 向下翻页选中: ⇧⇟, ⌃⇧V 向后逐词移动: ⌥← 右移: → 移动到行的最右端并选中: ⇧⌘→ 向上逐行移动并选中: ⇧↑, ⌃⇧P 向右逐词移动并选中: ⌥⇧→ 向左逐词移动并选中: ⌥⇧← 向后逐词移动: ⌃⌥B 移动到行的最右端: ⌘→ 向后移动: ⌃B 向前移动: ⌃F 移动到行的最左端: ⌘← 向下翻页(光标移动): ⌥⇟, ⌃V 向上翻页(光标移动): ⌥⇞ 向下翻页(光标不移动): ⇟ 向下翻页到最底端: ↘︎ 向上翻页(光标不移动): ⇞ 向上翻页到最顶端: ↖︎ 逐行向上: ⌥↑ 逐行向下: ⌥↓ 删除整行: ⌃K 向前逐词删除: ⌥⌦ 向后逐词删除: ⌥⌫ 向前逐节点删除: ⌃⌦ 向后逐节点删除: ⌃⌫ 向前删除: ⌦, ⌃D 向后删除: ⌫, ⌃H 颠倒位置: ⌃T  颠倒位置\n 插入新的一行: ↩︎ 插入新的一行并顶到最前端: ⌃↩︎  ","title":"机械键盘"},{"link":"https://blog.policx.com/posts/programming/","text":"   红牛陪伴！\n","title":"programming"},{"link":"https://blog.policx.com/posts/banjia/","text":"   三年，再见。\n","title":"搬家"},{"link":"https://blog.policx.com/posts/clang-llvm/","text":"   前言 2000年，伊利诺伊大学厄巴纳－香槟分校（University of Illinois at Urbana-Champaign 简称UIUC）这所享有世界声望的一流公立研究型大学的 Chris Lattner（他的 twitter @clattner_llvm ） 开发了一个叫作 Low Level Virtual Machine 的编译器开发工具套件，后来涉及范围越来越大，可以用于常规编译器，JIT编译器，汇编器，调试器，静态分析工具等一系列跟编程语言相关的工作，于是就把简称 LLVM 这个简称作为了正式的名字。Chris Lattner 后来又开发了 Clang，使得 LLVM 直接挑战 GCC 的地位。2012年，LLVM 获得美国计算机学会 ACM 的软件系统大奖，和 UNIX，WWW，TCP/IP，Tex，JAVA 等齐名。\nChris Lattner 生于 1978 年，2005年加入苹果，将苹果使用的 GCC 全面转为 LLVM。2010年开始主导开发 Swift 语言。\niOS 开发中 Objective-C 是 Clang / LLVM 来编译的。\nswift 是 Swift / LLVM，其中 Swift 前端会多出 SIL optimizer，它会把 .swift 生成的中间代码 .sil 属于 High-Level IR， 因为 swift 在编译时就完成了方法绑定直接通过地址调用属于强类型语言，方法调用不再是像OC那样的消息发送，这样编译就可以获得更多的信息用在后面的后端优化上。\nLLVM是一个模块化和可重用的编译器和工具链技术的集合，Clang 是 LLVM 的子项目，是 C，C++ 和 Objective-C 编译器，目的是提供惊人的快速编译，比 GCC 快3倍，其中的 clang static analyzer 主要是进行语法分析，语义分析和生成中间代码，当然这个过程会对代码进行检查，出错的和需要警告的会标注出来。LLVM 核心库提供一个优化器，对流行的 CPU 做代码生成支持。lld 是 Clang / LLVM 的内置链接器，clang 必须调用链接器来产生可执行文件。\nLLVM 比较有特色的一点是它能提供一种代码编写良好的中间表示 IR，这意味着它可以作为多种语言的后端，这样就能够提供语言无关的优化同时还能够方便的针对多种 CPU 的代码生成。\nLLVM 还用在 Gallium3D 中进行 JIT 优化，Xorg 中的 pixman 也有考虑使用 LLVM 优化执行速度， LLVM-Lua 用LLVM 来编译 lua 代码， gpuocelot 使用 LLVM 可以让 CUDA 程序无需重新编译就能够在多种 CPU 机器上跑。\n这里是 Clang 官方详细文档： Welcome to Clang’s documentation! — Clang 4.0 documentation\n这篇是对 LLVM 架构的一个概述： The Architecture of Open Source Applications\n将编译器之前对于编译的前世今生也是需要了解的，比如回答下这个问题，编译器程序是用什么编译的？看看 《linkers and loaders》 这本书就知道了。\n编译流程 在列出完整步骤之前可以先看个简单例子。看看是如何完成一次编译的。\n#import \u0026lt;Foundation/Foundation.h\u0026gt; #define DEFINEEight 8 int main(){ @autoreleasepool { int eight = DEFINEEight; int six = 6; NSString* site = [[NSString alloc] initWithUTF8String:”starming”]; int rank = eight + six; NSLog(@“%@ rank %d”, site, rank); } return 0; } 在命令行输入\nclang -ccc-print-phases main.m 可以看到编译源文件需要的几个不同的阶段\n0: input, “main.m”, objective-c 1: preprocessor, {0}, objective-c-cpp-output 2: compiler, {1}, ir 3: backend, {2}, assembler 4: assembler, {3}, object 5: linker, {4}, image 6: bind-arch, “x86_64”, {5}, image 这样能够了解到过程和重要的信息。 查看oc的c实现可以使用如下命令\nclang -rewrite-objc main.m 查看操作内部命令，可以使用 -### 命令\nclang -### main.m -o main 想看清clang的全部过程，可以先通过-E查看clang在预编译处理这步做了什么。\nclang -E main.m 执行完后可以看到文件\n# 1 “/System/Library/Frameworks/Foundation.framework/Headers/FoundationLegacySwiftCompatibility.h” 1 3 # 185 “/System/Library/Frameworks/Foundation.framework/Headers/Foundation.h” 2 3 # 2 “main.m” 2 int main(){ @autoreleasepool { int eight = 8; int six = 6; NSString* site = [[NSString alloc] initWithUTF8String:”starming”]; int rank = eight + six; NSLog(@“%@ rank %d”, site, rank); } return 0; } 这个过程的处理包括宏的替换，头文件的导入。下面这些代码也会在这步处理。\n “#define” “#include” “#indef” 注释 “#pragma”  预处理完成后就会进行词法分析，这里会把代码切成一个个 Token，比如大小括号，等于号还有字符串等。\nclang -fmodules -fsyntax-only -Xclang -dump-tokens main.m 然后是语法分析，验证语法是否正确，然后将所有节点组成抽象语法树 AST 。\nclang -fmodules -fsyntax-only -Xclang -ast-dump main.m 完成这些步骤后就可以开始IR中间代码的生成了，CodeGen 会负责将语法树自顶向下遍历逐步翻译成 LLVM IR，IR 是编译过程的前端的输出后端的输入。\nclang -S -fobjc-arc -emit-llvm main.m -o main.ll 这里 LLVM 会去做些优化工作，在 Xcode 的编译设置里也可以设置优化级别-01，-03，-0s，还可以写些自己的 Pass，官方有比较完整的 Pass 教程： Writing an LLVM Pass — LLVM 5 documentation 。\nclang -O3 -S -fobjc-arc -emit-llvm main.m -o main.ll Pass 是 LLVM 优化工作的一个节点，一个节点做些事，一起加起来就构成了 LLVM 完整的优化和转化。\n如果开启了 bitcode 苹果会做进一步的优化，有新的后端架构还是可以用这份优化过的 bitcode 去生成。\nclang -emit-llvm -c main.m -o main.bc 生成汇编\nclang -S -fobjc-arc main.m -o main.s 生成目标文件\nclang -fmodules -c main.m -o main.o 生成可执行文件，这样就能够执行看到输出结果\nclang main.o -o main 执行 ./main 输出 starming rank 14 下面是完整步骤：\n 编译信息写入辅助文件，创建文件架构 .app 文件 处理文件打包信息 执行 CocoaPod 编译前脚本，checkPods Manifest.lock 编译.m文件，使用 CompileC 和 clang 命令 链接需要的 Framework 编译 xib 拷贝 xib ，资源文件 编译 ImageAssets 处理 info.plist 执行 CocoaPod 脚本 拷贝标准库 创建 .app 文件和签名  Clang 编译 .m 文件 在 Xcode 编译过后，可以通过 Show the report navigator 里对应 target 的 build 中查看每个 .m 文件的 clang 参数信息，这些参数都是通过Build Setting。\n具体拿编译 AFSecurityPolicy.m 的信息来看看。首先对任务进行描述。\nCompileC DerivedData path/AFSecurityPolicy.o AFNetworking/AFNetworking/AFSecurityPolicy.m normal x86_64 objective-c com.apple.compilers.llvm.clang.1_0.compiler 接下来对会更新工作路径，同时设置 PATH\ncd /Users/didi/Documents/Demo/GitHub/GCDFetchFeed/GCDFetchFeed/Pods export LANG=en_US.US-ASCII export PATH=“/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/usr/bin:/Applications/Xcode.app/Contents/Developer/usr/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin” 接下来就是实际的编译命令\nclang -x objective-c -arch x86_64 -fmessage-length=0 -fobjc-arc… -Wno-missing-field-initializers … -DDEBUG=1 … -isysroot iPhoneSimulator10.1.sdk -fasm-blocks … -I -F -c AFSecurityPolicy.m -o AFSecurityPolicy.o clang 命令参数\n-x 编译语言比如objective-c -arch 编译的架构，比如arm7 -f 以-f开头的。 -W 以-W开头的，可以通过这些定制编译警告 -D 以-D开头的，指的是预编译宏，通过这些宏可以实现条件编译 -iPhoneSimulator10.1.sdk 编译采用的iOS SDK版本 -I 把编译信息写入指定的辅助文件 -F 需要的Framework -c 标识符指明需要运行预处理器，语法分析，类型检查，LLVM生成优化以及汇编代码生成.o文件 -o 编译结果 构建 Target 编译工程中的第三方依赖库后会构建我们程序的 target，会按顺序输出如下的信息：\nCreate product structure Process product packaging Run custom shell script ‘Check Pods Manifest.lock’ Compile … 各个项目中的.m文件 Link /Users/… 路径 Copy … 静态文件 Compile asset catalogs Compile Storyboard file … Process info.plist Link Storyboards Run custom shell script ‘Embed Pods Frameworks’ Run custom shell script ‘Copy Pods Resources’ … Touch GCDFetchFeed.app Sign GCDFetchFeed.app 从这些信息可以看出在这些步骤中会分别调用不同的命令行工具来执行。\nTarget 在 Build 过程的控制 在 Xcode 的 Project editor 中的 Build Setting，Build Phases 和 Build Rules 能够控制编译的过程。\nBuild Phases 构建可执行文件的规则。指定 target 的依赖项目，在 target build 之前需要先 build 的依赖。在 Compile Source 中指定所有必须编译的文件，这些文件会根据 Build Setting 和 Build Rules 里的设置来处理。\n在 Link Binary With Libraries 里会列出所有的静态库和动态库，它们会和编译生成的目标文件进行链接。\nbuild phase 还会把静态资源拷贝到 bundle 里。\n可以通过在 build phases 里添加自定义脚本来做些事情，比如像 CocoaPods 所做的那样。\nBuild Rules 指定不同文件类型如何编译。每条 build rule 指定了该类型如何处理以及输出在哪。可以增加一条新规则对特定文件类型添加处理方法。\nBuild Settings 在 build 的过程中各个阶段的选项的设置。\npbxproj工程文件 build 过程控制的这些设置都会被保存在工程文件 .pbxproj 里。在这个文件中可以找 rootObject 的 ID 值\nrootObject = 3EE311301C4E1F0800103FA3 /* Project object */; 然后根据这个 ID 找到 main 工程的定义。\n/* Begin PBXProject section */ 3EE311301C4E1F0800103FA3 /* Project object */ = { isa = PBXProject; … /* End PBXProject section */ 在 targets 里会指向各个 taget 的定义\ntargets = ( 3EE311371C4E1F0800103FA3 /* GCDFetchFeed */, 3EE311501C4E1F0800103FA3 /* GCDFetchFeedTests */, 3EE3115B1C4E1F0800103FA3 /* GCDFetchFeedUITests */, ); 顺着这些 ID 就能够找到更详细的定义地方。比如我们通过 GCDFetchFeed 这个 target 的 ID 找到定义如下：\n3EE311371C4E1F0800103FA3 /* GCDFetchFeed */ = { isa = PBXNativeTarget; buildConfigurationList = 3EE311651C4E1F0800103FA3 /* configuration list for PBXNativeTarget “GCDFetchFeed” buildPhases = ( 9527AA01F4AAE11E18397E0C /* Check Pods st.lock */, 3EE311341C4E1F0800103FA3 /* Sources */, 3EE311351C4E1F0800103FA3 /* Frameworks */, 3EE311361C4E1F0800103FA3 /* Resources */, C3DDA7C46C0308459A18B7D9 /* Embed Pods Frameworks DD33A716222617FAB49F1472 /* Copy Pods Resources ); buildRules = ( ); dependencies = ( ); name = GCDFetchFeed; productName = GCDFetchFeed; productReference = 3EE311381C4E1F0800103FA3 /* chFeed.app */; productType = “com.apple.product-type.application”; }; 这个里面又有更多的 ID 可以得到更多的定义，其中 buildConfigurationList 指向了可用的配置项，包含 Debug 和 Release。可以看到还有 buildPhases，buildRules 和 dependencies 都能够通过这里索引找到更详细的定义。\n接下来详细的看看 Clang 所做的事情吧。\nClang Static Analyzer静态代码分析 可以在 llvm/clang/ Source Tree - Woboq Code Browser 上查看 Clang 的代码。\nYoutube上一个教程：The Clang AST - a Tutorial - YouTube CMU关于llvm的教案 https://www.cs.cmu.edu/afs/cs.cmu.edu/academic/class/15745-s14/public/lectures/\n静态分析前会对源代码分词成 Token，这个过程称为词法分析（Lexical Analysis），在 TokensKind.def 里有 Clang 定义的所有 Token。Token 可以分为以下几类\n 关键字：语法中的关键字，if else while for 等。 标识符：变量名 字面量：值，数字，字符串 特殊符号：加减乘除等符号  通过下面的命令可以输出所有 token 和所在文件具体位置\nclang -fmodules -E -Xclang -dump-tokens main.m 结果如下\nannot_module_include ‘#import \u0026lt;Fo’ Loc=\u0026lt;main.m:2:1\u0026gt; int ‘int’ [StartOfLine] Loc=\u0026lt;main.m:5:1\u0026gt; identifier ‘main’ [LeadingSpace] Loc=\u0026lt;main.m:5:5\u0026gt; l_paren ‘(‘ Loc=\u0026lt;main.m:5:9\u0026gt; r_paren ‘)’ Loc=\u0026lt;main.m:5:10\u0026gt; l_brace ‘{‘ [LeadingSpace] Loc=\u0026lt;main.m:5:12\u0026gt; at ‘@‘ [StartOfLine] [LeadingSpace] Loc=\u0026lt;main.m:6:5\u0026gt; identifier ‘autoreleasepool’ Loc=\u0026lt;main.m:6:6\u0026gt; l_brace ‘{‘ [LeadingSpace] Loc=\u0026lt;main.m:6:22\u0026gt; identifier ‘NSString’ [StartOfLine] [LeadingSpace] Loc=\u0026lt;main.m:7:9\u0026gt; star ‘*’ [LeadingSpace] Loc=\u0026lt;main.m:7:18\u0026gt; identifier ‘a’ Loc=\u0026lt;main.m:7:19\u0026gt; equal ‘=‘ [LeadingSpace] Loc=\u0026lt;main.m:7:21\u0026gt; at ‘@‘ [LeadingSpace] Loc=\u0026lt;main.m:7:23\u0026gt; string_literal ‘”aaa”’ Loc=\u0026lt;main.m:7:24\u0026gt; semi ‘;’ Loc=\u0026lt;main.m:7:29\u0026gt; identifier ‘NSLog’ [StartOfLine] [LeadingSpace] Loc=\u0026lt;main.m:8:9\u0026gt; l_paren ‘(‘ Loc=\u0026lt;main.m:8:14\u0026gt; at ‘@‘ Loc=\u0026lt;main.m:8:15\u0026gt; string_literal ‘”hi %@“’ Loc=\u0026lt;main.m:8:16\u0026gt; comma ‘,’ Loc=\u0026lt;main.m:8:23\u0026gt; identifier ‘a’ Loc=\u0026lt;main.m:8:24\u0026gt; r_paren ‘)’ Loc=\u0026lt;main.m:8:25\u0026gt; semi ‘;’ Loc=\u0026lt;main.m:8:26\u0026gt; r_brace ‘}’ [StartOfLine] [LeadingSpace] Loc=\u0026lt;main.m:9:5\u0026gt; return ‘return’ [StartOfLine] [LeadingSpace] Loc=\u0026lt;main.m:10:5\u0026gt; numeric_constant ‘0’ [LeadingSpace] Loc=\u0026lt;main.m:10:12\u0026gt; semi ‘;’ Loc=\u0026lt;main.m:10:13\u0026gt; r_brace ‘}’ [StartOfLine] Loc=\u0026lt;main.m:11:1\u0026gt; eof ‘’ Loc=\u0026lt;main.m:11:2\u0026gt; 可以获得每个 token 的类型，值还有类似 StartOfLine 的位置类型和 Loc=main.m:11:1 这个样的具体位置。\n接着进行语法分析（Semantic Analysis）将 token 先按照语法组合成语义生成 VarDecl 节点，然后将这些节点按照层级关系构成抽象语法树 Abstract Syntax Tree (AST)。\n打个比方，如果遇到 token 是 = 符号进行赋值的处理，遇到加减乘除就先处理乘除，然后处理加减，这些组合经过嵌套后会生成一个语法数的结构。这个过程完成后会进行赋值操作时类型是不是匹配的处理。\n打印语法树的命令\nclang -fmodules -fsyntax-only -Xclang -ast-dump main.m 输出结果\nTranslationUnitDecl 0x7fa80f018ad0 \u0026lt;\u0026lt;invalid sloc\u0026gt;\u0026gt; \u0026lt;invalid sloc\u0026gt; |-TypedefDecl 0x7fa80f018fc8 \u0026lt;\u0026lt;invalid sloc\u0026gt;\u0026gt; \u0026lt;invalid sloc\u0026gt; implicit __int128_t ‘__int128’ | `-BuiltinType 0x7fa80f018d20 ‘__int128’ |-TypedefDecl 0x7fa80f019028 \u0026lt;\u0026lt;invalid sloc\u0026gt;\u0026gt; \u0026lt;invalid sloc\u0026gt; implicit __uint128_t ‘unsigned __int128’ | `-BuiltinType 0x7fa80f018d40 ‘unsigned __int128’ |-TypedefDecl 0x7fa80f0190b8 \u0026lt;\u0026lt;invalid sloc\u0026gt;\u0026gt; \u0026lt;invalid sloc\u0026gt; implicit SEL ‘SEL *’ | `-PointerType 0x7fa80f019080 ‘SEL *’ | `-BuiltinType 0x7fa80f018f30 ‘SEL’ |-TypedefDecl 0x7fa80f019198 \u0026lt;\u0026lt;invalid sloc\u0026gt;\u0026gt; \u0026lt;invalid sloc\u0026gt; implicit id ‘id’ | `-ObjCObjectPointerType 0x7fa80f019140 ‘id’ imported | `-ObjCObjectType 0x7fa80f019110 ‘id’ imported |-TypedefDecl 0x7fa80f019278 \u0026lt;\u0026lt;invalid sloc\u0026gt;\u0026gt; \u0026lt;invalid sloc\u0026gt; implicit Class ‘Class’ | `-ObjCObjectPointerType 0x7fa80f019220 ‘Class’ | `-ObjCObjectType 0x7fa80f0191f0 ‘Class’ |-ObjCInterfaceDecl 0x7fa80f0192c8 \u0026lt;\u0026lt;invalid sloc\u0026gt;\u0026gt; \u0026lt;invalid sloc\u0026gt; implicit Protocol |-TypedefDecl 0x7fa80f019618 \u0026lt;\u0026lt;invalid sloc\u0026gt;\u0026gt; \u0026lt;invalid sloc\u0026gt; implicit __NSConstantString ‘struct __NSConstantString_tag’ | `-RecordType 0x7fa80f019430 ‘struct __NSConstantString_tag’ | `-Record 0x7fa80f019390 ‘__NSConstantString_tag’ |-TypedefDecl 0x7fa80f0196a8 \u0026lt;\u0026lt;invalid sloc\u0026gt;\u0026gt; \u0026lt;invalid sloc\u0026gt; implicit __builtin_ms_va_list ‘char *’ | `-PointerType 0x7fa80f019670 ‘char *’ | `-BuiltinType 0x7fa80f018b60 ‘char’ |-TypedefDecl 0x7fa80f047978 \u0026lt;\u0026lt;invalid sloc\u0026gt;\u0026gt; \u0026lt;invalid sloc\u0026gt; implicit __builtin_va_list ‘struct __va_list_tag [1]’ | `-ConstantArrayType 0x7fa80f047920 ‘struct __va_list_tag [1]’ 1 | `-RecordType 0x7fa80f0197a0 ‘struct __va_list_tag’ | `-Record 0x7fa80f0196f8 ‘__va_list_tag’ |-ImportDecl 0x7fa80f0486b0 \u0026lt;main.m:2:1\u0026gt; col:1 implicit Foundation |-FunctionDecl 0x7fa80f048738 \u0026lt;line:5:1, line:11:1\u0026gt; line:5:5 main ‘int ()’ | `-CompoundStmt 0x7fa80f393998 \u0026lt;col:12, line:11:1\u0026gt; | |-ObjCAutoreleasePoolStmt 0x7fa80f393950 \u0026lt;line:6:5, line:9:5\u0026gt; | | `-CompoundStmt 0x7fa80f393928 \u0026lt;line:6:22, line:9:5\u0026gt; | | |-DeclStmt 0x7fa80f3a3b38 \u0026lt;line:7:9, col:29\u0026gt; | | | `-VarDecl 0x7fa80f3a3580 \u0026lt;col:9, col:24\u0026gt; col:19 used a ‘NSString *’ cinit | | | `-ObjCStringLiteral 0x7fa80f3a3648 \u0026lt;col:23, col:24\u0026gt; ‘NSString *’ | | | `-StringLiteral 0x7fa80f3a3618 \u0026lt;col:24\u0026gt; ‘char [4]’ lvalue “aaa” | | `-CallExpr 0x7fa80f3938c0 \u0026lt;line:8:9, col:25\u0026gt; ‘void’ | | |-ImplicitCastExpr 0x7fa80f3938a8 \u0026lt;col:9\u0026gt; ‘void (*)(id, …)’ \u0026lt;FunctionToPointerDecay\u0026gt; | | | `-DeclRefExpr 0x7fa80f3a3b50 \u0026lt;col:9\u0026gt; ‘void (id, …)’ Function 0x7fa80f3a3670 ‘NSLog’ ‘void (id, …)’ | | |-ImplicitCastExpr 0x7fa80f3938f8 \u0026lt;col:15, col:16\u0026gt; ‘id’:’id’ \u0026lt;BitCast\u0026gt; | | | `-ObjCStringLiteral 0x7fa80f393800 \u0026lt;col:15, col:16\u0026gt; ‘NSString *’ | | | `-StringLiteral 0x7fa80f3a3bb8 \u0026lt;col:16\u0026gt; ‘char [6]’ lvalue “hi %@“ | | `-ImplicitCastExpr 0x7fa80f393910 \u0026lt;col:24\u0026gt; ‘NSString *’ \u0026lt;LValueToRValue\u0026gt; | | `-DeclRefExpr 0x7fa80f393820 \u0026lt;col:24\u0026gt; ‘NSString *’ lvalue Var 0x7fa80f3a3580 ‘a’ ‘NSString *’ | `-ReturnStmt 0x7fa80f393980 \u0026lt;line:10:5, col:12\u0026gt; | `-IntegerLiteral 0x7fa80f393960 \u0026lt;col:12\u0026gt; ‘int’ 0 `-\u0026lt;undeserialized declarations\u0026gt; TranslationUnitDecl 是根节点，表示一个源文件。Decl 表示一个声明，Expr 表示表达式，Literal 表示字面量是特殊的 Expr，Stmt 表示语句。\nclang 静态分析是通过建立分析引擎和 checkers 所组成的架构，这部分功能可以通过 clang —analyze 命令方式调用。clang static analyzer 分为 analyzer core 分析引擎和 checkers 两部分，所有 checker 都是基于底层分析引擎之上，通过分析引擎提供的功能能够编写新的 checker。\n可以通过 clang —analyze -Xclang -analyzer-checker-help 来列出当前 clang 版本下所有 checker。如果想编写自己的 checker，可以在 clang 项目的 lib / StaticAnalyzer / Checkers 目录下找到实例参考，比如 ObjCUnusedIVarsChecker.cpp 用来检查未使用定义过的变量。这种方式能够方便用户扩展对代码检查规则或者对 bug 类型进行扩展，但是这种架构也有不足，每执行完一条语句后，分析引擎会遍历所有 checker 中的回调函数，所以 checker 越多，速度越慢。通过 clang -cc1 -analyzer-checker-help 可以列出能调用的 checker，下面是常用 checker\ndebug.ConfigDumper Dump config table debug.DumpCFG Display Control-Flow Graphs debug.DumpCallGraph Display Call Graph debug.DumpCalls Print calls as they are traversed by the engine debug.DumpDominators Print the dominance tree for a given CFG debug.DumpLiveVars Print results of live variable analysis debug.DumpTraversal Print branch conditions as they are traversed by the engine debug.ExprInspection Check the analyzer's understanding of expressions debug.Stats Emit warnings with analyzer statistics debug.TaintTest Mark tainted symbols as such. debug.ViewCFG View Control-Flow Graphs using GraphViz debug.ViewCallGraph View Call Graph using GraphViz debug.ViewExplodedGraph View Exploded Graphs using GraphViz 这些 checker 里最常用的是 DumpCFG，DumpCallGraph，DumpLiveVars 和 DumpViewExplodedGraph。\nclang static analyzer 引擎大致分为 CFG，MemRegion，SValBuilder，ConstraintManager 和 ExplodedGraph 几个模块。clang static analyzer 本质上就是 path-sensitive analysis，要很好的理解 clang static analyzer 引擎就需要对 Data Flow Analysis 有所了解，包括迭代数据流分析，path-sensitive，path-insensitive ，flow-sensitive等。\n编译的概念（词法-\u0026gt;语法-\u0026gt;语义-\u0026gt;IR-\u0026gt;优化-\u0026gt;CodeGen）在 clang static analyzer 里到处可见，例如 Relaxed Live Variables Analysis 可以减少分析中的内存消耗，使用 mark-sweep 实现 Dead Symbols 的删除。\nclang static analyzer 提供了很多辅助方法，比如 SVal.dump()，MemRegion.getString 以及 Stmt 和 Dcel 提供的 dump 方法。Clang 抽象语法树 Clang AST 常见的 API 有 Stmt，Decl，Expr 和 QualType。在编写 checker 时会遇到 AST 的层级检查，这时有个很好的接口 StmtVisitor，这个接口类似 RecursiveASTVisitor。\n整个 clang static analyzer 的入口是 AnalysisConsumer，接着会调 HandleTranslationUnit() 方法进行 AST 层级进行分析或者进行 path-sensitive 分析。默认会按照 inline 的 path-sensitive 分析，构建 CallGraph，从顶层 caller 按照调用的关系来分析，具体是使用的 WorkList 算法，从 EntryBlock 开始一步步的模拟，这个过程叫做 intra-procedural analysis（IPA）。这个模拟过程还需要对内存进行模拟，clang static analyzer 的内存模型是基于《A Memory Model for Static Analysis of C Programs》这篇论文而来，pdf地址：https://lcs.ios.ac.cn/~xuzb/canalyze/memmodel.pdf 在clang里的具体实现代码可以查看这两个文件 MemRegion.h和 RegionStore.cpp 。\n下面举个简单例子看看 clang static analyzer 是如何对源码进行模拟的。\nint main() { int a; int b = 10; a = b; return a; } 对应的 AST 以及 CFG\n#————————AST————————— # clang -cc1 -ast-dump TranslationUnitDecl 0xc75b450 \u0026lt;\u0026lt;invalid sloc\u0026gt;\u0026gt; \u0026lt;invalid sloc\u0026gt; |-TypedefDecl 0xc75b740 \u0026lt;\u0026lt;invalid sloc\u0026gt;\u0026gt; \u0026lt;invalid sloc\u0026gt; implicit __builtin_va_list ‘char *’ `-FunctionDecl 0xc75b7b0 \u0026lt;test.cpp:1:1, line:7:1\u0026gt; line:1:5 main ‘int (void)’ `-CompoundStmt 0xc75b978 \u0026lt;line:2:1, line:7:1\u0026gt; |-DeclStmt 0xc75b870 \u0026lt;line:3:2, col:7\u0026gt; | `-VarDecl 0xc75b840 \u0026lt;col:2, col:6\u0026gt; col:6 used a ‘int’ |-DeclStmt 0xc75b8d8 \u0026lt;line:4:2, col:12\u0026gt; | `-VarDecl 0xc75b890 \u0026lt;col:2, col:10\u0026gt; col:6 used b ‘int’ cinit | `-IntegerLiteral 0xc75b8c0 \u0026lt;col:10\u0026gt; ‘int’ 10 \u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt; a = b \u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt; |-BinaryOperator 0xc75b928 \u0026lt;line:5:2, col:6\u0026gt; ‘int’ lvalue ‘=‘ | |-DeclRefExpr 0xc75b8e8 \u0026lt;col:2\u0026gt; ‘int’ lvalue Var 0xc75b840 ‘a’ ‘int’ | `-ImplicitCastExpr 0xc75b918 \u0026lt;col:6\u0026gt; ‘int’ \u0026lt;LValueToRValue\u0026gt; | `-DeclRefExpr 0xc75b900 \u0026lt;col:6\u0026gt; ‘int’ lvalue Var 0xc75b890 ‘b’ ‘int’ \u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt; `-ReturnStmt 0xc75b968 \u0026lt;line:6:2, col:9\u0026gt; `-ImplicitCastExpr 0xc75b958 \u0026lt;col:9\u0026gt; ‘int’ \u0026lt;LValueToRValue\u0026gt; `-DeclRefExpr 0xc75b940 \u0026lt;col:9\u0026gt; ‘int’ lvalue Var 0xc75b840 ‘a’ ‘int’ #————————CFG————————— # clang -cc1 -analyze -analyzer-checker=debug.DumpCFG int main() [B2 (ENTRY)] Succs (1): B1 [B1] 1: int a; 2: 10 3: int b = 10; 4: b 5: [B1.4] (ImplicitCastExpr, LValueToRValue, int) 6: a 7: [B1.6] = [B1.5] 8: a 9: [B1.8] (ImplicitCastExpr, LValueToRValue, int) 10: return [B1.9]; Preds (1): B2 Succs (1): B0 [B0 (EXIT)] Preds (1): B1 CFG 将程序拆得更细，能够将执行的过程表现的更直观些，为了避免路径爆炸，函数 inline 的条件会设置的比较严格，函数 CFG 块多时不会进行 inline 分析，模拟栈深度超过一定值不会进行 inline 分析，这个默认是5。\n在MRC使用的是CFG这样的执行路径模拟，ARC就没有了，举个例子，没有全部条件都返回，CFG就会报错，而AST就不会。\n官方 AST 相关文档\n https://clang.llvm.org/docs/Tooling.html https://clang.llvm.org/docs/IntroductionToTheClangAST.html https://clang.llvm.org/docs/RAVFrontendAction.html https://clang.llvm.org/docs/LibTooling.html https://clang.llvm.org/docs/LibASTMatchers.html  静态检查的一些库以及使用方法\n FauxPas_document_translation/README.md at master · DeveloperLx/FauxPas_document_translation · GitHub  CodeGen 生成 IR 代码 将语法树翻译成 LLVM IR 中间代码，做为 LLVM Backend 输入的桥接语言。这样做的好处在前言里也提到了，方便 LLVM Backend 给多语言做相同的优化，做到语言无关。\n这个过程中还会跟 runtime 桥接。\n 各种类，方法，成员变量等的结构体的生成，并将其放到对应的Mach-O的section中。 Non-Fragile ABI 合成 OBJC_IVAR_$_ 偏移值常量。 ObjCMessageExpr 翻译成相应版本的 objc_msgSend，super 翻译成 objc_msgSendSuper。 strong，weak，copy，atomic 合成 @property 自动实现 setter 和 getter。 @synthesize 的处理。 生成 block_layout 数据结构 __block 和 __weak _block_invoke ARC 处理，插入 objc_storeStrong 和 objc_storeWeak 等 ARC 代码。ObjCAutoreleasePoolStmt 转 objc_autorealeasePoolPush / Pop。自动添加 [super dealloc]。给每个 ivar 的类合成 .cxx_destructor 方法自动释放类的成员变量。  不管编译的语言时 Objective-C 还是 Swift 也不管对应机器是什么，亦或是即时编译，LLVM 里唯一不变的是中间语言 LLVM IR。那么我们就来看看如何玩 LLVM IR。\nIR 结构 下面是刚才生成的 main.ll 中间代码文件。\n; ModuleID = ‘main.c’ source_filename = “main.c” target datalayout = “e-m:o-i64:64-f80:128-n8:16:32:64-S128” target triple = “x86_64-apple-macosx10.12.0” @.str = private unnamed_addr constant [16 x i8] c”Please input a:\\00”, align 1 @.str.1 = private unnamed_addr constant [3 x i8] c”%d\\00”, align 1 @.str.2 = private unnamed_addr constant [16 x i8] c”Please input b:\\00”, align 1 @.str.3 = private unnamed_addr constant [32 x i8] c”a is:%d,b is :%d,count equal:%d\\00”, align 1 ; Function Attrs: nounwind ssp uwtable define i32 @main() #0 { %1 = alloca i32, align 4 %2 = alloca i32, align 4 %3 = bitcast i32* %1 to i8* call void @llvm.lifetime.start(i64 4, i8* %3) #3 %4 = bitcast i32* %2 to i8* call void @llvm.lifetime.start(i64 4, i8* %4) #3 %5 = tail call i32 (i8*, …) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str, i64 0, i64 0)) %6 = call i32 (i8*, …) @scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32* nonnull %1) %7 = call i32 (i8*, …) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.2, i64 0, i64 0)) %8 = call i32 (i8*, …) @scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32* nonnull %2) %9 = load i32, i32* %1, align 4, !tbaa !2 %10 = load i32, i32* %2, align 4, !tbaa !2 %11 = add nsw i32 %10, %9 %12 = call i32 (i8*, …) @printf(i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.3, i64 0, i64 0), i32 %9, i32 %10, i32 %11) call void @llvm.lifetime.end(i64 4, i8* %4) #3 call void @llvm.lifetime.end(i64 4, i8* %3) #3 ret i32 0 } ; Function Attrs: argmemonly nounwind declare void @llvm.lifetime.start(i64, i8* nocapture) #1 ; Function Attrs: nounwind declare i32 @printf(i8* nocapture readonly, …) #2 ; Function Attrs: nounwind declare i32 @scanf(i8* nocapture readonly, …) #2 ; Function Attrs: argmemonly nounwind declare void @llvm.lifetime.end(i64, i8* nocapture) #1 attributes #0 = { nounwind ssp uwtable “disable-tail-calls”=“false” “less-precise-fpmad”=“false” “no-frame-pointer-elim”=“true” “no-frame-pointer-elim-non-leaf” “no-infs-fp-math”=“false” “no-nans-fp-math”=“false” “stack-protector-buffer-size”=“8” “target-cpu”=“penryn” “target-features”=“+cx16,+fxsr,+mmx,+sse,+sse2,+sse3,+sse4.1,+ssse3” “unsafe-fp-math”=“false” “use-soft-float”=“false” } attributes #1 = { argmemonly nounwind } attributes #2 = { nounwind “disable-tail-calls”=“false” “less-precise-fpmad”=“false” “no-frame-pointer-elim”=“true” “no-frame-pointer-elim-non-leaf” “no-infs-fp-math”=“false” “no-nans-fp-math”=“false” “stack-protector-buffer-size”=“8” “target-cpu”=“penryn” “target-features”=“+cx16,+fxsr,+mmx,+sse,+sse2,+sse3,+sse4.1,+ssse3” “unsafe-fp-math”=“false” “use-soft-float”=“false” } attributes #3 = { nounwind } !llvm.module.flags = !{!0} !llvm.ident = !{!1} !0 = !{i32 1, !”PIC Level”, i32 2} !1 = !{!”Apple LLVM version 8.0.0 (clang-800.0.42.1)”} !2 = !{!3, !3, i64 0} !3 = !{!”int”, !4, i64 0} !4 = !{!”omnipotent char”, !5, i64 0} !5 = !{!”Simple C/C++ TBAA”} LLVM IR 有三种表示格式，第一种是 bitcode 这样的存储格式，以 .bc 做后缀，第二种是可读的以 .ll，第三种是用于开发时操作 LLVM IR 的内存格式。\n一个编译的单元即一个文件在 IR 里就是一个 Module，Module 里有 Global Variable 和 Function，在 Function里有 Basic Block，Basic Block 里有 指令 Instructions。 ‘\n通过下面的 IR 结构图能够更好的理解 IR 的整体结构。\n图中可以看出最大的是 Module，里面包含多个 Function，每个 Function 包含多个 BasicBlock，BasicBlock 里含有 Instruction，代码非常清晰，这样如果想开发一个新语言只需要完成语法解析后通过 LLVM 提供的丰富接口在内存中生成 IR 就可以直接运行在各个不同的平台。\nIR 语言满足静态单赋值，可以很好的降低数据流分析和控制流分析的复杂度。及只能在定义时赋值，后面不能更改。但是这样就没法写程序了，输入输出都没法弄，所以函数式编程才会有类似 Monad 这样机制的原因。\nLLVM IR 优化 使用 O2，O3 这样的优化会调用对应的 Pass 来进行处理，有比如类似死代码清理，内联化，表达式重组，循环变量移动这样的 Pass。可以通过 llvm-opt 调用 LLVM 优化相关的库。\n可能直接这么说不太直观，我们可以更改下原 c 代码举个小例子看看这些 Pass 会做哪些优化。当我们加上\nint i = 0; while (i \u0026lt; 10) { i++; printf(\u0026quot;%d\u0026quot;,i); } 对应的 IR 代码是\n %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32 1) %call4.1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32 2) %call4.2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32 3) %call4.3 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32 4) %call4.4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32 5) %call4.5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32 6) %call4.6 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32 7) %call4.7 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32 8) %call4.8 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32 9) %call4.9 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32 10) 可以看出来这个 while 在 IR 中就是重复的打印了10次，那要是我把10改成100是不是会变成打印100次呢？\n我们改成100后，再次生成 IR 可以看到 IR 变成了这样：\n br label %while.body while.body: ; preds = %while.body, %entry %i.010 = phi i32 [ 0, %entry ], [ %inc, %while.body ] %inc = add nuw nsw i32 %i.010, 1 %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32 %inc) %exitcond = icmp eq i32 %inc, 100 br i1 %exitcond, label %while.end, label %while.body while.end: ; preds = %while.body %2 = load i32, i32* %a, align 4, !tbaa !2 %3 = load i32, i32* %b, align 4, !tbaa !2 %add = add nsw i32 %3, %2 %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.3, i64 0, i64 0), i32 %add) call void @llvm.lifetime.end(i64 4, i8* nonnull %1) #3 call void @llvm.lifetime.end(i64 4, i8* nonnull %0) #3 ret i32 0 } 这里对不同条件生成的不同都是 Pass 优化器做的事情。解读上面这段 IR 需要先了解下 IR 语法关键字，如下：\n @ - 代表全局变量 % - 代表局部变量 alloca - 指令在当前执行的函数的堆栈帧中分配内存，当该函数返回到其调用者时，将自动释放内存。 i32：- i 是几这个整数就会占几位，i32就是32位4字节 align - 对齐，比如一个 int,一个 char 和一个 int。单个 int 占4个字节，为了对齐只占一个字节的 char需要向4对齐占用4字节空间。 Load - 读出，store 写入 icmp - 两个整数值比较，返回布尔值 br - 选择分支，根据 cond 来转向 label，不根据条件跳转的话类似 goto indirectbr - 根据条件间接跳转到一个 label，而这个 label 一般是在一个数组里，所以跳转目标是可变的，由运行时决定的 label - 代码标签  br label %while.body 如上面表述，br 会选择跳向 while.body 定义的这个标签。这个标签里可以看到\n%exitcond = icmp eq i32 %inc, 100 br i1 %exitcond, label %while.end, label %while.body 这段，icmp 会比较当前的 %inc 和定义的临界值 100，根据返回的布尔值来决定 br 跳转到那个代码标签，真就跳转到 while.end 标签，否就在进入 while.body 标签。这就是 while 的逻辑。通过br 跳转和 label 这种标签的概念使得 IR 语言能够成为更低级兼容性更高更方便转向更低级语言的语言。\nSSA LLVM IR 是 SSA 形式的，维护双向 def-use 信息，use-def 是通过普通指针实现信息维护，def-use 是通过内存跳表和链表来实现的，便于 forward dataflow analysis 和 backward dataflow analysis。可以通过 ADCE 这个 Pass 来了解下 backward dataflow，这个pass 的源文件在 lib/Transforms/Scalar/ADCE.cpp 中，ADCE 实现了 Aggressive Dead Code Elimination Pass。这个 Pass 乐观地假设所有 instructions 都是 Dead 直到证明是否定的，允许它消除其他 DCE Pass 的 Dead 计算 catch，特别是涉及循环计算。其它 DCE 相关的 Pass 可以查看同级目录下的 BDCE.cpp 和 DCE.cpp，目录下其它的 Pass 都是和数据流相关的分析包含了各种分析算法和思路。\n那么看看加法这个操作的相关的 IR 代码\n%2 = load i32, i32* %a, align 4, !tbaa !2 %3 = load i32, i32* %b, align 4, !tbaa !2 %add = add nsw i32 %3, %2 加法对应的指令是\nBinaryOperator::CreateAdd(Value *V1, Value *V2, const Twine \u0026amp;Name) 两个输入 V1 和 V2 的 def-use 是如何的呢，看看如下代码\nclass Value { void addUse(Use \u0026amp;U) { U.addToList(\u0026amp;UseList); } // ... }; class Use { Value *Val; Use *Next; PointerIntPair\u0026lt;Use **, 2, PrevPtrTag\u0026gt; Prev; // ... }; void Use::set(Value *V) { if (Val) removeFromList(); Val = V; if (V) V-\u0026gt;addUse(*this); } Value *Use::operator=(Value *RHS) { set(RHS); return RHS; } class User : public Value { template \u0026lt;int Idx, typename U\u0026gt; static Use \u0026amp;OpFrom(const U *that) { return Idx \u0026lt; 0 ? OperandTraits\u0026lt;U\u0026gt;::op_end(const_cast\u0026lt;U*\u0026gt;(that))[Idx] : OperandTraits\u0026lt;U\u0026gt;::op_begin(const_cast\u0026lt;U*\u0026gt;(that))[Idx]; } template \u0026lt;int Idx\u0026gt; Use \u0026amp;Op() { return OpFrom\u0026lt;Idx\u0026gt;(this); } template \u0026lt;int Idx\u0026gt; const Use \u0026amp;Op() const { return OpFrom\u0026lt;Idx\u0026gt;(this); } // ... }; class Instruction : public User, public ilist_node_with_parent\u0026lt;Instruction, BasicBlock\u0026gt; { // ... }; class BinaryOperator : public Instruction { /// Construct a binary instruction, given the opcode and the two /// operands. Optionally (if InstBefore is specified) insert the instruction /// into a BasicBlock right before the specified instruction. The specified /// Instruction is allowed to be a dereferenced end iterator. /// static BinaryOperator *Create(BinaryOps Op, Value *S1, Value *S2, const Twine \u0026amp;Name = Twine(), Instruction *InsertBefore = nullptr); // ... }; BinaryOperator::BinaryOperator(BinaryOps iType, Value *S1, Value *S2, Type *Ty, const Twine \u0026amp;Name, Instruction *InsertBefore) : Instruction(Ty, iType, OperandTraits\u0026lt;BinaryOperator\u0026gt;::op_begin(this), OperandTraits\u0026lt;BinaryOperator\u0026gt;::operands(this), InsertBefore) { Op\u0026lt;0\u0026gt;() = S1; Op\u0026lt;1\u0026gt;() = S2; init(iType); setName(Name); } BinaryOperator *BinaryOperator::Create(BinaryOps Op, Value *S1, Value *S2, const Twine \u0026amp;Name, Instruction *InsertBefore) { assert(S1-\u0026gt;getType() == S2-\u0026gt;getType() \u0026amp;\u0026amp; \u0026quot;Cannot create binary operator with two operands of differing type!\u0026quot;); return new BinaryOperator(Op, S1, S2, S1-\u0026gt;getType(), Name, InsertBefore); } 从代码里可以看出是使用了 Use 对象来把 use 和 def 联系起来的。\nLLVM IR 通过 mem2reg 这个 Pass 来把局部变量成 SSA 形式。这个 Pass 的代码在 lib/Transforms/Utils/Mem2Reg.cpp 里。LLVM通过 mem2reg Pass 能够识别 alloca 模式，将其设置 SSA value。这时就不在需要 alloca，load和store了。mem2reg 是对 PromoteMemToReg 函数调用的一个简单包装，真正的算法实现是在 PromoteMemToReg 函数里，这个函数在 lib/Transforms/Utils/PromoteMemoryToRegister.cpp 这个文件里。\n这个算法会使 alloca 这个仅仅作为 load 和 stores 的用途的指令使用迭代 dominator 边界转换成 PHI 节点，然后通过使用深度优先函数排序重写 loads 和 stores。这种算法叫做 iterated dominance frontier算法，具体实现方法可以参看 PromoteMemToReg 函数的实现。\n当然把多个字节码 .bc 合成一个文件，链接时还会优化，IR 结构在优化后会有变化，这样还能够在变化后的 IR 的结构上再进行更多的优化。\n这里可以进行 lli 解释执行 LLVM IR。\nllc 编译器是专门编译 LLVM IR 的编译器用来生成汇编文件。\n调用系统汇编器比如 GNU 的 as 来编译生成 .o Object 文件，接下来就是用链接器链接相关库和 .o 文件一起生成可执行的 .out 或者 exe 文件了。\nllvm-mc 还可以直接生成 object 文件。\nClang CFE 动手玩肯定不能少了 Clang 的前端组件及库，熟悉这些库以后就能够自己动手用这些库编写自己的程序了。下面我就对这些库做些介绍，然后再着重说说 libclang 库，以及如何用它来写工具。\n LLVM Support Library - LLVM libSupport 库提供了许多底层库和数据结构，包括命令行 option 处理，各种容器和系统抽象层，用于文件系统访问。 The Clang “Basic” Library - 提供了跟踪和操纵 source buffers，source buffers 的位置，diagnostics，tokens,抽象目标以及编译语言子集信息的 low-level 实用程序。还有部分可以用在其他的非 c 语言比如 SourceLocation，SourceManager，Diagnositics，FileManager 等。其中 Diagnositics 这个子系统是编译器和普通写代码人交流的主要组成部分，它会诊断当前代码哪些不正确，按照严重程度而产生 WARNING 或 ERROR，每个诊断会有唯一 ID ， SourceLocation 会负责管理。 The Driver Library - 和 Driver 相关的库，上面已经对其做了详细的介绍。 Precompiled Headers - Clang 支持预编译 headers 的两个实现。 The Frontend Library - 这个库里包含了在 Clang 库之上构建的功能，比如输出 diagnositics 的几种方法。 The Lexer and Preprocessor Library - 词法分析和预处理的库，包含了 Token，Annotation Tokens，TokenLexer，Lexer 等词法类，还有 Parser Library 和 AST 语法树相关的比如 Type，ASTContext，QualType，DeclarationName，DeclContext 以及 CFG 类。 The Sema Library - 解析器调用此库时，会对输入进行语义分析。 对于有效的程序，Sema 为解析构造一个 AST。 The CodeGen Library - CodeGen 用 AST 作为输入，并从中生成 LLVM IR 代码。  libclang libclang 会让你觉得 clang 不仅仅只是一个伟大的编译器。下面从解析源码来说下\n先写个 libclang 的程序来解析源码\nint main(int argc, char *argv[]) { CXIndex Index = clang_createIndex(0, 0); CXTranslationUnit TU = clang_parseTranslationUnit(Index, 0, argv, argc, 0, 0, CXTranslationUnit_None); for (unsigned I = 0, N = clang_getNumDiagnostics(TU); I != N; ++I) { CXDiagnostic Diag = clang_getDiagnostic(TU, I); CXString String = clang_formatDiagnostic(Diag,clang_defaultDiagnosticDisplayOptions()); fprintf(stderr, \u0026quot;%s\\n\u0026quot;, clang_getCString(String)); clang_disposeString(String); } clang_disposeTranslationUnit(TU); clang_disposeIndex(Index); return 0; } 再写个有问题的 c 程序\nstruct List { /**/ };int sum(union List *L) { /* ... */ } 运行了语法检查后会出现提示信息\n1 2 3 4 5 6 7 8  list.c:2:9: error: use of \u0026#39;List\u0026#39; with tag type that does not match previous declaration int sum(union List *Node) { ^~~~~ struct list.c:1:8: note: previous use is here struct List { ^   下面我们看看诊断过程，显示几个核心诊断方法诊断出问题\n enum CXDiagnosticSeverity clang_getDiagnosticSeverity(CXDiagnostic Diag); CXSourceLocation clang_getDiagnosticLocation(CXDiagnostic Diag); CXString clang_getDiagnosticSpelling(CXDiagnostic Diag);  接着进行高亮显示，最后提供两个提示修复的方法\n unsigned clang_getDiagnosticNumFixIts(CXDiagnostic Diag);* CXString clang_getDiagnosticFixIt(CXDiagnostic Diag, unsigned FixIt,CXSourceRange *ReplacementRange);  我们先遍历语法树的节点。源 c 程序如下\nstruct List { int Data; struct List *Next; }; int sum(struct List *Node) { int result = 0; for (; Node; Node = Node-\u0026gt;Next) result = result + Node-\u0026gt;Data; return result; } 先找出所有的声明，比如 List，Data，Next，sum，Node 以及 result 等。再找出引用，比如 struct List *Next 里的 List。还有声明和表达式，比如 int result = 0; 还有 for 语句等。还有宏定义和实例化等。\nCXCursor 会统一 AST 的节点，规范包含的信息\n 代码所在位置和长度 名字和符号解析 类型 子节点  举个 CXCursor 分析例子\nstruct List { int Data; struct List *Next; }; CXCursor 的处理过程如下\n//Top-level cursor C clang_getCursorKind(C) == CXCursor_StructDecl clang_getCursorSpelling(C) == \u0026quot;List\u0026quot; //获取名字字符串 clang_getCursorLocation(C) //位置 clang_getCursorExtent(C) //长度 clang_visitChildren(C, ...); //访问子节点 //Reference cursor R clang_getCursorKind(R) == CXCursor_TypeRef clang_getCursorSpelling(R) == \u0026quot;List\u0026quot; clang_getCursorLocation(R) clang_getCursorExtent(R) clang_getCursorReferenced(R) == C //指向C Driver 动手玩的话，特别是想要使用这些工具链之前最好先了解我们和 LLVM 交互的实现。那么这部分就介绍下 LLVM 里的 Driver。\nDriver 是 Clang 面对用户的接口，用来解析 Option 设置，判断决定调用的工具链，最终完成整个编译过程。\n相关源代码在这里：clang/tools/driver/driver.cpp\n整个 Driver 源码的入口函数就是 driver.cpp 里的 main() 函数。从这里可以作为入口看看整个 driver 是如何工作的，这样更利于我们以后轻松动手驾驭 LLVM。\nint main(int argc_, const char **argv_) { llvm::sys::PrintStackTraceOnErrorSignal(argv_[0]); llvm::PrettyStackTraceProgram X(argc_, argv_); llvm::llvm_shutdown_obj Y; // Call llvm_shutdown() on exit. if (llvm::sys::Process::FixupStandardFileDescriptors()) return 1; SmallVector\u0026lt;const char *, 256\u0026gt; argv; llvm::SpecificBumpPtrAllocator\u0026lt;char\u0026gt; ArgAllocator; std::error_code EC = llvm::sys::Process::GetArgumentVector( argv, llvm::makeArrayRef(argv_, argc_), ArgAllocator); if (EC) { llvm::errs() \u0026lt;\u0026lt; \u0026quot;error: couldn't get arguments: \u0026quot; \u0026lt;\u0026lt; EC.message() \u0026lt;\u0026lt; '\\n'; return 1; } llvm::InitializeAllTargets(); std::string ProgName = argv[0]; std::pair\u0026lt;std::string, std::string\u0026gt; TargetAndMode = ToolChain::getTargetAndModeFromProgramName(ProgName); llvm::BumpPtrAllocator A; llvm::StringSaver Saver(A); //省略 ... // If we have multiple failing commands, we return the result of the first // failing command. return Res; } Driver 的工作流程图 在 driver.cpp 的 main 函数里有 Driver 的初始化。我们来看看和 driver 相关的代码\n Driver TheDriver(Path, llvm::sys::getDefaultTargetTriple(), Diags); SetInstallDir(argv, TheDriver, CanonicalPrefixes); insertTargetAndModeArgs(TargetAndMode.first, TargetAndMode.second, argv, SavedStrings); SetBackdoorDriverOutputsFromEnvVars(TheDriver); std::unique_ptr\u0026lt;Compilation\u0026gt; C(TheDriver.BuildCompilation(argv)); int Res = 0; SmallVector\u0026lt;std::pair\u0026lt;int, const Command *\u0026gt;, 4\u0026gt; FailingCommands; if (C.get()) Res = TheDriver.ExecuteCompilation(*C, FailingCommands); // Force a crash to test the diagnostics. if (::getenv(\u0026quot;FORCE_CLANG_DIAGNOSTICS_CRASH\u0026quot;)) { Diags.Report(diag::err_drv_force_crash) \u0026lt;\u0026lt; \u0026quot;FORCE_CLANG_DIAGNOSTICS_CRASH\u0026quot;; // Pretend that every command failed. FailingCommands.clear(); for (const auto \u0026amp;J : C-\u0026gt;getJobs()) if (const Command *C = dyn_cast\u0026lt;Command\u0026gt;(\u0026amp;J)) FailingCommands.push_back(std::make_pair(-1, C)); } for (const auto \u0026amp;P : FailingCommands) { int CommandRes = P.first; const Command *FailingCommand = P.second; if (!Res) Res = CommandRes; // If result status is \u0026lt; 0, then the driver command signalled an error. // If result status is 70, then the driver command reported a fatal error. // On Windows, abort will return an exit code of 3. In these cases, // generate additional diagnostic information if possible. bool DiagnoseCrash = CommandRes \u0026lt; 0 || CommandRes == 70; #ifdef LLVM_ON_WIN32 DiagnoseCrash |= CommandRes == 3; #endif if (DiagnoseCrash) { TheDriver.generateCompilationDiagnostics(*C, *FailingCommand); break; } } 可以看到初始化 Driver 后 driver 会调用 BuildCompilation 生成 Compilation。Compilation 字面意思是合集的意思，通过 driver.cpp 的 include 可以看到\n#include \u0026quot;clang/Driver/Compilation.h\u0026quot; 根据此路径可以细看下 Compilation 这个为了 driver 设置的一组任务的类。通过这个类我们提取里面这个阶段比较关键的几个信息出来\nclass Compilation { /// The original (untranslated) input argument list. llvm::opt::InputArgList *Args; /// The driver translated arguments. Note that toolchains may perform their /// own argument translation. llvm::opt::DerivedArgList *TranslatedArgs; /// The driver we were created by. const Driver \u0026amp;TheDriver; /// The default tool chain. const ToolChain \u0026amp;DefaultToolChain; ... /// The list of actions. This is maintained and modified by consumers, via /// getActions(). ActionList Actions; /// The root list of jobs. JobList Jobs; ... public: ... const Driver \u0026amp;getDriver() const { return TheDriver; } const ToolChain \u0026amp;getDefaultToolChain() const { return DefaultToolChain; } ... ActionList \u0026amp;getActions() { return Actions; } const ActionList \u0026amp;getActions() const { return Actions; } ... JobList \u0026amp;getJobs() { return Jobs; } const JobList \u0026amp;getJobs() const { return Jobs; } void addCommand(std::unique_ptr\u0026lt;Command\u0026gt; C) { Jobs.addJob(std::move(C)); } ... /// ExecuteCommand - Execute an actual command. /// /// \\param FailingCommand - For non-zero results, this will be set to the /// Command which failed, if any. /// \\return The result code of the subprocess. int ExecuteCommand(const Command \u0026amp;C, const Command *\u0026amp;FailingCommand) const; /// ExecuteJob - Execute a single job. /// /// \\param FailingCommands - For non-zero results, this will be a vector of /// failing commands and their associated result code. void ExecuteJobs( const JobList \u0026amp;Jobs, SmallVectorImpl\u0026lt;std::pair\u0026lt;int, const Command *\u0026gt;\u0026gt; \u0026amp;FailingCommands) const; ... }; 通过这些关键定义再结合 BuildCompilation 函数的实现可以看出这个 Driver 的流程是按照 ArgList - Actions - Jobs 来的，完整的图如下：\nParse 看完完整的 Driver 流程后，我们就先从 Parse 开始说起。\nParse 是解析选项，对应的代码在 ParseArgStrings 这个函数里。\n下面通过执行一个试试，比如 clang -### main.c -ITheOptionWeAdd\n这里的 -I 是 Clang 支持的，在 Clang 里是 Option 类，Clang 会对这些 Option 专门的进行解析，使用一种 DSL 语言将其转成 .tb 文件后使用 table-gen 转成 C++ 语言和其它代码一起进行编译。\nDriver 层会解析我们传入的 -I Option 参数。\n-x 后加个 c 表示是对 c 语言进行编译，Clang Driver 通过文件的后缀 .c 来自动加上这个 参数的。如果是 c++ 语言，仅仅通过在 -x 后添加 cpp 编译还是会出错的。\nclang -x c++ main.cpp 通过报错信息可以看出一些链接错误\n因为需要链接 C++ 标准库，所以加上参数 -lc++ 就可以了\nclang -x c++ -lc++ main.cpp 那么 clang++ 和 clang 命令的区别就在于会加载 C++ 库，其实 clang++ 最终还是会调用 Clang，那么手动指定加载库就好了何必还要多个 clang++ 命令呢，这主要是为了能够在这个命令里去加载更多的库，除了标准库以外，还有些非 C++ 标准库，辅助库等等。这样只要是 C++ 的程序用 clang++ 够了。\n只有加上 -cc1 这个 option 才能进入到 Clang driver 比如 emit-obj 这个 option 就需要先加上 -cc1。\n这点可以通过 driver.cpp 源码来看，在 main() 函数里可以看到在做了些多平台的兼容处理后就开始进行对入参判断第一个是不是 -cc1。\nif (MarkEOLs \u0026amp;\u0026amp; argv.size() \u0026gt; 1 \u0026amp;\u0026amp; StringRef(argv[1]).startswith(\u0026quot;-cc1\u0026quot;)) MarkEOLs = false; llvm:🆑:ExpandResponseFiles(Saver, Tokenizer, argv, MarkEOLs); // 处理 -cc1 集成工具 auto FirstArg = std::find_if(argv.begin() + 1, argv.end(), [](const char *A) { return A != nullptr; }); if (FirstArg != argv.end() \u0026amp;\u0026amp; StringRef(*FirstArg).startswith(\u0026quot;-cc1\u0026quot;)) { // 如果 -cc1 来自 response file, 移除 EOL sentinels if (MarkEOLs) { auto newEnd = std::remove(argv.begin(), argv.end(), nullptr); argv.resize(newEnd - argv.begin()); } return ExecuteCC1Tool(argv, argv[1] + 4); } 如果是 -cc1 的话会调用 ExecuteCC1Tool 这个函数，先看看这个函数\nstatic int ExecuteCC1Tool(ArrayRef\u0026lt;const char *\u0026gt; argv, StringRef Tool) { void *GetExecutablePathVP = (void *)(intptr_t) GetExecutablePath; if (Tool == \u0026quot;\u0026quot;) return cc1_main(argv.slice(2), argv[0], GetExecutablePathVP); if (Tool == \u0026quot;as\u0026quot;) return cc1as_main(argv.slice(2), argv[0], GetExecutablePathVP); // 拒绝未知工具 llvm::errs() \u0026lt;\u0026lt; \u0026quot;error: unknown integrated tool '\u0026quot; \u0026lt;\u0026lt; Tool \u0026lt;\u0026lt; \u0026quot;'\\n\u0026quot;; return 1; } 最终的执行会执行 cc1-main 或者 cc1as_main 。这两个函数分别在 driver.cpp 同级目录里的 cc1_main.cpp 和 cc1as_main.cpp 中。\n下面看看有哪些解析 Args 的方法\n ParseAnalyzerArgs - 解析出静态分析器 option ParseMigratorArgs - 解析 Migrator option ParseDependencyOutputArgs - 解析依赖输出 option ParseCommentArgs - 解析注释 option ParseFileSystemArgs - 解析文件系统 option ParseFrontendArgs - 解析前端 option ParseTargetArgs - 解析目标 option ParseCodeGenArgs - 解析 CodeGen 相关的 option ParseHeaderSearchArgs - 解析 HeaderSearch 对象相关初始化相关的 option parseSanitizerKinds - 解析 Sanitizer Kinds ParsePreprocessorArgs - 解析预处理的 option ParsePreprocessorOutputArgs - 解析预处理输出的 option  Pipeline Pipeline 这里可以添加 -ccc-print-phases 看到进入 Pipeline 以后的事情。\n这些如 -ccc-print-phases 这样的 option 在编译时会生成.inc 这样的 C++ TableGen 文件。在 Options.td 可以看到全部的 option 定义。\n在 Clang 的 Pipeline 中很多实际行为都有对应的 Action，比如 preprocessor 时提供文件的 InputAction 和用于绑定机器架构的 BindArchAction。\n使用 clang main.c -arch i386 -arch x86_64 -o main 然后 file main 能够看到这时 BindArchAction 这个 Action 起到了作用，编译链接了两次同时创建了一个库既能够支持32位也能够支持64位用 lipo 打包。\nAction /// BuildActions - Construct the list of actions to perform for the /// given arguments, which are only done for a single architecture. /// /// \\param C - The compilation that is being built. /// \\param Args - The input arguments. /// \\param Actions - The list to store the resulting actions onto. void BuildActions(Compilation \u0026amp;C, llvm::opt::DerivedArgList \u0026amp;Args, const InputList \u0026amp;Inputs, ActionList \u0026amp;Actions) const; /// BuildUniversalActions - Construct the list of actions to perform /// for the given arguments, which may require a universal build. /// /// \\param C - The compilation that is being built. /// \\param TC - The default host tool chain. void BuildUniversalActions(Compilation \u0026amp;C, const ToolChain \u0026amp;TC, const InputList \u0026amp;BAInputs) const; 上面两个方法中 BuildUniversalActions 最后也会走 BuildActions。BuildActions 了，进入这个方法\nvoid Driver::BuildActions(Compilation \u0026amp;C, DerivedArgList \u0026amp;Args, const InputList \u0026amp;Inputs, ActionList \u0026amp;Actions) const { llvm::PrettyStackTraceString CrashInfo(\u0026quot;Building compilation actions\u0026quot;); if (!SuppressMissingInputWarning \u0026amp;\u0026amp; Inputs.empty()) { Diag(clang::diag::err_drv_no_input_files); return; } Arg *FinalPhaseArg; phases::ID FinalPhase = getFinalPhase(Args, \u0026amp;FinalPhaseArg); 接着跟 getFinalPhase 这个方法。\n// -{E,EP,P,M,MM} only run the preprocessor. if (CCCIsCPP() || (PhaseArg = DAL.getLastArg(options::OPT_E)) || (PhaseArg = DAL.getLastArg(options::OPT__SLASH_EP)) || (PhaseArg = DAL.getLastArg(options::OPT_M, options::OPT_MM)) || (PhaseArg = DAL.getLastArg(options::OPT__SLASH_P))) { FinalPhase = phases::Preprocess; // -{fsyntax-only,-analyze,emit-ast} only run up to the compiler. } else if ((PhaseArg = DAL.getLastArg(options::OPT_fsyntax_only)) || (PhaseArg = DAL.getLastArg(options::OPT_module_file_info)) || (PhaseArg = DAL.getLastArg(options::OPT_verify_pch)) || (PhaseArg = DAL.getLastArg(options::OPT_rewrite_objc)) || (PhaseArg = DAL.getLastArg(options::OPT_rewrite_legacy_objc)) || (PhaseArg = DAL.getLastArg(options::OPT__migrate)) || (PhaseArg = DAL.getLastArg(options::OPT__analyze, options::OPT__analyze_auto)) || (PhaseArg = DAL.getLastArg(options::OPT_emit_ast))) { FinalPhase = phases::Compile; // -S only runs up to the backend. } else if ((PhaseArg = DAL.getLastArg(options::OPT_S))) { FinalPhase = phases::Backend; // -c compilation only runs up to the assembler. } else if ((PhaseArg = DAL.getLastArg(options::OPT_c))) { FinalPhase = phases::Assemble; // Otherwise do everything. } else FinalPhase = phases::Link; 看完这段代码就会发现其实每次的 option 都会完整的走一遍从预处理，静态分析，backend 再到汇编的过程。\n下面列下一些编译器的前端 Action，大家可以一个个用着玩。\n InitOnlyAction - 只做前端初始化，编译器 option 是 -init-only PreprocessOnlyAction - 只做预处理，不输出，编译器的 option 是 -Eonly PrintPreprocessedAction - 做预处理，子选项还包括-P、-C、-dM、-dD 具体可以查看PreprocessorOutputOptions 这个类，编译器 option 是 -E RewriteIncludesAction - 预处理 DumpTokensAction - 打印token，option 是 -dump-tokens DumpRawTokensAction - 输出原始tokens，包括空格符，option 是 -dump-raw-tokens RewriteMacrosAction - 处理并扩展宏定义，对应的 option 是 -rewrite-macros HTMLPrintAction - 生成高亮的代码网页，对应的 option 是 -emit-html DeclContextPrintAction - 打印声明，option 对应的是 -print-decl-contexts ASTDeclListAction - 打印 AST 节点，option 是 -ast-list ASTDumpAction - 打印 AST 详细信息，对应 option 是 -ast-dump ASTViewAction - 生成 AST dot 文件，能够通过 Graphviz 来查看图形语法树。 option 是 -ast-view AnalysisAction - 运行静态分析引擎，option 是 -analyze EmitLLVMAction - 生成可读的 IR 中间语言文件，对应的 option 是 -emit-llvm EmitBCAction - 生成 IR Bitcode 文件，option 是 -emit-llvm-bc MigrateSourceAction - 代码迁移，option 是 -migrate  Bind Bind 主要是与工具链 ToolChain 交互 根据创建的那些 Action，在 Action 执行时 Bind 来提供使用哪些工具，比如生成汇编时是使用内嵌的还是 GNU 的，还是其它的呢，这个就是由 Bind 来决定的，具体使用的工具有各个架构，平台，系统的 ToolChain 来决定。\n通过 clang -ccc-print-bindings main.c -o main 来看看 Bind 的结果\n可以看到编译选择的是 clang，链接选择的是 darwin::Linker，但是在链接时前没有汇编器的过程，这个就是 Bind 起了作用，它会根据不同的平台来决定选择什么工具，因为是在 Mac 系统里 Bind 就会决定使用 integrated-as 这个内置汇编器。那么如何在不用内置汇编器呢。可以使用 -fno-integrated-as 这个 option。\nTranslate Translate 就是把相关的参数对应到不同平台上不同的工具。\nJobs 从创建 Jobs 的方法\n/// BuildJobsForAction - Construct the jobs to perform for the action \\p A and /// return an InputInfo for the result of running \\p A. Will only construct /// jobs for a given (Action, ToolChain, BoundArch, DeviceKind) tuple once. InputInfo BuildJobsForAction(Compilation \u0026amp;C, const Action *A, const ToolChain *TC, StringRef BoundArch, bool AtTopLevel, bool MultipleArchs, const char *LinkingOutput, std::map\u0026lt;std::pair\u0026lt;const Action *, std::string\u0026gt;, InputInfo\u0026gt; \u0026amp;CachedResults, Action::OffloadKind TargetDeviceOffloadKind) const; 可以看出 Jobs 需要前面的 Compilation，Action，ToolChain 等，那么 Jobs 就是将前面获取的信息进行组合分组给后面的 Execute 做万全准备。\nExecute 在 driver.cpp 的 main 函数里的 ExecuteCompilation 方法里可以看到如下代码：\n // Set up response file names for each command, if necessary for (auto \u0026amp;Job : C.getJobs()) setUpResponseFiles(C, Job); C.ExecuteJobs(C.getJobs(), FailingCommands); 能够看到 Jobs 准备好了后就要开始 Excute 他们。\nExecute 就是执行整个的编译过程的 Jobs。过程执行的内容和耗时可以通过添加 -ftime-report 这个 option 来看到。\nClang Attributes 以 attribute(xx) 的语法格式出现，是 Clang 提供的一些能够让开发者在编译过程中参与一些源码控制的方法。下面列一些会用到的用法：\nattribute((format(NSString, F, A))) 格式化字符串 可以查看 NSLog 的用法\nFOUNDATION_EXPORT void NSLog(NSString *format, …) NS_FORMAT_FUNCTION(1,2) NS_NO_TAIL_CALL; // Marks APIs which format strings by taking a format string and optional varargs as arguments #if !defined(NS_FORMAT_FUNCTION) #if (__GNUC__*10+__GNUC_MINOR__ \u0026gt;= 42) \u0026amp;\u0026amp; (TARGET_OS_MAC || TARGET_OS_EMBEDDED) #define NS_FORMAT_FUNCTION(F,A) __attribute__((format(__NSString__, F, A))) #else #define NS_FORMAT_FUNCTION(F,A) #endif #endif attribute((deprecated(s))) 版本弃用提示 在编译过程中能够提示开发者该方法或者属性已经被弃用\n- (void)preMethod:( NSString *)string __attribute__((deprecated(“preMethod已经被弃用，请使用newMethod”))); - (void)deprecatedMethod DEPRECATED_ATTRIBUTE; //也可以直接使用DEPRECATED_ATTRIBUTE这个系统定义的宏 attribute((availability(os,introduced=m,deprecated=n, obsoleted=o,message=“” VA_ARGS))) 指明使用版本范围 os 指系统的版本，m 指明引入的版本，n 指明过时的版本，o 指完全不用的版本，message 可以写入些描述信息。\n- (void)method __attribute__((availability(ios,introduced=3_0,deprecated=6_0,obsoleted=7_0,message=“iOS3到iOS7版本可用，iOS7不能用”))); attribute((unavailable(…))) 方法不可用提示 这个会在编译过程中告知方法不可用，如果使用了还会让编译失败。\nattribute((unused)) 没有被使用也不报警告\nattribute((warn_unused_result)) 不使用方法的返回值就会警告，目前 swift3 已经支持该特性了。oc中也可以通过定义这个attribute来支持。\nattribute((availability(swift, unavailable, message=_msg))) OC 的方法不能在 Swift 中使用。\nattribute((cleanup(…))) 作用域结束时自动执行一个指定方法 作用域结束包括大括号结束，return，goto，break，exception 等情况。这个动作是先于这个对象的 dealloc 调用的。\nReactive Cocoa 中有个比较好的使用范例，@onExit 这个宏，定义如下：\n#define onExit \\ rac_keywordify \\ __strong rac_cleanupBlock_t metamacro_concat(rac_exitBlock_, __LINE__) __attribute__((cleanup(rac_executeCleanupBlock), unused)) = ^ static inline void rac_executeCleanupBlock (__strong rac_cleanupBlock_t *block) { (*block)(); } 这样可以在就可以很方便的把需要成对出现的代码写在一起了。同样可以在 Reactive Cocoa 看到其使用\nif (property != NULL) { rac_propertyAttributes *attributes = rac_copyPropertyAttributes(property); if (attributes != NULL) { @onExit { free(attributes); }; BOOL isObject = attributes-\u0026gt;objectClass != nil || strstr(attributes-\u0026gt;type, @encode(id)) == attributes-\u0026gt;type; BOOL isProtocol = attributes-\u0026gt;objectClass == NSClassFromString(@“Protocol”); BOOL isBlock = strcmp(attributes-\u0026gt;type, @encode(void(^)())) == 0; BOOL isWeak = attributes-\u0026gt;weak; shouldAddDeallocObserver = isObject \u0026amp;\u0026amp; isWeak \u0026amp;\u0026amp; !isBlock \u0026amp;\u0026amp; !isProtocol; } } 可以看出 attributes 的设置和释放都在一起使得代码的可读性得到了提高。\nattribute((overloadable)) 方法重载 能够在 c 的函数上实现方法重载。即同样的函数名函数能够对不同参数在编译时能够自动根据参数来选择定义的函数\n__attribute__((overloadable)) void printArgument(int number){ NSLog(@“Add Int %i”, number); } __attribute__((overloadable)) void printArgument(NSString *number){ NSLog(@“Add NSString %@“, number); } __attribute__((overloadable)) void printArgument(NSNumber *number){ NSLog(@“Add NSNumber %@“, number); } attribute((objc_designated_initializer)) 指定内部实现的初始化方法  如果是 objc_designated_initializer 初始化的方法必须调用覆盖实现 super 的 objc_designated_initializer 方法。 如果不是 objc_designated_initializer 的初始化方法，但是该类有 objc_designated_initializer 的初始化方法，那么必须调用该类的 objc_designated_initializer 方法或者非 objc_designated_initializer 方法，而不能够调用 super 的任何初始化方法。  attribute((objc_subclassing_restricted)) 指定不能有子类 相当于 Java 里的 final 关键字，如果有子类继承就会出错。\nattribute((objc_requires_super)) 子类继承必须调用 super 声明后子类在继承这个方法时必须要调用 super，否则会出现编译警告，这个可以定义一些必要执行的方法在 super 里提醒使用者这个方法的内容时必要的。\nattribute((const)) 重复调用相同数值参数优化返回 用于数值类型参数的函数，多次调用相同的数值型参数，返回是相同的，只在第一次是需要进行运算，后面只返回第一次的结果，这时编译器的一种优化处理方式。\nattribute((constructor(PRIORITY))) 和 attribute((destructor(PRIORITY))) PRIORITY 是指执行的优先级，main 函数执行之前会执行 constructor，main 函数执行后会执行 destructor，+load 会比 constructor 执行的更早点，因为动态链接器加载 Mach-O 文件时会先加载每个类，需要 +load 调用，然后才会调用所有的 constructor 方法。\n通过这个特性，可以做些比较好玩的事情，比如说类已经 load 完了，是不是可以在 constructor 中对想替换的类进行替换，而不用加在特定类的 +load 方法里。\nClang 警告处理 先看看这个\n#pragma clang diagnostic push #pragma clang diagnostic ignored “-Wdeprecated-declarations” sizeLabel = [self sizeWithFont:font constrainedToSize:size lineBreakMode:NSLineBreakByWordWrapping]; #pragma clang diagnostic pop 如果没有#pragma clang 这些定义，会报出 sizeWithFont 的方法会被废弃的警告，这个加上这个方法当然是为了兼容老系统，加上 ignored “-Wdeprecated-declarations” 的作用是忽略这个警告。通过 clang diagnostic push/pop 可以灵活的控制代码块的编译选项。\n使用 libclang 来进行语法分析 使用 libclang 里面提供的方法对源文件进行语法分析，分析语法树，遍历语法树上每个节点。\n使用这个库可以直接使用 C 的 API，官方也提供了 python binding。还有开源的 node-js / ruby binding，还有 Objective-C的开源库 GitHub - macmade/ClangKit: ClangKit provides an Objective-C frontend to LibClang. Source tokenization, diagnostics and fix-its are actually implemented. 。\n写个 python 脚本来调用 clang\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  pip install clang #!/usr/bin/python # vim: set fileencoding=utf-8 import clang.cindex import asciitree import sys def node_children(node): return (c for c in node.get_children() if c.location.file == sys.argv[1]) def print_node(node): text = node.spelling or node.displayname kind = str(node.kind)[str(node.kind).index(‘.’)+1:] return ‘{} {}’.format(kind, text) if len(sys.argv) != 2: print(“Usage: dump_ast.py [header file name]”) sys.exit() clang.cindex.Config.set_library_file(‘/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/libclang.dylib’) index = clang.cindex.Index.create() translation_unit = index.parse(sys.argv[1], [‘-x’, ‘objective-c’]) print asciitree.draw_tree(translation_unit.cursor, lambda n: list(n.get_children()), lambda n: “%s (%s)” % (n.spelling or n.displayname, str(n.kind).split(“.”)[1]))   基于语法树的分析还可以针对字符串做加密。\nLibTooling 对语法树完全的控制 因为 LibTooling 能够完全控制语法树，那么可以做的事情就非常多了。\n 可以改变 clang 生成代码的方式。 增加更强的类型检查。 按照自己的定义进行代码的检查分析。 对源码做任意类型分析，甚至重写程序。 给 clang 添加一些自定义的分析，创建自己的重构器。 基于现有代码做出大量的修改。 基于工程生成相关图形或文档。 检查命名是否规范，还能够进行语言的转换，比如把 OC 语言转成JS或者 Swift 。  官方有个文档开发者可以按照这个里面的说明去构造 LLVM，clang 和其工具： Tutorial for building tools using LibTooling and LibASTMatchers — Clang 4.0 documentation\n按照说明编译完成后进入 LLVM 的目录 ~/llvm/tools/clang/tools/ 在这了可以创建自己的 clang 工具。这里有个范例： GitHub - objcio/issue-6-compiler-tool: Example code for a standalone clang/llvm tool. 可以直接 make 成一个二进制文件。\n下面是检查 target 对象中是否有对应的 action 方法存在检查的一个例子\n@interface Observer + (instancetype)observerWithTarget:(id)target action:(SEL)selector; @end //查找消息表达式，observer 作为接受者，observerWithTarget:action: 作为 selector，检查 target 中是否存在相应的方法。 virtual bool VisitObjCMessageExpr(ObjCMessageExpr *E) { if (E-\u0026gt;getReceiverKind() == ObjCMessageExpr::Class) { QualType ReceiverType = E-\u0026gt;getClassReceiver(); Selector Sel = E-\u0026gt;getSelector(); string TypeName = ReceiverType.getAsString(); string SelName = Sel.getAsString(); if (TypeName == “Observer” \u0026amp;\u0026amp; SelName == “observerWithTarget:action:”) { Expr *Receiver = E-\u0026gt;getArg(0)-\u0026gt;IgnoreParenCasts(); ObjCSelectorExpr* SelExpr = cast\u0026lt;ObjCSelectorExpr\u0026gt;(E-\u0026gt;getArg(1)-\u0026gt;IgnoreParenCasts()); Selector Sel = SelExpr-\u0026gt;getSelector(); if (const ObjCObjectPointerType *OT = Receiver-\u0026gt;getType()-\u0026gt;getAs\u0026lt;ObjCObjectPointerType\u0026gt;()) { ObjCInterfaceDecl *decl = OT-\u0026gt;getInterfaceDecl(); if (! decl-\u0026gt;lookupInstanceMethod(Sel)) { errs() \u0026lt;\u0026lt; “Warning: class “ \u0026lt;\u0026lt; TypeName \u0026lt;\u0026lt; “ does not implement selector “ \u0026lt;\u0026lt; Sel.getAsString() \u0026lt;\u0026lt; “\\n”; SourceLocation Loc = E-\u0026gt;getExprLoc(); PresumedLoc PLoc = astContext-\u0026gt;getSourceManager().getPresumedLoc(Loc); errs() \u0026lt;\u0026lt; “in “ \u0026lt;\u0026lt; PLoc.getFilename() \u0026lt;\u0026lt; “ \u0026lt;“ \u0026lt;\u0026lt; PLoc.getLine() \u0026lt;\u0026lt; “:” \u0026lt;\u0026lt; PLoc.getColumn() \u0026lt;\u0026lt; “\u0026gt;\\n”; } } } } return true; } Clang Plugin 通过自己写个插件，比如上面写的 LibTooling 的 clang 工具，可以将这个插件动态的加载到编译器中，对编译进行控制，可以在 LLVM 的这个目录下查看一些范例 llvm/tools/clang/tools\n动态化方案 DynamicCocoa 中就是使用了一个将 OC 源码转 JS 的插件来进行代码的转换，这里整理了些利用 clang 转 js 的库 clangtojs资源 - Lmsgsendnilself ，JSPatch 是直接手写 JS 而没有转换的过程，所以也就没有多出这一步，而鹅厂的OCS更猛，直接在端内写了个编译器。在 C 函数的调用上孙源有个 slides 可以看看： Calling Conventions in Cocoa by sunnyxx bang 也有篇文章： 如何动态调用 C 函数 « bang’s blog 。\n这三个方案作者都分别写了文章详细说明其实现方案。\n JSPatch实现原理详解 « bang’s blog DynamicCocoa：滴滴 iOS 动态化方案的诞生与起航 OCS——史上最疯狂的iOS动态化方案 - 简书  滴滴的王康在做瘦身时也实现了一个自定义的 clang 插件，具体自定义插件的实现可以查看他的这文章 《基于clang插件的一种iOS包大小瘦身方案》\n那么我们要自己动手做应该怎么入门呢，除了本身带的范例外还有些教程可以看看。\n 官方 clang 的插件： External Clang Examples 收集一些如何使用 clang 库的例子：GitHub - loarabia/Clang-tutorial: A collection of code samples showing usage of clang and llvm as a library 在 Xcode 中添加 clang 静态分析自定义 checks： Running the analyzer within Xcode 将 LLVM C 的 API 用 swift 来包装： GitHub - harlanhaskins/LLVMSwift: A Swifty wrapper for the LLVM C API version 3.9.1  LLVM Backend 首先通过下图看看 LLVM Backend 在整个 LLVM 里所处的位置：\n接下来是整个 LLVM Backend 的流程图，后面会对每个过程详细说明\nCodeGen 阶段  Instruction Selection 指令选择：将IR转化成目标平台指令组成的定向非循环图 DAG（Directed Acyclic Graph） Scheduling and Formation 调度与排序：读取 DAG，将 DAG 的指令排成 MachineInstr 的队列 SSA 优化：多个基于 SSA（Static Single Assignment） 的 Pass 组成。比如 modulo-scheduling 和 peephole optimization 都是在这个阶段完成的 Register allocation 寄存器分配：将 Virtual Register 映射到 Physical Register 或内存上 Prolog / Epilog 生成 确定所需堆栈大小：Machine Code 晚期优化：最后一次优化机会 Code Emission：输出代码，可以选择汇编或者二进制机器码。  SelectionDAG  构建最初的 DAG：把 IR 里的 add 指令转成 SelectionDAG 的 add 节点 优化构建好的 DAG：把一些平台支持的 meta instructions 比如 Rotates，div / rem 指令识别出 Legalization SelectionDAG 类型：比如某些平台只有64位浮点和32位整数运算指令，那么就需要把所有 f32 都提升到 f64，i1/i8/i16 都提升到 i32，同时还要把 i64 拆分成两个 i32 来存储，操作符的合法化，比如 SDIV 在 x86 上回转成 SDIVREM。这个过程结果可以通过 llc -view-dag-combine2-dags sum.ll 看到 指令选择 instruction selector（ISel）：将平台无关的 DAG 通过 TableGen 读入 .tb 文件并且生成对应的模式匹配代码从而转成平台相关的 DAG SelectionDAG Scheduling and Formation：因为 CPU 是没法执行 DAG，所以需要将指令从 DAG 中提取依据一定规则比如 minimal register pressure 或隐藏指令延迟重排成指令队列。（DAG -\u0026gt; linear list（SSA form） -\u0026gt; MachineInstr -\u0026gt; MC Layer API MCInst MCStreamr -\u0026gt; MCCodeEmitter -\u0026gt; Binary Instr）  下图是 llc -view-isel-dags 状态下的 DAG 图：\n查看 DAG 不同状态的说明如下：\n -view-dag-combine1-dags：可以显示没有被优化的 DAG -view-legalize-dags：合法化之前的 DAG -view-dag-cmobine2-dags：第二次优化前 -view-isel-dags：显示指令选择前的 DAG -view-sched-dags：在 Scheduler 之前 ISel 之后 -view-sunit-dags：可以显示 Scheduler 的依赖图  Register Allocation 寄存器分配 寄存器在 LLVM 中的表达 物理寄存器在 LLVM 里均有 1 - 1023 范围内的编号。在 GenRegisterNames.inc 里找到，比如 lib/Target/X86/X86GenRegisterInfo.inc\n虚拟寄存器到物理寄存器的映射 直接映射使用 TargetRegisterInfo 和 MachineOperand 中的 API。间接映射的API用 VirtRegMap 以正确插入读写指令实现内存调度\nLLVM 自带的寄存器分配算法 llc -regalloc=Greedy add.bc -o ln.s\n Fast - debug 默认，尽可能保存寄存器。 Basic - 增量分配 Greedy - LLVM 默认寄存器分配算法，对 Basic 算法变量生存期进行分裂进行高度优化 PBQP - 将寄存器分配描述成分区布尔二次规划  Code Emission 下图详细表达了整个 Code Emission 的过程 Swift 编译流 Swift 编译流和 Clang 一样都是编译前端，和 Clang 一样代码会被解析成语法数 AST，接下来会比 Clang 多一步，通过 SILGen 生成 SIL 这一次方便做些 Swift 特定的优化，SIL 会被传递给 IR 生成阶段生成 LLVM IR，最后由 LLVM 解决余下事情。看到这里大家肯定会好奇 swift 是如何与 C 和 OC 交互的比如系统底层的模块，这里就要提提 swift 的模块映射了（Module map），它调用 Clang 的模块，将其传入 Clang importer 中生成 AST 来分析是的 swift 能够和 C/OC 进行交互。\n下面通过一个例子看详细了解下 Swift 编译流吧。先创建一个 toy.swift\n1  print(“hi!”)   生成程序\nswiftc toy.swift ./toy 生成检查 AST\nswiftc -dump-ast toy.swift 可以还原之前函数名\nswiftc -emit-silgen toy.swift | xcrun swift-demangle llvm ir 和汇编的生成\nswiftc -emit-ir toy.swift swiftc -emit-assembly toy.swift 生成可执行的脚本\nxcrun -sdk macosx swiftc toy.swift -o toy 编译后生成的二进制内容 Link Map File 在 Build Settings 里设置 Write Link Map File 为 Yes 后每次编译都会在指定目录生成这样一个文件。文件内容包含 Object files，Sections，Symbols。下面分别说说这些内容\nObject files 这个部分的内容都是 .m 文件编译后的 .o 和需要 link 的 .a 文件。前面是文件编号，后面是文件路径。\nSections 这里描述的是每个 Section 在可执行文件中的位置和大小。每个 Section 的 Segment 的类型分为 __TEXT 代码段和 __DATA 数据段两种。\nSymbols Symbols 是对 Sections 进行了再划分。这里会描述所有的 methods，ivar 和字符串，及它们对应的地址，大小，文件编号信息。\n每次编译后生成的 dSYM 文件 在每次编译后都会生成一个 dSYM 文件，程序在执行中通过地址来调用方法函数，而 dSYM 文件里存储了函数地址映射，这样调用栈里的地址可以通过 dSYM 这个映射表能够获得具体函数的位置。一般都会用来处理 crash 时获取到的调用栈 .crash 文件将其符号化。\n可以通过 Xcode 进行符号化，将 .crash 文件，.dSYM 和 .app 文件放到同一个目录下，打开 Xcode 的 Window 菜单下的 organizer，再点击 Device tab，最后选中左边的 Device Logs。选择 import 将 .crash 文件导入就可以看到 crash 的详细 log 了。\n还可以通过命令行工具 symbolicatecrash 来手动符号化 crash log。同样先将 .crash 文件，.dSYM 和 .app 文件放到同一个目录下，然后输入下面的命令\nexport DEVELOPER_DIR=/Applications/Xcode.app/Contents/Developer symbolicatecrash appName.crash appName.app \u0026gt; appName.log Mach-O 文件 记录编译后的可执行文件，对象代码，共享库，动态加载代码和内存转储的文件格式。不同于 xml 这样的文件，它只是二进制字节流，里面有不同的包含元信息的数据块，比如字节顺序，cpu 类型，块大小等。文件内容是不可以修改的，因为在 .app 目录中有个 _CodeSignature 的目录，里面包含了程序代码的签名，这个签名的作用就是保证签名后 .app 里的文件，包括资源文件，Mach-O 文件都不能够更改。\nMach-O 文件包含三个区域\n Mach-O Header：包含字节顺序，magic，cpu 类型，加载指令的数量等 Load Commands：包含很多内容的表，包括区域的位置，符号表，动态符号表等。每个加载指令包含一个元信息，比如指令类型，名称，在二进制中的位置等。 Data：最大的部分，包含了代码，数据，比如符号表，动态符号表等。  Mach-O 文件的解析 再通过一个例子来分析下： 这次用 xcrun 来\nxcrun clang -v 先创建一个test.c的文件\ntouch test.c 编辑里面的内容\nvi test.c #include \u0026lt;stdio.h\u0026gt; int main(int argc, char *argv[]) { printf(\u0026quot;hi there!\\n\u0026quot;); return 0; } 编译运行，没有起名默认为 a.out\nxcrun clang test.c ./a.out a.out 就是编译生成的二进制文件，下面看看这个二进制文件时如何生成的把。先看看输出的汇编代码\nxcrun clang -S -o - test.c | open -f 输出的结果里 . 开头的行是汇编指令不是汇编代码，其它的都是汇编代码。先看看前几行\n.section __TEXT,__text,regular,pure_instructions .macosx_version_min 10, 12 .globl _main .align 4, 0x90 .section 指令指定接下来执行哪一个段。\n.globl 指令说明 _main 是一个外部符号，因为 main() 函数对于系统来说是需要调用它来运行执行文件的。\n.align 指出后面代码的对齐方式，16(2^4) 字节对齐， 0x90 补齐。\n看看接下来的 main 函数头部部分\n_main: ## @main .cfi_startproc ## BB#0: pushq %rbp Ltmp0: .cfi_def_cfa_offset 16 Ltmp1: .cfi_offset %rbp, -16 movq %rsp, %rbp Ltmp2: .cfi_def_cfa_register %rbp subq $32, %rsp _main 是函数开始的地址，二进制文件会有这个位置的引用。\n.cfi_startproc 这个指令用于函数的开始，CFI 是 Call Frame Infomation 的缩写是调用帧信息的意思，在用 debugger 时实际上就是 stepping in / out 的一个调用帧。当出现 .cfi_endproc 时表示匹对结束标记出 main() 函数结束。\npushq %rbp 是汇编代码，## BB#0: 这个 label 里的。ABI 会让 rbp 这个寄存器的被保护起来，当函数调用返回时让 rbp 寄存器的值跟以前一样。 ABI 是 application binary interface 的缩写表示应用二进制接口，它指定了函数调用是如何在汇编代码层面上工作的。pushq %rbp 将 rbp 的值 push 到栈中。\n.cfi_def_cfa_offset 16 和 .cfi_offset %rbp, -16 会输出一些堆栈和调试信息，确保调试器要使用这些信息时能够找到。\nmovq %rsp, %rbp 把局部变量放到栈上。\nsubq $32, %rsp 会将栈指针移动 32 个字节，就是函数调用的位置。旧的栈指针存在 rbp 里作为局部变量的基址，再更新堆栈指针到会使用的位置。\n再看看 printf()\nleaq L_.str(%rip), %rax movl $0, -4(%rbp) movl %edi, -8(%rbp) movq %rsi, -16(%rbp) movq %rax, %rdi movb $0, %al callq _printf leap 会将 L_.str 这个指针加载到 rax 寄存器里。可以看看 L_.str 的定义\nL_.str: ## @.str .asciz \u0026quot;hi there\\n\u0026quot; 这个就是我们代码文件里定义的那个字符串。\n这里可以看到函数的两个参数分别保存在 edi 和 rsi 寄存器里，根据函数地址做了不同的偏移。\n当然也可以看出在这个汇编代码还有能够优化的地方，因为这两个值并没有用，却还是被寄存器存储了。\nprintf() 是个可变参数的函数，按照 ABI 调用约定存储参数的寄存器数量存储在寄存器 al 中，可变所以数量设置为0，callq 会调用 printf() 函数。\n接下来看看返回和函数的结束\nxorl %ecx, %ecx movl %eax, -20(%rbp) ## 4-byte Spill movl %ecx, %eax addq $32, %rsp popq %rbp retq .cfi_endproc xorl %ecx, %ecx 相当于将 ecx 寄存器设置为0。ABI 约定 eax 寄存器用来保存函数返回值，拷贝 ecx 到 eax 中，这样 main() 返回值就是0。\n函数执行完会恢复堆栈指针，前面是 subq 32 是把 rsp 下移32字节，addq 就是上移归位。然后把 rbp 的值从栈里 pop 出来。ret 会读取出栈返回的地址，.cfi_endproc 和 .cfi_startproc 配对标记结束。\n接下来是字符串输出\n .section __TEXT,__cstring,cstring_literals L_.str: ## @.str .asciz \u0026quot;hi there\\n\u0026quot; .subsections_via_symbols 同样 .section 指出进入一个新的段。最后 .subsections_via_symbols 是静态链接器用的。\n接下来通过 size 工具来看看 a.out 里的 section。\nxcrun size -x -l -m a.out Segment __PAGEZERO: 0x100000000 (vmaddr 0x0 fileoff 0) Segment __TEXT: 0x1000 (vmaddr 0x100000000 fileoff 0) Section __text: 0x34 (addr 0x100000f50 offset 3920) Section __stubs: 0x6 (addr 0x100000f84 offset 3972) Section __stub_helper: 0x1a (addr 0x100000f8c offset 3980) Section __cstring: 0xa (addr 0x100000fa6 offset 4006) Section __unwind_info: 0x48 (addr 0x100000fb0 offset 4016) total 0xa6 Segment __DATA: 0x1000 (vmaddr 0x100001000 fileoff 4096) Section __nl_symbol_ptr: 0x10 (addr 0x100001000 offset 4096) Section __la_symbol_ptr: 0x8 (addr 0x100001010 offset 4112) total 0x18 Segment __LINKEDIT: 0x1000 (vmaddr 0x100002000 fileoff 8192) total 0x100003000 可以看出有四个 segment 和多个section。\n在运行时，虚拟内存会把 segment 映射到进程的地址空间，虚拟内存会避免将全部执行文件全部加载到内存。\n__PAGEZERO segment 的大小是 4GB，不是文件真实大小，是规定进程地址空间前 4GB 被映射为不可执行，不可写和不可读。\n__TEXT segment 包含被执行的代码以只读和可执行的方式映射。\n __text section 包含编译后的机器码。 __stubs 和 __stub_helper 是给动态链接器 dyld 使用，可以允许延迟链接。 __cstring 可执行文件中的字符串。 __const 不可变的常量。  __DATA segment 以可读写和不可执行的方式映射，里面是会被更改的数据。\n __nl_symbol_ptr 非延迟指针。可执行文件加载同时加载。 __la_symbol_ptr 延迟符号指针。延迟用于可执行文件中调用未定义的函数，可执行文件里没有包含的函数会延迟加载。 __const 需要重定向的常量，例如 char * const c = “foo”; c指针指向可变的数据。 __bss 不用初始化的静态变量，例如 static int i; ANSI C 标准规定静态变量必须设置为0。运行时静态变量的值是可修改的。 __common 包含外部全局变量。例如在函数外定义 int i; __dyld 是section占位符，用于动态链接器。  更多 section 类型介绍可以查看苹果文档： OS X Assembler Reference\n接下来用 otool 查看下 section 里的内容：\nxcrun otool -s __TEXT __text a.out a.out: Contents of (__TEXT,__text) section 0000000100000f50 55 48 89 e5 48 83 ec 20 48 8d 05 47 00 00 00 c7 0000000100000f60 45 fc 00 00 00 00 89 7d f8 48 89 75 f0 48 89 c7 0000000100000f70 b0 00 e8 0d 00 00 00 31 c9 89 45 ec 89 c8 48 83 0000000100000f80 c4 20 5d c3 这个返回的内容很难读，加个 - v 就可以查看反汇编代码了， -s __TEXT __text 有个缩写 -t\nxcrun otool -v -t a.out a.out: (__TEXT,__text) section _main: 0000000100000f50 pushq %rbp 0000000100000f51 movq %rsp, %rbp 0000000100000f54 subq $0x20, %rsp 0000000100000f58 leaq 0x47(%rip), %rax 0000000100000f5f movl $0x0, -0x4(%rbp) 0000000100000f66 movl %edi, -0x8(%rbp) 0000000100000f69 movq %rsi, -0x10(%rbp) 0000000100000f6d movq %rax, %rdi 0000000100000f70 movb $0x0, %al 0000000100000f72 callq 0x100000f84 0000000100000f77 xorl %ecx, %ecx 0000000100000f79 movl %eax, -0x14(%rbp) 0000000100000f7c movl %ecx, %eax 0000000100000f7e addq $0x20, %rsp 0000000100000f82 popq %rbp 0000000100000f83 retq 看起来是不是很熟悉，和前面的编译时差不多，不同的就是没有汇编指令。\n现在来看看可执行文件。\n通过 otool 来看看可执行文件头部， 通过 -h 可以打印出头部信息：\notool -v -h a.out Mach header magic cputype cpusubtype caps filetype ncmds sizeofcmds flags MH_MAGIC_64 X86_64 ALL LIB64 EXECUTE 15 1200 NOUNDEFS DYLDLINK TWOLEVEL PIE mach_header 结构体\nstruct mach_header { uint32_t magic; cpu_type_t cputype; cpu_subtype_t cpusubtype; uint32_t filetype; uint32_t ncmds; uint32_t sizeofcmds; uint32_t flags; }; cputype 和 cpusubtype 规定可执行文件可以在哪些目标架构运行。ncmds 和 sizeofcmds 是加载命令。通过 -l 可以查看加载命令\notool -v -l a.out | open -f 加载命令结构体\nstruct segment_command { uint32_t cmd; uint32_t cmdsize; char segname[16]; uint32_t vmaddr; uint32_t vmsize; uint32_t fileoff; uint32_t filesize; vm_prot_t maxprot; vm_prot_t initprot; uint32_t nsects; uint32_t flags; }; 查看 Load command 1 这个部分可以找到 initprot r-x ，表示只读和可执行。\n在加载命令里还是看看 __TEXT __text 的section的内容\nSection sectname __text segname __TEXT addr 0x0000000100000f50 size 0x0000000000000034 offset 3920 align 2^4 (16) reloff 0 nreloc 0 type S_REGULAR attributes PURE_INSTRUCTIONS SOME_INSTRUCTIONS reserved1 0 reserved2 0 addr 的值表示代码的位置地址，在上面反汇编的代码里可以看到地址是一样的，offset 表示在文件中的偏移量。\n单个文件的就这样了，但是工程都是多个源文件的，那么多个文件是怎么合成一个可执行文件的呢？那么建多个文件来看看先。 Foo.h\n#import \u0026lt;Foundation/Foundation.h\u0026gt; @interface Foo : NSObject - (void)say; @end Foo.m\n#import “Foo.h” @implementation Foo - (void)say { NSLog(@“hi there again!\\n”); } @end SayHi.m\n#import “Foo.h” int main(int argc, char *argv[]) { @autoreleasepool { Foo *foo = [[Foo alloc] init]; [foo say]; return 0; } } 先编译多个文件\nxcrun clang -c Foo.m xcrun clang -c SayHi.m 再将编译后的文件链接起来，这样就可以生成 a.out 可执行文件了。\nxcrun clang SayHi.o Foo.o -Wl,`xcrun —show-sdk-path`/System/Library/Frameworks/Foundation.framework/Foundation 逆向 Mach-O 文件 需要先安装 tweak，安装越狱可以通过 cydia，不越狱直接打包成 ipa 安装包。越狱的话会安装一个 mobilesubstrate 的动态库，使用 theos 开发工具，非越狱的直接把这个库打包进 ipa 中或者直接修改汇编代码。\nMobilesubstrate 提供了三个模块来方便开发。\n MobileHooker：利用 method swizzling 技术定义一些宏和函数来替换系统或者目标函数。 MobileLoader：在程序启动时将我们写的破解程序用的第三方库注入进去。怎么注入的呢，还记得先前说的 clang attribute 里的一个 attribute((constructor)) 么，它会在 main 执行之前执行，所以把我们的 hook 放在这里就可以了。 Safe mode：类似安全模式，会禁用的改动。  先前提到 Mach-O 的结构有 Header，Load commands 和 Data，Mobileloader 会通过修改二进制的 loadCommands 来先把自己注入然后再把我们写的第三方库注入进去，这样破解程序就会放在 Load commands 段里面了。\n当然如果是我们自己的程序我们是知道要替换哪些方法的，既然是逆向肯定是别人的程序了，这个时候就需要去先分析下我们想替换方法是哪个，网络相关的分析可以用常用那些抓包工具，比如 Charles，WireShark 等，静态的可以通过砸壳，反汇编，classdump 头文件来分析 app 的架构，对应的常用工具dumpdecrypted，hopper disassembler 和 class_dump。运行时的分析可用工具有运行时控制台cycript，远程断点调试lldb+debugserver，logify。\n 这里有个实例，讲解如何通过逆向实现微信抢红包的插件： 【Dev Club 分享第三期】iOS 黑客技术大揭秘 - DEV CLUB 入门文章可以看看这篇： MyArticles/iOS冰与火之歌 at master · zhengmin1989/MyArticles · GitHub 玩出新花样： 黑科技：把第三方 iOS 应用转成动态库 - Jun’s Blog，作者另一篇文章： iOS符号表恢复\u0026amp;逆向支付宝 - Jun’s Blog  dyld动态链接 生成可执行文件后就是在启动时进行动态链接了，进行符号和地址的绑定。首先会加载所依赖的 dylibs，修正地址偏移，因为 iOS 会用 ASLR 来做地址偏移避免攻击，确定 Non-Lazy Pointer 地址进行符号地址绑定，加载所有类，最后执行 load 方法和 clang attribute 的 constructor 修饰函数。\n用先前 Mach-O 章节的例子继续分析，每个函数，全局变量和类都是通过符号的形式来定义和使用的，当把目标文件链接成一个执行文件时，链接器在目标文件和动态库之间对符号做解析处理。\n符号表会规定它们的符号，使用 nm 工具看看\nxcrun nm -nm SayHi.o  (undefined) external _OBJC_CLASS_$_Foo (undefined) external _objc_autoreleasePoolPop (undefined) external _objc_autoreleasePoolPush (undefined) external _objc_msgSend 0000000000000000 (__TEXT,__text) external _main  OBJC_CLASS$_Foo 表示 Foo 的 OC 符号。 (undefined) external 表示未实现非私有，如果是私有就是 non-external。 external _main 表示 main() 函数，处理 0 地址，将要到 __TEXT,__text section  再看看 Foo\nxcrun nm -nm Foo.o  (undefined) external _NSLog (undefined) external _OBJC_CLASS_$_NSObject (undefined) external _OBJC_METACLASS_$_NSObject (undefined) external ___CFConstantStringClassReference (undefined) external __objc_empty_cache 0000000000000000 (__TEXT,__text) non-external -[Foo say] 0000000000000060 (__DATA,__objc_const) non-external l_OBJC_METACLASS_RO_$_Foo 00000000000000a8 (__DATA,__objc_const) non-external l_OBJC_$_INSTANCE_METHODS_Foo 00000000000000c8 (__DATA,__objc_const) non-external l_OBJC_CLASS_RO_$_Foo 0000000000000110 (__DATA,__objc_data) external _OBJC_METACLASS_$_Foo 0000000000000138 (__DATA,__objc_data) external _OBJC_CLASS_$_Foo 因为 undefined 符号表示该文件类未实现的，所以在目标文件和 Fundation framework 动态库做链接处理时，链接器会尝试解析所有的 undefined 符号。\n链接器通过动态库解析成符号会记录是通过哪个动态库解析的，路径也会一起记录。对比下 a.out 符号表看看是怎么解析符号的。\nxcrun nm -nm a.out  (undefined) external _NSLog (from Foundation) (undefined) external _OBJC_CLASS_$_NSObject (from CoreFoundation) (undefined) external _OBJC_METACLASS_$_NSObject (from CoreFoundation) (undefined) external ___CFConstantStringClassReference (from CoreFoundation) (undefined) external __objc_empty_cache (from libobjc) (undefined) external _objc_autoreleasePoolPop (from libobjc) (undefined) external _objc_autoreleasePoolPush (from libobjc) (undefined) external _objc_msgSend (from libobjc) (undefined) external dyld_stub_binder (from libSystem) 0000000100000000 (__TEXT,__text) [referenced dynamically] external __mh_execute_header 0000000100000e90 (__TEXT,__text) external _main 0000000100000f10 (__TEXT,__text) non-external -[Foo say] 0000000100001130 (__DATA,__objc_data) external _OBJC_METACLASS_$_Foo 0000000100001158 (__DATA,__objc_data) external _OBJC_CLASS_$_Foo 看看哪些 undefined 的符号，有了更多信息，可以知道在哪个动态库能够找到。\n通过 otool 可以找到所需库在哪\nxcrun otool -L a.out a.out: /System/Library/Frameworks/Foundation.framework/Versions/C/Foundation (compatibility version 300.0.0, current version 1349.25.0) /usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1238.0.0) /System/Library/Frameworks/CoreFoundation.framework/Versions/A/CoreFoundation (compatibility version 150.0.0, current version 1348.28.0) /usr/lib/libobjc.A.dylib (compatibility version 1.0.0, current version 228.0.0) libSystem 里有很多我们熟悉的lib\n libdispatch：GCD libsystem_c：C语言库 libsystem_blocks：Block libcommonCrypto：加密，比如md5  dylib 这种格式的表示是动态链接的，编译的时候不会被编译到执行文件中，在程序执行的时候才 link，这样就不用算到包的大小里，而且也能够不更新执行程序就能够更新库。\n打印什么库被加载了\n(export DYLD_PRINT_LIBRARIES=; ./a.out ) dyld: loaded: /Users/didi/Downloads/./a.out dyld: loaded: /System/Library/Frameworks/Foundation.framework/Versions/C/Foundation dyld: loaded: /usr/lib/libSystem.B.dylib dyld: loaded: /System/Library/Frameworks/CoreFoundation.framework/Versions/A/CoreFoundation … 数数还挺多的，因为 Fundation 还会依赖一些其它的动态库，其它的库还会再依赖更多的库，这样相互依赖的符号会很多，需要处理的时间也会比较长，这里系统上的动态链接器会使用共享缓存，共享缓存在 /var/db/dyld/。当加载 Mach-O 文件时动态链接器会先检查共享内存是否有。每个进程都会在自己地址空间映射这些共享缓存，这样可以优化启动速度。\n动态链接器的作用顺序是怎么样的呢，可以先看看 Mike Ash 写的这篇关于 dyld 的博客： Dynamic Linking On OS X\ndyld 做了些什么事\n kernel 做启动程序初始准备，开始由dyld负责。 基于非常简单的原始栈为 kernel 设置进程来启动自身。 使用共享缓存来处理递归依赖带来的性能问题，ImageLoader 会读取二进制文件，其中包含了我们的类，方法等各种符号。 立即绑定 non-lazy 的符号并设置用于 lazy bind 的必要表，将这些库 link 到执行文件里。 为可执行文件运行静态初始化。 设置参数到可执行文件的 main 函数并调用它。 在执行期间，通过绑定符号处理对 lazily-bound 符号存根的调用提供 runtime 动态加载服务（通过 dl*() 这个 API ），并为gdb和其它调试器提供钩子以获得关键信息。runtime 会调用 map_images 做解析和处理，load_images 来调用 call_load_methods 方法遍历所有加载了的 Class，按照继承层级依次调用 +load 方法。 在 mian 函数返回后运行 static terminator。 在某些情况下，一旦 main 函数返回，就需要调用 libSystem 的 _exit。  查看运行时的调用 map_images 和 调用 +load 方法的相关 runtime 处理可以通过 RetVal 的可debug 的 objc/runtime RetVal/objc-runtime: objc runtime 706 来进行断点查看调用的 runtime 方法具体实现。在 debug-objc 下创建一个类，在 +load 方法里断点查看走到这里调用的堆栈如下：\n0 +[someclass load] 1 call_class_loads() 2 ::call_load_methods 3 ::load_images(const char *path __unused, const struct mach_header *mh) 4 dyld::notifySingle(dyld_image_states, ImageLoader const*, ImageLoader::InitializerTimingList*) 11 _dyld_start 在 load_images 方法里断点 p path 可以打印出所有加载的动态链接库，这个方法的 hasLoadMethods 用于快速判断是否有 +load 方法。\nprepare_load_methods 这个方法会获取所有类的列表然后收集其中的 +load 方法，在代码里可以发现 Class 的 +load 是先执行的，然后执行 Category 的。为什么这样做，原因可以通过 prepare_load_methods 这个方法看出，在遍历 Class 的 +load 方法时会执行 schedule_class_load 这个方法，这个方法会递归到根节点来满足 Class 收集完整关系树的需求。\n最后 call_load_methods 会创建一个 autoreleasePool 使用函数指针来动态调用类和 Category 的 +load 方法。\n如果想了解 Cocoa 的 Fundation 库可以通过 GNUStep 源码来学习。比如 NSNotificationCenter 发送通知是按什么顺序发送的可以查看 NSNotificationCenter.m 里的 addObserver 方法和 postNotification 方法，看看观察者是怎么添加的和怎么被遍历通知到的。\ndyld 是开源的： GitHub - opensource-apple/dyld\n还可以看看苹果的 WWDC 视频 WWDC 2016 Session 406 里讲解对启动进行优化。\n这篇文章也不错： Dynamic Linking of Imported Functions in Mach-O - CodeProject\nLLVM 工具链 获取 LLVM 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  #先下载 LLVM svn co https://llvm.org/svn/llvm-project/llvm/trunk llvm #在 LLVM 的 tools 目录下下载 Clang cd llvm/tools svn co https://llvm.org/svn/llvm-project/cfe/trunk clang #在 LLVM 的 projects 目录下下载 compiler-rt，libcxx，libcxxabi cd ../projects svn co https://llvm.org/svn/llvm-project/compiler-rt/trunk compiler-rt svn co https://llvm.org/svn/llvm-project/libcxx/trunk libcxx svn co https://llvm.org/svn/llvm-project/libcxxabi/trunk libcxxabi #在 Clang 的 tools 下安装 extra 工具 cd ../tools/clang/tools svn co https://llvm.org/svn/llvm-project/clang-tools-extra/trunk extra   编译 LLVM 1 2 3 4 5 6 7 8 9  brew install gcc brew install cmake mkdir build cd build cmake -DCMAKE_BUILD_TYPE=Release -DBUILD_SHARED_LIBS=ON -DLLVM_TARGETS_TO_BUILD=\u0026#34;AArch64;X86\u0026#34; -G \u0026#34;Unix Makefiles\u0026#34; .. make j8 #安装 make install #如果找不到标准库，Xcode 需要安装 xcode-select --install   1 2 3 4  #如果希望是 xcodeproject 方式 build 可以使用 -GXcode mkdir xcodeBuild cd xcodeBuild cmake -GXcode /path/to/llvm/source   在 bin 下存放着工具链，有了这些工具链就能够完成源码编译了。\nLLVM 源码工程目录介绍  llvm/examples/ - 使用 LLVM IR 和 JIT 的例子。 llvm/include/ - 导出的头文件。 llvm/lib/ - 主要源文件都在这里。 llvm/project/ - 创建自己基于 LLVM 的项目的目录。 llvm/test/ - 基于 LLVM 的回归测试，健全检察。 llvm/suite/ - 正确性，性能和基准测试套件。 llvm/tools/ - 基于 lib 构建的可以执行文件，用户通过这些程序进行交互，-help 可以查看各个工具详细使用。 llvm/utils/ - LLVM 源代码的实用工具，比如，查找 LLC 和 LLI 生成代码差异工具， Vim 或 Emacs 的语法高亮工具等。  lib 目录介绍  llvm/lib/IR/ - 核心类比如 Instruction 和 BasicBlock。 llvm/lib/AsmParser/ - 汇编语言解析器。 llvm/lib/Bitcode/ - 读取和写入字节码 llvm/lib/Analysis/ - 各种对程序的分析，比如 Call Graphs，Induction Variables，Natural Loop Identification 等等。 llvm/lib/Transforms/ - IR-to-IR 程序的变换。 llvm/lib/Target/ - 对像 X86 这样机器的描述。 llvm/lib/CodeGen/ - 主要是代码生成，指令选择器，指令调度和寄存器分配。 llvm/lib/ExecutionEngine/ - 在解释执行和JIT编译场景能够直接在运行时执行字节码的库。  工具链命令介绍 基本命令  llvm-as - 汇编器，将 .ll 汇编成字节码。 llvm-dis - 反汇编器，将字节码编成可读的 .ll 文件。 opt - 字节码优化器。 llc - 静态编译器，将字节码编译成汇编代码。 lli - 直接执行 LLVM 字节码。 llvm-link - 字节码链接器，可以把多个字节码文件链接成一个。 llvm-ar - 字节码文件打包器。 llvm-lib - LLVM lib.exe 兼容库工具。 llvm-nm - 列出字节码和符号表。 llvm-config - 打印 LLVM 编译选项。 llvm-diff - 对两个进行比较。 llvm-cov - 输出 coverage infomation。 llvm-profdata - Profile 数据工具。 llvm-stress - 生成随机 .ll 文件。 llvm-symbolizer - 地址对应源码位置，定位错误。 llvm-dwarfdump - 打印 DWARF。  调试工具  bugpoint - 自动测试案例工具 llvm-extract - 从一个 LLVM 的模块里提取一个函数。 llvm-bcanalyzer - LLVM 字节码分析器。  开发工具  FileCheck - 灵活的模式匹配文件验证器。 tblgen - C++ 代码生成器。 lit - LLVM 集成测试器。 llvm-build - LLVM 构建工程时需要的工具。 llvm-readobj - LLVM Object 结构查看器。  Swift 编译 官网： GitHub - apple/swift: The Swift Programming Language swift 现在是开源的，如果希望能够为它做贡献可以先了解下官方的介绍说明： Swift.org - Contributing\n#首先和 LLVM 一样先安装 cmake 和 ninja ，再创建目录 brew install cmake ninja mkdir swiftsource cd swiftsource #clone 下 swift 源码 git clone https://github.com/apple/swift.git #checkout 相关编译的依赖，比如 llvm，clang，llbuild，lldb，ninja，cmark 等等，目前差不多有13个 ./swift/utils/update-checkout —clone #查看文件夹 du -h -d 1 #build swift，这里的 -x 参数会生成 xcode 的工程文件方便在xcode里阅读。-R 会使用 release 模式，比 debug 快。 ./swift/utils/build-script -x -R #更新 ./swift/utils/update-checkout ./swift/utils/build-script -x -R #切到指定tag和分支 #tag ./swift/utils/update-checkout —tag swift-3.0-RELEASE #特定分支 ./swift/utils/update-checkout —scheme swift-3.0-branch swift 编译是由多个代码仓库组合而成的，各个代码仓库的介绍说明可以查看官方说明： Swift.org - Source Code\n其它编译工具 js写的C++解释器JSCPP 适合学生学习时能够方便的在浏览器里直接编c++程序。项目地址：GitHub - felixhao28/JSCPP: A simple C++ interpreter written in JavaScript\nC-SMILE 一套支持C/C++ JS JAVA四种语言的scripting language 在 web 中有个 WebAssembly 是个标准，可以使得 web 运行 C/C++ 成为可能。当然还有其它的比如：https://c-smile.sourceforge.net/\n资料网址  https://llvm.org https://clang.llvm.org/ https://www.aosabook.org/en/llvm.html GitHub - loarabia/Clang-tutorial: A collection of code samples showing usage of clang and llvm as a library Using an external Xcode Clang Static Analyzer binary, with additional checks - Stack Overflow LLVM Developers’ Metting ming1016  ","title":"深入剖析-iOS-编译-Clang---LLVM"},{"link":"https://blog.policx.com/posts/ios-han/","text":"打算在项目中大面积使用RAC来开发，所以整理一些常用的实践范例和比较完整的api说明方便开发时随时查阅 *\n声明式编程泛型Declarative programming 函数反应式编程是声明式编程的子编程范式之一\n高阶函数 需要满足两个条件\n 一个或者多个函数作为输入。 有且仅有一个函数输出。  Objective-c里使用block作为函数\n[array enumerateObjectsUsingBlock:^(NSNumber *number, NSUInteger idx, BOOL *stop) { NSLog(@\u0026quot;%@\u0026quot;,number); }]; 映射map NSArray * mappedArray = [array rx_mapWithBlock:^id(id each){ return @(pow([each integerValue],2)); }]; 过滤filter NSArray *filteredArray = [array rx_filterWithBlock:^BOOL(id each){ return ([each integerValue] % 2 == 0); }] 折叠fold [[array rx_mapWithBlock:^id (id each){ return [each stringValue]; }] rx_foldInitialValue:@\u0026quot;\u0026quot; block:^id (id memo , id each){ return [memo stringByAppendingString:each]; }]; Currying 用函数生成另一个函数\nfunc filterGenerator(lastnameCondition: String) -\u0026gt; (Staff) -\u0026gt; (Bool) { return {staff in return staff.lastname == lastnameCondition } } let filterWang = filterGenerator(\u0026quot;Wang\u0026quot;) let filterHu = filterGenerator(\u0026quot;Hu\u0026quot;) staffs.filter(filterHu) RAC中使用高阶函数 映射 NSArray *array = @[ @1, @2, @3 ]; RACSequence * stream = [array rac_sequence]; //RACSequence是一个RACStream的子类。 [stream map:^id (id value){ return @(pow([value integerValue], 2)); }]; //RACSequence有一个方法返回数组:array NSLog(@\u0026quot;%@\u0026quot;,[stream array]); //避免污染变量的作用域 NSLog(@\u0026quot;%@\u0026quot;,[[[array rac_sequence] map:^id (id value){ return @(pow([value integerValue], 2)); }] array]); 过滤 NSLog(@\u0026quot;%@\u0026quot;, [[[array rac_sequence] filter:^BOOL (id value){ return [value integerValue] % 2 == 0; }] array]); 折叠 NSLog(@\u0026quot;%@\u0026quot;,[[[array rac_sequence] map:^id (id value){ return [value stringValue]; }] foldLeftWithStart:@\u0026quot;\u0026quot; reduce:^id (id accumulator, id value){ return [accumulator stringByAppendingString:value]; }]); 绑定键值 RACSignal * validEmailSignal = [self.textField.rac_textSignal map:^id (NSString *value){ return @([value rangeOfString:@\u0026quot;@\u0026quot;].location != NSNotFound); }]; RAC(self.button, enabled) = validEmailSignal; RAC(self.textField, textColor) = [validEmailSignal map: ^id (id value){ if([value boolValue]){ return [UIColor greenColor]; }else{ return [UIColor redColor]; } }]; 实践 比较好的一个完整的RAC实践的例子：https://github.com/ashfurrow/FunctionalReactivePixels\n网络请求生成对应model + (RACSignal *)importPhotos{ RACReplaySubject * subject = [RACReplaySubject subject]; NSURLRequest * request = [self popularURLRequest]; [NSURLConnection sendAsynchronousRequest:request queue:[NSOperationQueue mainQueue] completionHandler:^(NSURLResponse *response, NSData *data, NSError *connectionError){ if (data) { id results = [NSJSONSerialization JSONObjectWithData:data options:0 error:nil]; [subject sendNext:[[[results[@\u0026quot;photos\u0026quot;] rac_sequence] map:^id(NSDictionary *photoDictionary){ FRPPhotoModel * model = [FRPPhotoModel new]; [self configurePhotoModel:model withDictionary:photoDictionary]; [self downloadThumbnailForPhotoModel:model]; return model; }] array]]; [subject sendCompleted]; } else{ [subject sendError:connectionError]; } }]; return subject; } 过滤相同大小的图片，取出他们的url，返回第一个 + (NSString *)urlForImageSize:(NSInteger)size inDictionary:(NSArray *)array{ return [[[[[array rac_sequence] filter:^ BOOL (NSDictionary * value){ return [value[@\u0026quot;size\u0026quot;] integerValue] == size; }] map:^id (id value){ return value[@\u0026quot;url\u0026quot;]; }] array] firstObject]; } 观察model里的图片数据，进行为空过滤判断，将data转为UIImage，再把绑定新信号的值给对象的关键路径 - (void)setPhotoModel:(FRPPhotoModel *)photoModel{ self.subscription = [[[RACObserver(photoModel, thumbnailData) filter:^ BOOL (id value){ return value != nil; }] map:^id (id value){ return [UIImage imageWithData:value]; }] setKeyPath:@keypath(self.imageView, image) onObject:self.imageView]; } UITableViewCell复用时需要取消cell上各个组件的订阅 - (void)perpareForReuse { [super prepareForReuse]; [self.subscription dispose], self.subscription = nil; } Delegate的使用 //注意：你必须retain这个delegate对象，否则他们将会被释放，你将会得到一个EXC_BAD_ACCESS异常。添加下列私有属性到画廊视图控制器： @property (nonatomic, strong) id collectionViewDelegate; //同时你也需要导入RACDelegateProxy.h，因为他不是ReactiveCocoa的核心部分，不包含在ReactiveCocoa.h中。 RACDelegateProxy *viewControllerDelegate = [[RACDelegateProxy alloc] initWithProtocol:@protocol(FRPFullSizePhotoViewControllerDelegate)]; [[viewControllerDelegate rac_signalForSelector:@selector(userDidScroll:toPhotoAtIndex:) fromProtocol:@protocol(FRPFullSizePhotoViewControllerDelegate)] subscribeNext:^(RACTuple *value){ @strongify(self); [self.collectionView scrollToItemAtIndexPath:[NSIndexPath indexPathForItem:[value.second integerValue] inSection:0] atScrollPosition:UICollectionViewScrollPositionCenteredVertically animated:NO]; }]; self.collectionViewDelegate = [[RACDelegateProxy alloc] initWithProtocol:@protocol(UICollectionViewDelegate)]; [[self.collectionViewDelegate rac_signalForSelector:@selector(collectionView:didSelectItemAtIndexPath:)] subscribeNext:^(RACTuple *arguments) { @strongify(self); FRPFullSizePhotoViewController *viewController = [[FRPFullSizePhotoViewController alloc] initWithPhotoModels:self.photosArray currentPhotoIndex:[(NSIndexPath *)arguments.second item]]; viewController.delegate = (id\u0026lt;FRPFullSizePhotoViewControllerDelegate\u0026gt;)viewControllerDelegate; [self.navigationController pushViewController:viewController animated:YES]; }]; 处理异常，完成执行刷新操作，异常打印日志，执行对应方法 RAC(self, photosArray) = [[[[FRPPhotoImporter importPhotos] doCompleted:^{ @strongify(self); [self.collectionView reloadData]; }] logError] catchTo:[RACSignal empty]]; 网络请求处理数据，获取数据返回主线程 + (RACSignal *)importPhotos { NSURLRequest *request = [self popularURLRequest]; return [[[[[[NSURLConnection rac_sendAsynchronousRequest:request] reduceEach:^id(NSURLResponse *response , NSData *data){ //注意：我们可以用下面的reduceEach:替代使用RACTuple的第一个map:，以便提供编译时检查。 return data; }] deliverOn:[RACScheduler mainThreadScheduler]] map:^id (NSData *data) { id results = [NSJSONSerialization JSONObjectWithData:data options:0 error:nil]; return [[[results[@\u0026quot;photo\u0026quot;] rac_sequence] map:^id (NSDictionary *photoDictionary) { FRPPhotoModel *model = [FRPPhotoModel new]; [self configurePhotoModel:model withDictionary:photoDictionary]; [self downloadThumbnailForPhotoModel:model]; return model; }] array]; }] publish] autoconnect]; //信号链条最末端的信号操作publish. publish返回一个RACMulitcastConnection,当信号连接上时，他将订阅该接收信号。autoconnect为我们做的是：当它返回的信号被订阅，连接到 该(订阅背后的)信号（underly signal）。 } 信号的信号Signal of signals，一个外部信号包含一个内部信号，在输出信号的subscribeNext:块中订阅内部信号，会引起嵌套麻烦。使用flattenMap后会生成一个新的信号，和先前信号平级，订阅会订阅到返回的新信号里的值。map方法也是创建一个新信号，但是会将返回的信号也当做值，这样就得不到真正需要的值了。 [[[self.signInButton rac_signalForControlEvents:UIControlEventTouchUpInside] flattenMap:^RACStream *(id value) { return [self signInSignal]; }] subscribeNext:^(id x) { //x NSLog(@\u0026quot;Sign in result: %@\u0026quot;, x); }]; 不同信号顺序链接，程序需要等待前一个信号发出完成事件（sendCompleted），然后再订阅下一个信号（then） - (RACSignal *)requestAccessToTwitterSignal { // 定义一个错误，如果用户拒绝访问则发送 NSError *accessError = [NSError errorWithDomain:RWTwitterInstantDomain code:RWTwitterInstantErrorAccessDenied userInfo:nil]; // 创建并返回信号 @weakify(self) return [RACSignal createSignal:^RACDisposable *(id\u0026lt;RACSubscriber\u0026gt; subscriber) { // 请求访问twitter @strongify(self) [self.accountStore requestAccessToAccountsWithType:self.twitterAccountType options:nil completion:^(BOOL granted, NSError *error) { // 处理响应 if (!granted) { [subscriber sendError:accessError]; } else { [subscriber sendNext:nil]; [subscriber sendCompleted]; } }]; return nil; }]; } //throttle可以避免连续输入造成的不必要的请求，then会忽略前一个信号的值，底层的实现是先过滤之前信号发的值，再使用concat连接then返回的信号。 [[[[[[[self requestAccessToTwitterSignal] then:^RACSignal *{ @strongify(self) return self.searchText.rac_textSignal; }] filter:^BOOL(NSString *text) { @strongify(self) return [self isValidSearchText:text]; }] throttle:0.5] flattenMap:^RACStream *(NSString *text) { @strongify(self) //flattenMap来将每个next事件映射到一个新的被订阅的信号 return [self signalForSearchWithText:text]; }] deliverOn:[RACScheduler mainThreadScheduler]] subscribeNext:^(NSDictionary *jsonSearchResult) { NSArray *statuses = jsonSearchResult[@\u0026quot;statuses\u0026quot;]; NSArray *tweets = [statuses linq_select:^id(id tweet) { return [RWTweet tweetWithStatus:tweet]; }]; [self.resultsViewController displayTweets:tweets]; } error:^(NSError *error) { NSLog(@\u0026quot;An error occurred: %@\u0026quot;, error); }]; - (RACSignal *)signalForSearchWithText:(NSString *)text { // 1 - define the errors NSError *noAccountsError = [NSError errorWithDomain:RWTwitterInstantDomain code:RWTwitterInstantErrorNoTwitterAccounts userInfo:nil]; NSError *invalidResponseError = [NSError errorWithDomain:RWTwitterInstantDomain code:RWTwitterInstantErrorInvalidResponse userInfo:nil]; @weakify(self) return [RACSignal createSignal:^RACDisposable *(id subscriber) { @strongify(self); SLRequest *request = [self requestforTwitterSearchWithText:text]; NSArray *twitterAccounts = [self.accountStore accountsWithAccountType:self.twitterAccountType]; if (twitterAccounts.count == 0) { [subscriber sendError:noAccountsError]; } else { [request setAccount:[twitterAccounts lastObject]]; [request performRequestWithHandler: ^(NSData *responseData, NSHTTPURLResponse *urlResponse, NSError *error) { if (urlResponse.statusCode == 200) { NSDictionary *timelineData = [NSJSONSerialization JSONObjectWithData:responseData options:NSJSONReadingAllowFragments error:nil]; [subscriber sendNext:timelineData]; [subscriber sendCompleted]; } else { [subscriber sendError:invalidResponseError]; } }]; } return nil; }]; } 异步加载图片 -(RACSignal *)signalForLoadingImage:(NSString *)imageUrl { RACScheduler *scheduler = [RACScheduler schedulerWithPriority:RACSchedulerPriorityBackground]; return [[RACSignal createSignal:^RACDisposable *(id\u0026lt;RACSubscriber\u0026gt; subscriber) { NSData *data = [NSData dataWithContentsOfURL:[NSURL URLWithString:imageUrl]]; UIImage *image = [UIImage imageWithData:data]; [subscriber sendNext:image]; [subscriber sendCompleted]; return nil; }] subscribeOn:scheduler]; } cell.twitterAvatarView.image = nil; [[[self signalForLoadingImage:tweet.profileImageUrl] deliverOn:[RACScheduler mainThreadScheduler]] subscribeNext:^(UIImage *image) { cell.twitterAvatarView.image = image; }]; 观察viewModel里的tableView的数据键值和全部读取键值，只要有一个有新值就会调用 @weakify(self); [[[RACSignal merge: @[RACObserve(self.viewModel, tweets), RACObserve(self.viewModel, allTweetsLoaded)]] bufferWithTime: 0 onScheduler: [RACScheduler mainThreadScheduler]] subscribeNext: ^(id value) { @strongify(self); [self.tableView reloadData]; }]; //bufferWithTime设置为0是为了避免同一时刻两个值被同时设置新值产生了table进行了两次reloadData 封装hook方法，某个selector被调用时，再执行一段指定代码和hook一样。 @weakify(self); [[tableView rac_signalForSelector:@selector(layoutSubviews)]subscribeNext:^(id x) { @strongify(self); [self doSomethingBeforeTableViewLayoutSubviews]; }]; 使用RACCommand来实现按钮的状态根据输入邮箱判断邮箱是否非法还有提交到服务器后出错处理等 Demo的github地址：https://github.com/olegam/RACCommandExample\n- (void)bindWithViewModel { RAC(self.viewModel, email) =self.emailTextField.rac_textSignal; self.subscribeButton.rac_command = self.viewModel.subscribeCommand; RAC(self.statusLabel, text) =RACObserve(self.viewModel, statusMessage); } @interface SubscribeViewModel :NSObject @property(nonatomic, strong)RACCommand *subscribeCommand; // writeto this property @property(nonatomic, strong) NSString *email; // read from this property @property(nonatomic, strong) NSString *statusMessage; @end #import \u0026quot;SubscribeViewModel.h\u0026quot; #import \u0026quot;AFHTTPRequestOperationManager+RACSupport.h\u0026quot; #import\u0026quot;NSString+EmailAdditions.h\u0026quot; static NSString *const kSubscribeURL =@\u0026quot;https://reactivetest.apiary.io/subscribers\u0026quot;; @interface SubscribeViewModel () @property(nonatomic, strong) RACSignal*emailValidSignal; @end @implementation SubscribeViewModel - (id)init { self= [super init]; if(self) { [self mapSubscribeCommandStateToStatusMessage]; } returnself; } -(void)mapSubscribeCommandStateToStatusMessage { RACSignal *startedMessageSource = [self.subscribeCommand.executionSignals map:^id(RACSignal *subscribeSignal) { return NSLocalizedString(@\u0026quot;Sending request...\u0026quot;, nil); }]; RACSignal *completedMessageSource = [self.subscribeCommand.executionSignals flattenMap:^RACStream *(RACSignal *subscribeSignal) { return[[[subscribeSignal materialize] filter:^BOOL(RACEvent *event) { return event.eventType == RACEventTypeCompleted; }] map:^id(id value) { return NSLocalizedString(@\u0026quot;Thanks\u0026quot;, nil); }]; }]; RACSignal*failedMessageSource = [[self.subscribeCommand.errors subscribeOn:[RACSchedulermainThreadScheduler]] map:^id(NSError *error) { return NSLocalizedString(@\u0026quot;Error :(\u0026quot;, nil); }]; RAC(self,statusMessage) = [RACSignal merge:@[startedMessageSource, completedMessageSource, failedMessageSource]]; } - (RACCommand *)subscribeCommand { if(!_subscribeCommand) { @weakify(self); _subscribeCommand = [[RACCommand alloc] initWithEnabled:self.emailValidSignal signalBlock:^RACSignal *(id input) { @strongify(self); return [SubscribeViewModel postEmail:self.email]; }]; } return _subscribeCommand; } + (RACSignal *)postEmail:(NSString *)email{ AFHTTPRequestOperationManager*manager = [AFHTTPRequestOperationManager manager]; manager.requestSerializer= [AFJSONRequestSerializer new]; NSDictionary*body = @{@\u0026quot;email\u0026quot;: email ?: @\u0026quot;\u0026quot;}; return [[[manager rac_POST:kSubscribeURL parameters:body] logError] replayLazily]; } - (RACSignal *)emailValidSignal { if(!_emailValidSignal) { _emailValidSignal= [RACObserve(self, email) map:^id(NSString *email) { return@([email isValidEmail]); }]; } return _emailValidSignal; } @end 替换Delegate，直接使用RACSubject RAC内存管理 RAC会维护一个全局的信号集合，一个或多于一个订阅者就可用，所有订阅者都被移除了，信号就被释放了。\nRAC需要注意的内存问题 宏定义 - (void)viewDidLoad { [super viewDidLoad]; RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id\u0026lt;RACSubscriber\u0026gt; subscriber) { //1 MTModel *model = [[MTModel alloc] init]; // MTModel有一个名为的title的属性 [subscriber sendNext:model]; [subscriber sendCompleted]; return nil; }]; self.flattenMapSignal = [signal flattenMap:^RACStream *(MTModel *model) { //2 return RACObserve(model, title); }]; [self.flattenMapSignal subscribeNext:^(id x) { //3 NSLog(@\u0026quot;subscribeNext - %@\u0026quot;, x); }]; } 上面的RACObserve会引起引用不释放的问题，通过RACObserve的定义来看看，里面会对self进行持有。\n#define RACObserve(TARGET, KEYPATH) \\ ({ \\ _Pragma(\u0026quot;clang diagnostic push\u0026quot;) \\ _Pragma(\u0026quot;clang diagnostic ignored \\\u0026quot;-Wreceiver-is-weak\\\u0026quot;\u0026quot;) \\ __weak id target_ = (TARGET); \\ [target_ rac_valuesForKeyPath:@keypath(TARGET, KEYPATH) observer:self]; \\ _Pragma(\u0026quot;clang diagnostic pop\u0026quot;) \\ }) Subject 对subject进行map这样的操作，这时就需要sendCompleted\n- (void)viewDidLoad { [super viewDidLoad]; RACSubject *subject = [RACSubject subject]; [subject.rac_willDeallocSignal subscribeCompleted:^{ NSLog(@\u0026quot;subject dealloc\u0026quot;); }]; [[subject map:^id(NSNumber *value) { return @([value integerValue] * 3); }] subscribeNext:^(id x) { NSLog(@\u0026quot;next = %@\u0026quot;, x); }]; [subject sendNext:@1]; } 但是为什么signal进行map操作，不sendCompleted而不会内存泄漏呢。因为调到bind的比如map、filter、merge、combineLatest、flattenMap等操作如果是RACSubject这样会持有订阅者的信号会产生内存泄漏需要sendCompleted。可以先看看bind的实现\n- (RACSignal *)bind:(RACStreamBindBlock (^)(void))block { NSCParameterAssert(block != NULL); /* * -bind: should: * * 1. Subscribe to the original signal of values. * 2. Any time the original signal sends a value, transform it using the binding block. * 3. If the binding block returns a signal, subscribe to it, and pass all of its values through to the subscriber as they're received. * 4. If the binding block asks the bind to terminate, complete the _original_ signal. * 5. When _all_ signals complete, send completed to the subscriber. * * If any signal sends an error at any point, send that to the subscriber. */ return [[RACSignal createSignal:^(id\u0026lt;RACSubscriber\u0026gt; subscriber) { RACStreamBindBlock bindingBlock = block(); NSMutableArray *signals = [NSMutableArray arrayWithObject:self]; // 此处省略了80行代码 // ... }] setNameWithFormat:@\u0026quot;[%@] -bind:\u0026quot;, self.name]; } didSubscribe的开头，就创建了一个数组signals，并且持有了self，也就是源信号，也就是订阅者持有了信号，如果是Subject那么这种信号又会持有订阅者，这样就形成了循环引用。\n下面看看sendCompleted如何修复的内存泄漏\nvoid (^completeSignal)(RACSignal *, RACDisposable *) = ^(RACSignal *signal, RACDisposable *finishedDisposable) { BOOL removeDisposable = NO; @synchronized (signals) { [signals removeObject:signal]; //1 if (signals.count == 0) { [subscriber sendCompleted]; //2 [compoundDisposable dispose]; //3 } else { removeDisposable = YES; } } if (removeDisposable) [compoundDisposable removeDisposable:finishedDisposable]; //4 }; 从signals这个数组中移除传入的signal，也就是让订阅的signal不会持有subject这种信号。\n还有replay这样的操作，因为这个方法返回的是一个RACReplaySubject\nRACSignal *signal = [RACSignal createSignal:^RACDisposable *(id\u0026lt;RACSubscriber\u0026gt; subscriber) { [subscriber sendNext:@1]; [subscriber sendCompleted]; // 保证源信号发送完成 return nil; }]; RACSignal *replaySignal = [signal replay]; // 这里返回的其实是一个RACReplaySubject [[replaySignal map:^id(NSNumber *value) { return @([value integerValue] * 3); }] subscribeNext:^(id x) { NSLog(@\u0026quot;subscribeNext - %@\u0026quot;, x); }]; 热信号冷信号  热信号是主动的，不订阅也能够按时发送。冷信号是被动的，只有订阅才会发送。 热信号可以有多个订阅者。冷信号只能够一对一，有不同订阅者，消息会从新完整发送。  RAC的API手册 常见类 RACSiganl 信号类。  RACEmptySignal ：空信号，用来实现 RACSignal 的 +empty 方法； RACReturnSignal ：一元信号，用来实现 RACSignal 的 +return: 方法； RACDynamicSignal ：动态信号，使用一个 block - 来实现订阅行为，我们在使用 RACSignal 的 +createSignal: 方法时创建的就是该类的实例； RACErrorSignal ：错误信号，用来实现 RACSignal 的 +error: 方法； RACChannelTerminal ：通道终端，代表 RACChannel 的一个终端，用来实现双向绑定。  RACSubscriber 订阅者 RACDisposable 用于取消订阅或者清理资源，当信号发送完成或者发送错误的时候，就会自动触发它。  RACSerialDisposable ：作为 disposable 的容器使用，可以包含一个 disposable 对象，并且允许将这个 disposable 对象通过原子操作交换出来； RACKVOTrampoline ：代表一次 KVO 观察，并且可以用来停止观察； RACCompoundDisposable ：它可以包含多个 disposable 对象，并且支持手动添加和移除 disposable 对象 RACScopedDisposable ：当它被 dealloc 的时候调用本身的 -dispose 方法。  RACSubject 信号提供者，自己可以充当信号，又能发送信号。订阅后发送  RACGroupedSignal ：分组信号，用来实现 RACSignal 的分组功能； RACBehaviorSubject ：重演最后值的信号，当被订阅时，会向订阅者发送它最后接收到的值； RACReplaySubject ：重演信号，保存发送过的值，当被订阅时，会向订阅者重新发送这些值。可以先发送后订阅  RACTuple 元组类,类似NSArray,用来包装值. RACSequence RAC中的集合类 RACCommand RAC中用于处理事件的类，可以把事件如何处理,事件中的数据如何传递，包装到这个类中，他可以很方便的监控事件的执行过程。 RACMulticastConnection 用于当一个信号，被多次订阅时，为了保证创建信号时，避免多次调用创建信号中的block，造成副作用，可以使用这个类处理。 RACScheduler RAC中的队列，用GCD封装的。  RACImmediateScheduler ：立即执行调度的任务，这是唯一一个支持同步执行的调度器； RACQueueScheduler ：一个抽象的队列调度器，在一个 GCD 串行列队中异步调度所有任务； RACTargetQueueScheduler ：继承自 RACQueueScheduler ，在一个以一个任意的 GCD 队列为 target 的串行队列中异步调度所有任务； RACSubscriptionScheduler ：一个只用来调度订阅的调度器。  常见用法  rac_signalForSelector : 代替代理 rac_valuesAndChangesForKeyPath: KVO rac_signalForControlEvents:监听事件 rac_addObserverForName 代替通知 rac_textSignal：监听文本框文字改变 rac_liftSelector:withSignalsFromArray:Signals:当传入的Signals(信号数组)，每一个signal都至少sendNext过一次，就会去触发第一个selector参数的方法。  常见宏  RAC(TARGET, [KEYPATH, [NIL_VALUE]])：用于给某个对象的某个属性绑定 RACObserve(self, name) ：监听某个对象的某个属性,返回的是信号。 @weakify(Obj)和@strongify(Obj) RACTuplePack ：把数据包装成RACTuple（元组类） RACTupleUnpack：把RACTuple（元组类）解包成对应的数据 RACChannelTo 用于双向绑定的一个终端  常用操作方法  flattenMap map 用于把源信号内容映射成新的内容。 concat 组合 按一定顺序拼接信号，当多个信号发出的时候，有顺序的接收信号 then 用于连接两个信号，当第一个信号完成，才会连接then返回的信号。 merge 把多个信号合并为一个信号，任何一个信号有新值的时候就会调用 zipWith 把两个信号压缩成一个信号，只有当两个信号同时发出信号内容时，并且把两个信号的内容合并成一个元组，才会触发压缩流的next事件。 combineLatest:将多个信号合并起来，并且拿到各个信号的最新的值,必须每个合并的signal至少都有过一次sendNext，才会触发合并的信号。 reduce聚合:用于信号发出的内容是元组，把信号发出元组的值聚合成一个值 filter:过滤信号，使用它可以获取满足条件的信号. ignore:忽略完某些值的信号. distinctUntilChanged:当上一次的值和当前的值有明显的变化就会发出信号，否则会被忽略掉。 take:从开始一共取N次的信号 takeLast:取最后N次的信号,前提条件，订阅者必须调用完成，因为只有完成，就知道总共有多少信号. takeUntil:(RACSignal *):获取信号直到某个信号执行完成 skip:(NSUInteger):跳过几个信号,不接受。 switchToLatest:用于signalOfSignals（信号的信号），有时候信号也会发出信号，会在signalOfSignals中，获取signalOfSignals发送的最新信号。 doNext: 执行Next之前，会先执行这个Block doCompleted: 执行sendCompleted之前，会先执行这个Block timeout：超时，可以让一个信号在一定的时间后，自动报错。 interval 定时：每隔一段时间发出信号 delay 延迟发送next。 retry重试 ：只要失败，就会重新执行创建信号中的block,直到成功. replay重放：当一个信号被多次订阅,反复播放内容 throttle节流:当某个信号发送比较频繁时，可以使用节流，在某一段时间不发送信号内容，过了一段时间获取信号的最新内容发出。  UI - Category（常用汇总） rac_prepareForReuseSignal： 需要复用时用  相关UI: MKAnnotationView、UICollectionReusableView、UITableViewCell、UITableViewHeaderFooterView  rac_buttonClickedSignal：点击事件触发信号  相关UI：UIActionSheet、UIAlertView  rac_command：button类、刷新类相关命令替换  相关UI：UIBarButtonItem、UIButton、UIRefreshControl  rac_signalForControlEvents: control event 触发  相关UI：UIControl  rac_gestureSignal UIGestureRecognizer 事件处理信号  相关UI：UIGestureRecognizer  rac_imageSelectedSignal 选择图片的信号  相关UI：UIImagePickerController  rac_textSignal  相关UI：UITextField、UITextView  可实现双向绑定的相关API  rac_channelForControlEvents: key: nilValue: 相关UI：UIControl类 rac_newDateChannelWithNilValue: 相关UI：UIDatePicker rac_newSelectedSegmentIndexChannelWithNilValue: 相关UI：UISegmentedControl rac_newValueChannelWithNilValue: 相关UI：UISlider、UIStepper rac_newOnChannel 相关UI：UISwitch rac_newTextChannel 相关UI：UITextField  Foundation - Category （常用汇总） NSData  rac_readContentsOfURL: options: scheduler: 比oc多出线程设置  NSDictionary  rac_sequence rac_keySequence key 集合 rac_valueSequence value 集合  NSArray  rac_sequence 信号集合  NSFileHandle  rac_readInBackground 后台线程读取  NSInvocation  rac_setArgument: atIndex: 设置参数 rac_argumentAtIndex 取某个参数 rac_returnValue 所关联方法的返回值  NSNotificationCenter  rac_addObserverForName: object:注册通知  NSObject  rac_willDeallocSignal 对象销毁时发动的信号 rac_description debug用 rac_observeKeyPath: options: observer: block:监听某个事件 rac_liftSelector: withSignals: 全部信号都next在执行 rac_signalForSelector: 代替某个方法 rac_signalForSelector:(SEL)selector fromProtocol:代替代理  NSString  rac_keyPathComponents 获取一个路径所有的部分 rac_keyPathByDeletingLastKeyPathComponent 删除路径最后一部分 rac_keyPathByDeletingFirstKeyPathComponent 删除路径第一部分 rac_readContentsOfURL: usedEncoding: scheduler: 比之OC多线程调用 rac_sequence  NSURLConnection  rac_sendAsynchronousRequest 发起异步请求  NSUserDefaults  rac_channelTerminalForKey 用于双向绑定，此乃一  NSEnumerator  rac_sequence  NSIndexSet  rac_sequence  NSOrderedSet  rac_sequence  NSSet  rac_sequence  RAC图片版的API手册 ReactiveCocoa Objective-C ReactiveCocoa Swift RXSwift 本文参考整理自  ReactiveCocoa Tutorial – The Definitive Introduction: Part 1/2 https://www.raywenderlich.com/62699/reactivecocoa-tutorial-pt1 ReactiveCocoa Tutorial – The Definitive Introduction: Part 2/2 https://www.raywenderlich.com/62796/reactivecocoa-tutorial-pt2 iOS的函数响应型编程 https://www.gitbook.com/book/kevinhm/functionalreactiveprogrammingonios/details ReactiveCocoa Essentials: Understanding and Using RACCommand https://codeblog.shape.dk/blog/2013/12/05/reactivecocoa-essentials-understanding-and-using-raccommand/ iOS ReactiveCocoa 最全常用API整理（可做为手册查询）https://www.cocoachina.com/ios/20160729/17236.html ReactiveCocoa和RXSwift速查表 https://valiantcat.com/2016/07/22/ReactiveCocoa和RXSwift速查表/ ReactiveCocoa中潜在的内存泄漏及解决方案https://tech.meituan.com/potential-memory-leak-in-reactivecocoa.html?from=timeline\u0026amp;isappinstalled=0 ming1016  ","title":"iOS函数响应式编程以及ReactiveCocoa的使用"},{"link":"https://blog.policx.com/posts/gpu/","text":"   Shader着色器 Shader出现在OpenGL ES 2.0中，允许创建自己的Shader。必须同时创建两个Shader，分别是Vertex shader和Fragment shader.\nShader工具 Shader会有很多坑，不过一些工具能够帮助你跳过这些坑\n GPUImage：https://github.com/BradLarson/GPUImage ShaderToy：https://www.shadertoy.com/ Shaderific：https://www.shaderific.com/ Quartz Composer：官方工具  Shader使用范例 Vertex shader attribute vec4 position; attribute vec4 inputTextureCoordinate； varying vec2 textureCoordinate; void main() { gl_position = position; textureCoordinate = inputTextureCoordinate.xy; } Fragment shader 直通滤镜\nvarying highp vec2 textureCoordinate; //highp属性负责变量精度，这个被加入可以提高效率 uniform sampler2D inputImageTexture; //接收一个图片的引用，当做2D的纹理，这个数据类型就是smpler2D。 void main() { gl_FragColor = texture2D(inputImageTexture, textureCoordinate); //texture是GLSL（着色语言）特有的方法 } GLSL着色语言 GLSL的官方快速入门指导  OpenGL ES：https://www.khronos.org/opengles/sdk/docs/reference_cards/OpenGL-ES-2_0-Reference-card.pdf OpenGL：https://www.khronos.org/files/opengl-quick-reference-card.pdf  变量赋值 三个可以赋值给我们的变量的标签\n Uniforms：在渲染循环里作为不变的输入值 Attributes：随顶点位置不同会变的输入值 Varyings：用来在Vertex shader和Fragment shader之间传递信息的，比如在Vertex shader中写入varying值，然后就可以在Fragment shader中读取和处理  向量 有很多种向量，但是有三种会经常看到\n vec2：两个浮点数，适合在Fragment shader中保存X和Y坐标的情况 vec3：三个浮点数 vec4：四个浮点数，在图像处理中持续追踪每个像素的R,G,V,A这四个值。  矩阵 是浮点数组的数组。三个经常处理的矩阵对象\n mat2：相当于保存了两个vec2对象的值或四个浮点数。 mat3 mat4  向量和矩阵运算 线性代数发挥作用的地方。想知道线性代数如何工作可以看这个资源站：https://betterexplained.com/articles/linear-algebra-guide/\n线性代数可以一次在很多值上进行并行操作，so，正好适合需求，GLSL内建了很多函数可以处理庞大的计算转换\nGLSL特有函数 GLSL内建的函数可以在Shaderific网站上找到：https://www.shaderific.com/glsl-functions。很多C语言数学库基本数学运算都有对应的函数。\n step()：GPU处理条件逻辑不是很好。step()允许在不产生分支的前提下实现条件逻辑。传入step()函数的值小于阈值就返回0.0，大于等于阈值就返回1.0。 mix()：将两个颜色值混合为一个。 clamp()：可以确保值在一个区间内。  复杂的Shader的例子 一个饱和度调节的Fragment shader的例子，出自《图形着色器：理论和实践》这本书。\nvarying highp vec2 textureCoordinate; // uniform sampler2D inputImageTexture; uniform lowp float saturation; const mediump vec3 luminanceWeighting = vec3(0.2125, 0.7154, 0.0721); //光亮度里三个值相加要为1，各个值代表着颜色的百分比，中间是绿色的值，70%的比重会让效果更好点。 void main() { lowp vec4 textureColor = texture2D(inputImageTexture, textureCoordinate); //根据坐标取样图片颜色信息 lowp float luminance = dot(textureColor.rgb, luminanceWeighting); //GLSL中的点乘运算，线性代数的点运算符相乘两个数字。点乘计算需要将纹理颜色信息和相对应的亮度权重相乘。然后取出所有的三个值相加到一起计算得到这个像素的中和亮度值。 lowp vec3 greyScaleColor = vec3(luminance); //创建一个三个值都是亮度信息的vec3，如果只指定一个值，编译器会将其它的都设置成这个值 gl_FragColor = vec4(mix(greyScaleColor, textureColor.rgb, saturation), textureColor.w); //用mix函数把计算的灰度值，初识的纹理颜色和得到的饱和度信息结合起来。 } 球形滤镜示例 varying highp vec2 textureCoordinate; uniform sampler2D inputImageTexture; uniform highp vec2 center; uniform highp float radius; uniform highp float aspectRatio; uniform highp float refractiveIndex; void main() { highp vec2 textureCoordinateToUse = vec2(textureCoordinate.x, (textureCoordinate.y * aspectRatio + 0.5 - 0.5 * aspectRatio)); //归一化坐标空间需要考虑屏幕是一个单位宽和一个单位长。 highp float distanceFromCenter = distance(center, textureCoordinateToUse); //计算特定像素点距离球形的中心有多远。使用GLSL内建的distance()函数，用勾股定律计算出中心坐标和长宽比矫正过的纹理坐标的距离 lowp float checkForPresenceWithinSphere = step(distanceFromCenter, radius); //计算片段是否在球体内。 distanceFromCenter = distanceFromCenter / radius; //标准化到球心的距离，重新设置distanceFromCenter highp float normalizedDepth = radius * sqrt(1.0 - distanceFromCenter * distanceFromCenter); //模拟一个玻璃球，需要计算球的“深度”是多少。 highp vec3 sphereNormal = normalize(vec3(textureCoordinateToUse - center, normalizedDepth)); //归一化 highp vec3 refractedVector = refract(vec3(0.0, 0.0, -1.0), sphereNormal, refractiveIndex); //GLSL的refract()函数以刚才创建的球法线和折射率来计算当光线通过球时从任意一个点看起来如何。 gl_FragColor = texture2D(inputImageTexture, (refractedVector.xy + 1.0) * 0.5) * checkForPresenceWithinSphere; //最后凑齐所有计算需要的颜色信息。 } 调试Shader 使用gl_FragColor调试代码。GPUImage是个开源的资源有些很酷的shader，非常好的学习shader的方式，可以拿一个你觉得很有意思的shader对着源码一点点看下去。GPUImage还有一个shader设计器https://github.com/BradLarson/GPUImage/tree/master/examples/Mac/ShaderDesigner 的Mac应用，可以测试shader而不用准备OpenGL代码。\n性能调优 简单的方法达到调优目的，可以用下载Imagination Technologies PowerVR SDKhttps://community.imgtec.com/developers/powervr/这个工具帮助分析shader\n 消除条件逻辑：使用step()这样的函数 减少依赖纹理的读取：如果希望从附近像素取样而不是计算Fragment shader相邻像素的偏差，最好在Vertex shader中计算然后把结果以varying的方式传入Fragment shader里。 计算尽量简单：能够得到一个近似值就尽量用，不要用类似sin()，cos()，tan()的比较消耗的操作。 尽可能的将计算放到Vertex上：如果计算在图片上会有相同的结果或线性变化最好这样做。因为Vertex shader对每个顶点运行一次，而Fragment shader会在每个像素上运行一次。 移动设备使用合适的精度：在向量上使用低精度的值会变得更快。两个lowp vec4相加可以在一个时钟周期内完成，两个highp vec4相加则需要四个时钟周期。  边界探测 基于OpenCV库，不过这些步骤在GPUImage中都有完整的实现\nSobel边界探测 这种操作在滤镜方面比机器视觉方面多。Sobel边界探测用于探测边界的出现位置，边界是由明变暗或者由暗变明的区域。在被处理的图片中一个像素的亮度反映了这个像素周围边界的强度。\n 第一步，将彩色图片弄成灰阶图，这个过程就是将每个像素的红绿蓝部分合一代表亮度的值。如是果YUV而不是RGB格式的可以省略这步，因为YUV是将亮度信息和色度信息分开的。如果简化到只剩亮度的话一个像素周围的边界强度就可以由周围3*3个临近像素计算得到。这个计算涉及Convolution Matrix（卷积矩阵），每个像素都要与这个矩阵计算出一个数值，因为没有顺序要求所以可以采取并行运算。 Sobel的水平处理矩阵  -1 0 +1 -2 0 +2 -1 0 +1\n Sobel的垂直矩阵  -1 -2 -1 0 0 0 +1 +2 +1\n 和Sobel类似的变体，Prewitt边界探测。这个变体会在横向竖向矩阵中用不同的矩阵，但是运作过程差不多。 OpenGL ES代码   precision mediump float; //varying的都是在Vertex shader上定义了 varying vec2 textureCoordinate; varying vec2 leftTextureCoordinate; varying vec2 rightTextureCoordinate; varying vec2 topTextureCoordinate; varying vec2 topLeftTextureCoordinate; varying vec2 topRightTextureCoordinate; varying vec2 bottomTextureCoordinate; varying vec2 bottomLeftTextureCoordinate; varying vec2 bottomRightTextureCoordinate; uniform sampler2D inputImageTexture; void main() { float bottomLeftIntensity = texture2D(inputImageTexture, bottomLeftTextureCoordinate).r; float topRightIntensity = texture2D(inputImageTexture, topRightTextureCoordinate).r; float topLeftIntensity = texture2D(inputImageTexture, topLeftTextureCoordinate).r; float bottomRightIntensity = texture2D(inputImageTexture, bottomRightTextureCoordinate).r; float leftIntensity = texture2D(inputImageTexture, leftTextureCoordinate).r; float rightIntensity = texture2D(inputImageTexture, rightTextureCoordinate).r; float bottomIntensity = texture2D(inputImageTexture, bottomTextureCoordinate).r; float topIntensity = texture2D(inputImageTexture, topTextureCoordinate).r; float h = -bottomLeftIntensity - 2.0 * leftIntensity - topLeftIntensity + bottomRightIntensity + 2.0 * rightIntensity + topRightIntensity; float v = -topLeftIntensity - 2.0 * topIntensity - topRightIntensity + bottomLeftIntensity + 2.0 * bottomIntensity + bottomRightIntensity; float mag = length(vec2(h, v)); //length()函数计算出水平和垂直矩阵转化后值的平方和的平方根的值，这个值会被拷贝进输出像素的红绿蓝通道中，这样就可以来代表边界的明显程度了。 gl_FragColor = vec4(vec3(mag), 1.0); } Canny边界探测 Canny探测会比Sobel复杂些，这样做会得到一条物体边界的干净线条。\n探测过程：\n 先用Sobel矩阵得到边界梯度的强度。这个和Sobel比就是最后一个计算有些不同  vec2 gradientDirection; gradientDirection.x = -bottomLeftIntensity - 2.0 * leftIntensity - topLeftIntensity + bottomRightIntensity + 2.0 * rightIntensity + topRightIntensity; gradientDirection.y = -topLeftIntensity - 2.0 * topIntensity - topRightIntensity + bottomLeftIntensity + 2.0 * bottomIntensity + bottomRightIntensity; float gradientMagnitude = length(gradientDirection); vec2 normalizedDirection = normalize(gradientDirection); normalizedDirection = sign(normalizedDirection) * floor(abs(normalizedDirection) + 0.617316); // Offset by 1-sin(pi/8) to set to 0 if near axis, 1 if away normalizedDirection = (normalizedDirection + 1.0) * 0.5; // Place -1.0 - 1.0 within 0 - 1.0 gl_FragColor = vec4(gradientMagnitude, normalizedDirection.x, normalizedDirection.y, 1.0);  着色器步骤  precision mediump float; varying highp vec2 textureCoordinate; uniform sampler2D inputImageTexture; uniform highp float texelWidth; //要处理的图片中临近像素之间的距离。 uniform highp float texelHeight; //同上 uniform mediump float upperThreshold; //预期边界强度上下限 uniform mediump float lowerThreshold; void main() { vec3 currentGradientAndDirection = texture2D(inputImageTexture, textureCoordinate).rgb; vec2 gradientDirection = ((currentGradientAndDirection.gb * 2.0) - 1.0) * vec2(texelWidth, texelHeight); float firstSampledGradientMagnitude = texture2D(inputImageTexture, textureCoordinate + gradientDirection).r; float secondSampledGradientMagnitude = texture2D(inputImageTexture, textureCoordinate - gradientDirection).r; float multiplier = step(firstSampledGradientMagnitude, currentGradientAndDirection.r); multiplier = multiplier * step(secondSampledGradientMagnitude, currentGradientAndDirection.r); float thresholdCompliance = smoothstep(lowerThreshold, upperThreshold, currentGradientAndDirection.r); multiplier = multiplier * thresholdCompliance; gl_FragColor = vec4(multiplier, multiplier, multiplier, 1.0); } Harris边角探测 多步骤的方法来探测场景中的边角。\n 先弄得只有亮度信息，再通过Sobel矩阵，普里维特矩阵或者其它相关的矩阵计算出一个像素X和Y方向的梯度值，计算的结果会将X梯度传入红色部分，Y梯度传入绿色部分，X与Y梯度的乘积传入蓝色部分。 对计算的结果进行高斯模糊。将模糊后图中取出红绿蓝编码的值带到计算边角点可能性公式：  R = Ix2 × Iy2 − Ixy × Ixy − k × (Ix2 + Iy2)2\n#资料\n相关数学  3D Math Primer for Graphics and Game Development https://www.amazon.com/Math-Primer-Graphics-Game-Development/dp/1568817231/ref=sr_1_1?ie=UTF8\u0026amp;qid=1422837187\u0026amp;sr=8-1\u0026amp;keywords=3d+math+primer+for+graphics+and+game+development The Nature of Code https://natureofcode.com/ The Computational Beauty of Nature https://www.amazon.com/Computational-Beauty-Nature-Explorations-Adaptation/dp/0262561271/ref=sr_1_1?s=books\u0026amp;ie=UTF8\u0026amp;qid=1422837256\u0026amp;sr=1-1\u0026amp;keywords=computational+beauty+of+nature  相关GLSL  Graphic Shaders: Theory and Practice https://www.amazon.com/Graphics-Shaders-Theory-Practice-Second/dp/1568814348/ref=sr_1_1?s=books\u0026amp;ie=UTF8\u0026amp;qid=1422837351\u0026amp;sr=1-1\u0026amp;keywords=graphics+shaders+theory+and+practice The OpenGL Shading Language https://www.amazon.com/OpenGL-Shading-Language-Randi-Rost/dp/0321637631/ref=sr_1_1?s=books\u0026amp;ie=UTF8\u0026amp;qid=1422896457\u0026amp;sr=1-1\u0026amp;keywords=opengl+shading+language OpenGL 4 Shading Language Cookbook https://www.amazon.com/OpenGL-Shading-Language-Cookbook-Second/dp/1782167021/ref=sr_1_2?s=books\u0026amp;ie=UTF8\u0026amp;qid=1422896457\u0026amp;sr=1-2\u0026amp;keywords=opengl+shading+language GPU Gems https://http.developer.nvidia.com/GPUGems/gpugems_part01.html GPU Pro: Advanced Rendering Techniques https://www.amazon.com/GPU-Pro-Advanced-Rendering-Techniques/dp/1568814720/ref=sr_1_4?s=books\u0026amp;ie=UTF8\u0026amp;qid=1422837427\u0026amp;sr=1-4\u0026amp;keywords=gpu+pro  ming1016\n","title":"GPU处理图像"},{"link":"https://blog.policx.com/posts/camera/","text":"   相机原理 感光度(ISO) ISO也叫胶卷速度，衡量图像传感器对光的敏感程度。亮的时候需要的ISO就越小，暗的时候相反ISO就高噪点会多。\n光圈 光圈用来衡量到达图像感应器的光所通过的通孔大小。iPhone6的光圈值是f/2.2，2.2就是表示镜头焦距和光圈的有效直径比例。\n对焦 将离相机一定范围内物体渲染清晰，太近太远会模糊这种情况叫做失焦。\n保存获取文件 关于Core Image处理RAW格式可以参考CoreImage/CIRAWFilter.h，以及WWDC上的讲座WWDC 2014 session 514 https://developer.apple.com/videos/wwdc/2014/#514\n如何处理图像数据 处理位图的类是UIImage，CGImage(Core Graphics)和CIImage(Core Image)。从NSData得到UIImage使用imageWithContentsOfFiles:方法。\n从相机捕捉图像  相比较UIImagePickerController使用AVFoundation能够直接访问相机，提供完全的操作权，比如用编程方式更改硬件参数，或者操纵实时预览图。 先创建AVCaptureStillImageOutput对象，使用captureStillImageAsynchronouslyFromConnection: completionHandler: 方法。 使用AVCaptureStillImageOutput中的类方法jpegStillImageNSDataRepresentation:将其转换成NSData对象，接着用imageWithData:得到一个UIImage 过程中可以调节很多参数例如曝光，聚焦，光补偿，闪光灯，ISO等。所有这些设置都会被应用到一个AVCaptureDevice里。  AVFoundation相关类 可以通过以下类访问来自相机设备原始数据并控制他们的组件。\n AVCaptureDevice：控制硬件特性，比如镜头位置，曝光，闪光灯 AVCaptureDeviceInput：设备数据 AVCaptureOutput：抽象类包括了三种静态图片捕捉类   AVCaptureStillImageOutput：用于捕捉静态图片     AVCaptureMetadataOutput：启用检测人脸和二维码     AVCaptureVideoOutput：实时预览图提供原始帧   AVCaptureSession：管理输入输出之间数据流，以及在出现问题时生成运行时错误。 AVCaptureVideoPreviewLayer：CALayer的子类，用于自动显示相机产生的实时图像，  捕捉设置 //先需要一个AVCaptureSession对象 let session = AVCaptureSession() //接着遍历所能提供视频数据设备并检查position属性。 let availableCameraDevices = AVCaptureDevice.devicesWithMediaType(AVMediaTypeVideo) for device in availableCameraDevices as [AVCaptureDevice] { if device.position == .Back { backCameraDevice = device } else if device.position == .Front { frontCameraDevice = device } } //发现合适的相机设备，就可以获得相关的AVCaptureDeviceInput对象。将它设置为session输入： var error:NSError? let possibleCameraInput: AnyObject? = AVCaptureDeviceInput.deviceInputWithDevice(backCameraDevice, error: \u0026amp;error) if let backCameraInput = possibleCameraInput as? AVCaptureDeviceInput { if self.session.canAddInput(backCameraInput) { self.session.addInput(backCameraInput) } } //第一次调用AVCaptureDeviceInput.deviceInputWithDevice()会出发系统提示，向用户请求访问相机。 let authorizationStatus = AVCaptureDevice.authorizationStatusForMediaType(AVMediaTypeVideo) switch authorizationStatus { case .NotDetermined: // 许可对话没有出现，发起授权许可 AVCaptureDevice.requestAccessForMediaType(AVMediaTypeVideo, completionHandler: { (granted:Bool) -\u0026gt; Void in if granted { // 继续 } else { // 用户拒绝，无法继续 } }) case .Authorized: // 继续 case .Denied, .Restricted: // 用户明确地拒绝授权，或者相机设备无法访问 } //允许访问后的处理，有两种方法显示来自相机的图像流。 //第一种，生成一个带有AVCaptureVideoPreviewLayer的view。用capture session做初始参数。AVCaptureVideoPreviewLayer会自动的显示来自相机输出 previewLayer = AVCaptureVideoPreviewLayer.layerWithSession(session) as AVCaptureVideoPreviewLayer previewLayer.frame = view.bounds view.layer.addSublayer(previewLayer) //第二种，从输出数据流捕捉单一图像帧，使用OpenGL手动显示在view上。这种方法适用于想实时预览滤镜效果的情况。 glContext = EAGLContext(API: .OpenGLES2) // glView = GLKView(frame: viewFrame, context: glContext) ciContext = CIContext(EAGLContext: glContext) //AVCaptureVideoOutput videoOutput = AVCaptureVideoDataOutput() videoOutput.setSampleBufferDelegate(self, queue: dispatch_queue_create(\u0026quot;sample buffer delegate\u0026quot;, DISPATCH_QUEUE_SERIAL)) if session.canAddOutput(self.videoOutput) { session.addOutput(self.videoOutput) } //创建完AVCaptureVideoDataOutput后需要通过代理captureOutput(_:didOutputSampleBuffer:fromConnection:)获得所有图像帧，将他们绘制在GLKView中。 func captureOutput(captureOutput: AVCaptureOutput!, didOutputSampleBuffer sampleBuffer: CMSampleBuffer!, fromConnection connection: AVCaptureConnection!) { let pixelBuffer = CMSampleBufferGetImageBuffer(sampleBuffer) let image = CIImage(CVPixelBuffer: pixelBuffer) if glContext != EAGLContext.currentContext() { EAGLContext.setCurrentContext(glContext) } glView.bindDrawable() ciContext.drawImage(image, inRect:image.extent(), fromRect: image.extent()) glView.display() } //注意的问题， AVCaptureVideoPreviewLayer会自动处理样本旋转90度的情况。 //使用AVCaptureStillImageOutput捕捉静态图片。 stillCameraOutput = AVCaptureStillImageOutput() if self.session.canAddOutput(self.stillCameraOutput) { self.session.addOutput(self.stillCameraOutput) } //配置，为对象找最合适的配置。有两个方法，简单的方法是使用session preset session.sessionPreset = AVCaptureSessionPresetPhoto //AVCaptureSessionPresetPhoto会为照片捕捉选择最合适的配置，允许使用最高的感光度（ISO）和曝光时间。基于相位检测（phase detection）的自动对焦，以及输出全分辨率的JPEG格式压缩的静态图片。使用AVCaptureDeviceFormat这个类可以有更多的操控，比如静态分辨率，视频预览分辨率，自动对焦类型，感光度和曝光时间限制，支持格式都在AVCaptureDevice.formats中，可以赋值给AVCaptureDevice的activeFormat。 操作相机 到了iOS8后可以对所有参数进行手动调整了。包括镜头光圈。\n//先启动相机 sessionQueue = dispatch_queue_create(\u0026quot;com.example.camera.capture_session\u0026quot;, DISPATCH_QUEUE_SERIAL) dispatch_async(sessionQueue) { () -\u0026gt; Void in self.session.startRunning() } //建议将所有block调用操作和配置分配到后台串行队列中。在相机设备改变一些参数前先锁定，改完再解锁 var error:NSError? if currentDevice.lockForConfiguration(\u0026amp;error) { // 锁定成功，继续配置 // currentDevice.unlockForConfiguration() } else { // 出错，相机可能已经被锁 } 对焦 AVCaptureFocusMode枚举描述可用对焦模式\n locked：镜片固定位置 AutoFocus：先自动对焦一次就处于Locked模式 ContinuousAutoFocus：场景改变自动重新对焦到画面中心点  对焦可以使用UISlider设置，类似单反对焦环。手动对焦有个辅助标识指向清晰区域，可以通过对焦峰值（focus peaking）将对焦区域高亮显示的方式，方法是使用阈值边缘（threshold edge）滤镜，自定义CIFilter或GPUImageThresholdEdgeDetectionFilter，并调用AVCaptureAudioDataOutputSampleBufferDelegate下的captureOutput(_:didOutputSampleBuffer:fromConnection:)方法将它覆盖到实时预览图上。\n//设置对焦模式需要在锁定后 let focusMode:AVCaptureFocusMode = ... if currentCameraDevice.isFocusModeSupported(focusMode) { ... // 锁定以进行配置 currentCameraDevice.focusMode = focusMode ... // 解锁 } //AutoFocus会让屏幕中心为清晰区，也可以通过预览图上点击手势改变这个区域。 var pointInPreview = focusTapGR.locationInView(focusTapGR.view) var pointInCamera = previewLayer.captureDevicePointOfInterestForPoint(pointInPreview) ...// 锁定，配置 // 设置感兴趣的点 currentCameraDevice.focusPointOfInterest = pointInCamera // 在设置的点上切换成自动对焦 currentCameraDevice.focusMode = .AutoFocus ...// 解锁 //iOS8中可以通过选项移动镜片的位置 ... // 锁定，配置 var lensPosition:Float = ... // 0.0 到 1.0的float currentCameraDevice.setFocusModeLockedWithLensPosition(lensPosition) { (timestamp:CMTime) -\u0026gt; Void in // timestamp 对应于应用了镜片位置的第一张图像缓存区 } ... // 解锁 曝光 曝光档数范围在minExposureTargetBias和maxExposureTargetBias之间。0为默认没有补偿\nvar exposureBias:Float = ... // 在 minExposureTargetBias 和 maxExposureTargetBias 之间的值 ... // 锁定，配置 currentDevice.setExposureTargetBias(exposureBias) { (time:CMTime) -\u0026gt; Void in } ... // 解锁 //设置ISO和曝光时间 var activeFormat = currentDevice.activeFormat var duration:CTime = ... //在activeFormat.minExposureDuration 和 activeFormat.maxExposureDuration 之间的值，或用 AVCaptureExposureDurationCurrent 表示不变 var iso:Float = ... // 在 activeFormat.minISO 和 activeFormat.maxISO 之间的值，或用 AVCaptureISOCurrent 表示不变 ... // 锁定，配置 currentDevice.setExposureModeCustomWithDuration(duration, ISO: iso) { (time:CMTime) -\u0026gt; Void in } ... // 解锁 //检验曝光是否准确可以通过KVO观察AVCaptureDevice的exposureTargetOffset属性。 白平衡 iOS8可以手动控制白平衡。可以通过开尔文所表示的温度来调节色温和色彩。典型色温值在2000-3000K（类似蜡烛或灯泡的暖光源）到8000K（纯净的蓝色天空）之间。色彩范围从最小的-150（偏绿）到150（偏品红）。\nvar incandescentLightCompensation = 3_000 var tint = 0 // 不调节 let temperatureAndTintValues = AVCaptureWhiteBalanceTemperatureAndTintValues(temperature: incandescentLightCompensation, tint: tint) var deviceGains = currentCameraDevice.deviceWhiteBalanceGainsForTemperatureAndTintValues(temperatureAndTintValues) ... // 锁定，配置 currentCameraDevice.setWhiteBalanceModeLockedWithDeviceWhiteBalanceGains(deviceGains) { (timestamp:CMTime) -\u0026gt; Void in } } ... // 解锁 实时人脸检测 使用AVCaptureMetadataOutput可以检测人脸和二维码。\nvar metadataOutput = AVCaptureMetadataOutput() metadataOutput.setMetadataObjectsDelegate(self, queue: self.sessionQueue) if session.canAddOutput(metadataOutput) { session.addOutput(metadataOutput) } metadataOutput.metadataObjectTypes = [AVMetadataObjectTypeFace] func captureOutput(captureOutput: AVCaptureOutput!, didOutputMetadataObjects metadataObjects: [AnyObject]!, fromConnection connection: AVCaptureConnection!) { for metadataObject in metadataObjects as [AVMetadataObject] { if metadataObject.type == AVMetadataObjectTypeFace { var transformedMetadataObject = previewLayer.transformedMetadataObjectForMetadataObject(metadataObject) } } } 捕捉静态图片 捕捉高分辨率图像调用captureStillImageAsynchronouslyFromConnection(connection, completionHandler)。在视觉上反应图片捕捉何时开始以及何时结束可以使用KVO来观察AVCaptureStillImageOutput的isCapturingStillImage属性。\ndispatch_async(sessionQueue) { () -\u0026gt; Void in let connection = self.stillCameraOutput.connectionWithMediaType(AVMediaTypeVideo) // 将视频的旋转与设备同步 connection.videoOrientation = AVCaptureVideoOrientation(rawValue: UIDevice.currentDevice().orientation.rawValue)! self.stillCameraOutput.captureStillImageAsynchronouslyFromConnection(connection) { (imageDataSampleBuffer, error) -\u0026gt; Void in if error == nil { // 如果使用 session .Photo 预设，或者在设备输出设置中明确进行了设置 // 我们就能获得已经压缩为JPEG的数据 let imageData = AVCaptureStillImageOutput.jpegStillImageNSDataRepresentation(imageDataSampleBuffer) // 样本缓冲区也包含元数据，我们甚至可以按需修改它 let metadata:NSDictionary = CMCopyDictionaryOfAttachments(nil, imageDataSampleBuffer, CMAttachmentMode(kCMAttachmentMode_ShouldPropagate)).takeUnretainedValue() if let image = UIImage(data: imageData) { // 保存图片，或者做些其他想做的事情 ... } } else { NSLog(\u0026quot;error while capturing still image: \\(error)\u0026quot;) } } } 分级捕捉 通过设定-1，0，-1三个不同曝光档数用HDR算法合并成一张。\ndispatch_async(sessionQueue) { () -\u0026gt; Void in let connection = self.stillCameraOutput.connectionWithMediaType(AVMediaTypeVideo) connection.videoOrientation = AVCaptureVideoOrientation(rawValue: UIDevice.currentDevice().orientation.rawValue)! var settings = [-1.0, 0.0, 1.0].map { (bias:Float) -\u0026gt; AVCaptureAutoExposureBracketedStillImageSettings in AVCaptureAutoExposureBracketedStillImageSettings.autoExposureSettingsWithExposureTargetBias(bias) } var counter = settings.count self.stillCameraOutput.captureStillImageBracketAsynchronouslyFromConnection(connection, withSettingsArray: settings) { (sampleBuffer, settings, error) -\u0026gt; Void in ... // 保存 sampleBuffer(s) // 当计数为0，捕捉完成 counter-- } } 操作图像 //将两个图片拼接，并在图片上加个区域强调 -(UIImage*)composeStereogramLeft:(UIImage *)leftImage right:(UIImage *)rightImage { float w = leftImage.size.width; float h = leftImage.size.height; UIGraphicsBeginImageContext(CGSizeMake(w * 2.0, h + 32.0)); [leftImage drawAtPoint:CGPointMake(0.0, 32.0)]; [rightImage drawAtPoint:CGPointMake(w, 32.0)]; float leftCircleX = (w / 2.0) - 8.0; float rightCircleX = leftCircleX + w; float circleY = 8.0; [[UIColor blackColor] setFill]; UIRectFill(CGRectMake(0.0, 0.0, w * 2.0, 32.0)); [[UIColor whiteColor] setFill]; CGRect leftRect = CGRectMake(leftCircleX, circleY, 16.0, 16.0); CGRect rightRect = CGRectMake(rightCircleX, circleY, 16.0, 16.0); UIBezierPath *path = [UIBezierPath bezierPathWithOvalInRect:leftRect]; [path appendPath:[UIBezierPath bezierPathWithOvalInRect:rightRect]]; [path fill]; UIImage *savedImg = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return savedImg; } //使用CGBitmapContextCreate创建位图绘制环境，然后可以遍历位图获得各个颜色通道值，维持一张图片中的绿色和蓝色的原值，然后将蓝色和绿色的值按一定方式计算后赋值给另一张图片的红色值。 //可以访问实际像素的所有信息，做任何处理，不过Core Image也会提供一些滤镜方便使用。 UInt8 *rightPtr = rightBitmap; UInt8 *leftPtr = leftBitmap; UInt8 r1, g1, b1; UInt8 r2, g2, b2; UInt8 ra, ga, ba; for (NSUInteger idx = 0; idx \u0026lt; bitmapByteCount; idx += 4) { r1 = rightPtr[0]; g1 = rightPtr[1]; b1 = rightPtr[2]; r2 = leftPtr[0]; g2 = leftPtr[1]; b2 = leftPtr[2]; // r1/g1/b1 右侧图像，用于计算合并值 // r2/g2/b2 左侧图像，用于被合并值赋值 // ra/ga/ba 合并后的像素 ra = 0.7 * g1 + 0.3 * b1; ga = b2; ba = b2; leftPtr[0] = ra; leftPtr[1] = ga; leftPtr[2] = ba; rightPtr += 4; // 指向下一个像素 (4字节, 包括透明度 alpha 值) leftPtr += 4; } CGImageRef composedImage = CGBitmapContextCreateImage(_leftContext); UIImage *retval = [UIImage imageWithCGImage:composedImage]; CGImageRelease(composedImage); return retval; 元数据 存储图像信息的标准格式是Exif（可交换图像文件格式）。通常会保存照相时间日期，快门速度和光圈，设备支持还会包括GPS坐标。可以使用CGImageSourceCopyPropertiesAtIndex方法访问Exif信息。\n\n","title":"Camera"},{"link":"https://blog.policx.com/posts/ios-string/","text":"   搜索 在一个字符串中搜索子字符串  最灵活的方法  - (NSRange)rangeOfString:(NSString *)aString options:(NSStringCompareOptions)mask range:(NSRange)searchRange locale:(NSLocale *)locale 格式化字符串  3个方法  -initWithFormat: -initWithFormat:arguments: +stringWithFormat: 整数  可以同时工作在32位和64位的  uint64_t p = 2305843009213693951; NSString *s = [NSString stringWithFormat:@\u0026quot;The ninth Mersenne prime is %llu\u0026quot;, (unsigned long long) p]; // \u0026quot;The ninth Mersenne prime is 2305843009213693951\u0026quot;    Modifier d, i o, u, x, X     hh signed char unsigned char   h short unsigned short   (none) int unsigned int   l(ell) long unsigned long   j intmax_t uintmax_t   t ptrdiff_t    z  size_t     转换规则  int m = -150004021; uint n = 150004021U; NSString *s = [NSString stringWithFormat:@\u0026quot;d:%d i:%i o:%o u:%u x:%x X:%X\u0026quot;, m, m, n, n, n, n]; // \u0026quot;d:-150004021 i:-150004021 o:1074160465 u:150004021 x:8f0e135 X:8F0E135\u0026quot; //o是八进制  设置最小字段宽度和最小数字位数  int m = 42; NSString *s = [NSString stringWithFormat:@\u0026quot;'%4d' '%-4d' '%+4d' '%4.3d' '%04d'\u0026quot;, m, m, m, m, m]; // \u0026quot;[ 42] [42 ] [ +42] [ 042] [0042]\u0026quot; m = -42; NSString *s = [NSString stringWithFormat:@\u0026quot;'%4d' '%-4d' '%+4d' '%4.3d' '%04d'\u0026quot;, m, m, m, m, m]; // \u0026quot;[ -42] [-42 ] [ -42] [-042] [-042]\u0026quot;  %p可打印指针，和%#x不同的是它可以同时在32位和64位执行  浮点数  使用%f和%g  double v[5] = {12345, 12, 0.12, 0.12345678901234, 0.0000012345678901234}; NSString *s = [NSString stringWithFormat:@\u0026quot;%g %g %g %g %g\u0026quot;, v[0], v[1], v[2], v[3], v[4]]; // \u0026quot;12345 12 0.12 0.123457 1.23457e-06\u0026quot; NSString *s = [NSString stringWithFormat:@\u0026quot;%f %f %f %f %f\u0026quot;, v[0], v[1], v[2], v[3], v[4]]; // \u0026quot;12345.000000 12.000000 0.120000 0.123457 0.000001\u0026quot; 多行文字  使用\\n来  NSString *limerick = @\u0026quot;A lively young damsel named Menzies\\n\u0026quot; @\u0026quot;Inquired: «Do you know what this thenzies?»\\n\u0026quot; @\u0026quot;Her aunt, with a gasp,\\n\u0026quot; @\u0026quot;Replied: \u0026quot;It's a wasp,\\n\u0026quot; @\u0026quot;And you're holding the end where the stenzies.\\n\u0026quot;;  等价写法  NSString *limerick = @\u0026quot;A lively young damsel named Menzies\\nInquired: «Do you know what this thenzies?»\\nHer aunt, with a gasp,\\nReplied: \u0026quot;It's a wasp,\\nAnd you're holding the end where the stenzies.\\n\u0026quot;;  更简洁的方法  NSString * string = @\u0026quot;The man \u0026quot; @\u0026quot;who knows everything \u0026quot; @\u0026quot;learns nothing\u0026quot; @\u0026quot;.\u0026quot;; 替换字符串  NSMutableString的四个方法  -deleteCharactersInRange: -insertString:atIndex: -replaceCharactersInRange:withString: -replaceOccurrencesOfString:withString:options:range:  NSString的方法  -stringByReplacingOccurrencesOfString:withString: -stringByReplacingOccurrencesOfString:withString:options:range: -stringByReplacingCharactersInRange:withString:  NSMutableString不会创建新字符串，性能会好点  NSMutableString *string; // 假设我们已经有了一个名为 string 的字符串 // 现在要去掉它的一个前缀，做法如下: NSString *prefix = @\u0026quot;WeDon’tWantThisPrefix\u0026quot; NSRange r = [string rangeOfString:prefix options:NSAnchoredSearch range:NSMakeRange(0, string.length) locale:nil]; if (r.location != NSNotFound) { [string deleteCharactersInRange:r]; } 连接字符串 NSArray *names = @[\u0026quot;Hildr\u0026quot;, @\u0026quot;Heidrun\u0026quot;, @\u0026quot;Gerd\u0026quot;, @\u0026quot;Guðrún\u0026quot;, @\u0026quot;Freya\u0026quot;, @\u0026quot;Nanna\u0026quot;, @\u0026quot;Siv\u0026quot;, @\u0026quot;Skaði\u0026quot;, @\u0026quot;Gróa\u0026quot;]; NSString *result = [names componentsJoinedByString:@\u0026quot;, \u0026quot;]; 字符串解析 正则表达式 NSError *error = nil; NSString *pattern = @\u0026quot;(\\\\w+) = #(\\\\p{Hex_Digit}{6})\u0026quot;; NSRegularExpression *expression = [NSRegularExpression regularExpressionWithPattern:pattern options:0 error:\u0026amp;error]; NSTextCheckingResult *result = [expression firstMatchInString:string options:0 range:NSMakeRange(0, string.length)]; NSString *key = [string substringWithRange:[result rangeAtIndex:1]]; NSString *value = [string substringWithRange:[result rangeAtIndex:2]]; 将字符串分解成数组，使用componentsSeparatedByString:这个方法，或者enumerateSubstringsInRange:options:usingBlock:。如果是按照行来进行分解可以使用option这个参数传NSStringEnumerationByLines\nNSString *input = @“ backgroundColor = #ff0000 textColor = #0000ff \u0026quot; NSString *pattern = @\u0026quot;(\\\\w+) = #([\\\\da-f]{6})\u0026quot;; NSRegularExpression *expression = [NSRegularExpression regularExpressionWithPattern:pattern options:0 error:NULL]; NSArray *lines = [input componentsSeparatedByCharactersInSet:[NSCharacterSet newlineCharacterSet]]; NSMutableDictionary *result = [NSMutableDictionary dictionary]; for (NSString *line in lines) { NSTextCheckingResult *textCheckingResult = [expression firstMatchInString:line options:0 range:NSMakeRange(0, line.length)]; NSString* key = [line substringWithRange:[textCheckingResult rangeAtIndex:1]]; NSString* value = [line substringWithRange:[textCheckingResult rangeAtIndex:2]]; result[key] = value; } return result; 扫描  NSScanner  NSScanner *scanner = [NSScanner scannerWithString:string]; //默认情况下，扫描器会跳过所有空格符和换行符。但这里我们只希望跳过空格符 scanner.charactersToBeSkipped = [NSCharacterSet whitespaceCharacterSet]; //定义一个十六进制字符集 NSCharacterSet *hexadecimalCharacterSet = [NSCharacterSet characterSetWithCharactersInString:@\u0026quot;0123456789abcdefABCDEF\u0026quot;]; NSMutableDictionary *result = [NSMutableDictionary dictionary]; while (!scanner.isAtEnd) { NSString *key = nil; NSString *value = nil; NSCharacterSet *letters = [NSCharacterSet letterCharacterSet]; BOOL didScan = [scanner scanCharactersFromSet:letters intoString:\u0026amp;key] \u0026amp;\u0026amp; [scanner scanString:@\u0026quot;=\u0026quot; intoString:NULL] \u0026amp;\u0026amp; [scanner scanString:@\u0026quot;#\u0026quot; intoString:NULL] \u0026amp;\u0026amp; [scanner scanCharactersFromSet:hexadecimalCharacterSet intoString:\u0026amp;value] \u0026amp;\u0026amp; value.length == 6; result[key] = value; [scanner scanCharactersFromSet:[NSCharacterSet newlineCharacterSet] intoString:NULL]; // 继续扫描下一行 } return result; 解析器  设计一个能够用(100,0,255)或者#ff0000这样的字符来定义颜色的方法。  - (NSDictionary *)parse:(NSString *)string error:(NSError **)error { self.scanner = [NSScanner scannerWithString:string]; self.scanner.charactersToBeSkipped = [NSCharacterSet whitespaceCharacterSet]; NSMutableDictionary *result = [NSMutableDictionary dictionary]; NSCharacterSet *letters = [NSCharacterSet letterCharacterSet] while (!self.scanner.isAtEnd) { NSString *key = nil; UIColor *value = nil; BOOL didScan = [self.scanner scanCharactersFromSet:letters intoString:\u0026amp;key] \u0026amp;\u0026amp; [self.scanner scanString:@\u0026quot;=\u0026quot; intoString:NULL] \u0026amp;\u0026amp; [self scanColor:\u0026amp;value]; result[key] = value; [self.scanner scanCharactersFromSet:[NSCharacterSet newlineCharacterSet] intoString:NULL]; // 继续扫描下一行 } } - (BOOL)scanColor:(UIColor **)out { return [self scanHexColorIntoColor:out] || [self scanTupleColorIntoColor:out]; } //扫描设置#ff0000这样的 - (BOOL)scanHexColorIntoColor:(UIColor **)out { NSCharacterSet *hexadecimalCharacterSet = [NSCharacterSet characterSetWithCharactersInString:@\u0026quot;0123456789abcdefABCDEF\u0026quot;]; NSString *colorString = NULL; if ([self.scanner scanString:@\u0026quot;#\u0026quot; intoString:NULL] \u0026amp;\u0026amp; [self.scanner scanCharactersFromSet:hexadecimalCharacterSet intoString:\u0026amp;colorString] \u0026amp;\u0026amp; colorString.length == 6) { *out = [UIColor colorWithHexString:colorString]; return YES; } return NO; } - (BOOL)scanTupleColorIntoColor:(UIColor **)out { NSInteger red, green, blue = 0; BOOL didScan = [self.scanner scanString:@\u0026quot;(\u0026quot; intoString:NULL] \u0026amp;\u0026amp; [self.scanner scanInteger:\u0026amp;red] \u0026amp;\u0026amp; [self.scanner scanString:@\u0026quot;,\u0026quot; intoString:NULL] \u0026amp;\u0026amp; [self.scanner scanInteger:\u0026amp;green] \u0026amp;\u0026amp; [self.scanner scanString:@\u0026quot;,\u0026quot; intoString:NULL] \u0026amp;\u0026amp; [self.scanner scanInteger:\u0026amp;blue] \u0026amp;\u0026amp; [self.scanner scanString:@\u0026quot;)\u0026quot; intoString:NULL]; if (didScan) { *out = [UIColor colorWithRed:(CGFloat)red/255. green:(CGFloat)green/255. blue:(CGFloat)blue/255. alpha:1]; return YES; } else { return NO; } } 符号化处理 先进星扫描，使用NSScanner来解析这个表达式\nmyView.left = otherView.right * 2 + 10 viewController.view.centerX + myConstant \u0026lt;= self.view.centerX NSScanner *scanner = [NSScanner scannerWithString:contents]; NSMutableArray *tokens = [NSMutableArray array]; while (![scanner isAtEnd]) { for (NSString *operator in @[@\u0026quot;=\u0026quot;, @\u0026quot;+\u0026quot;, @\u0026quot;*\u0026quot;, @\u0026quot;\u0026gt;=\u0026quot;, @\u0026quot;\u0026lt;=\u0026quot;, @\u0026quot;.\u0026quot;]) { if ([scanner scanString:operator intoString:NULL]) { [tokens addObject:operator]; } } } //接下来识别非符号的只包含字母的string NSString *result = nil; if ([scanner scanCharactersFromSet:[NSCharacterSet letterCharacterSet] intoString:\u0026amp;result]) { [tokens addObject:result]; } //NSScanner有scanDouble:来扫描double double doubleResult = 0; if ([scanner scanDouble:\u0026amp;doubleResult]) { [tokens addObject:@(doubleResult)]; } //完成后用将需要解析的表达式放入试试 NSString* example = @\u0026quot;myConstant = 100\\n\u0026quot; @\u0026quot;\\nmyView.left = otherView.right * 2 + 10\\n\u0026quot; @\u0026quot;viewController.view.centerX + myConstant \u0026lt;= self.view.centerX\u0026quot;; NSArray *result = [self.scanner tokenize:example]; NSArray *expected = @[@\u0026quot;myConstant\u0026quot;, @\u0026quot;=\u0026quot;, @100, @\u0026quot;myView\u0026quot;, @\u0026quot;.\u0026quot;, @\u0026quot;left\u0026quot;, @\u0026quot;=\u0026quot;, @\u0026quot;otherView\u0026quot;, @\u0026quot;.\u0026quot;, @\u0026quot;right\u0026quot;, @\u0026quot;*\u0026quot;, @2, @\u0026quot;+\u0026quot;, @10, @\u0026quot;viewController\u0026quot;, @\u0026quot;.\u0026quot;, @\u0026quot;view\u0026quot;, @\u0026quot;.\u0026quot;, @\u0026quot;centerX\u0026quot;, @\u0026quot;+\u0026quot;, @\u0026quot;myConstant\u0026quot;, @\u0026quot;\u0026lt;=\u0026quot;, @\u0026quot;self\u0026quot;, @\u0026quot;.\u0026quot;, @\u0026quot;view\u0026quot;, @\u0026quot;.\u0026quot;, @\u0026quot;centerX\u0026quot;]; XCTAssertEqualObjects(result, expected); 进行语法解析，需要语法分析库描述我们的语言。下面代码就是为那个布局约束语言写的解析语法，用的扩展的巴科斯范式EBNF写法：\nconstraint = expression comparator expression comparator = \u0026quot;=\u0026quot; | \u0026quot;\u0026gt;=\u0026quot; | \u0026quot;\u0026lt;=\u0026quot; expression = keyPath \u0026quot;.\u0026quot; attribute addMultiplier addConstant keyPath = identifier | identifier \u0026quot;.\u0026quot; keyPath attribute = \u0026quot;left\u0026quot; | \u0026quot;right\u0026quot; | \u0026quot;top\u0026quot; | \u0026quot;bottom\u0026quot; | \u0026quot;leading\u0026quot; | \u0026quot;trailing\u0026quot; | \u0026quot;width\u0026quot; | \u0026quot;height\u0026quot; | \u0026quot;centerX\u0026quot; | \u0026quot;centerY\u0026quot; | \u0026quot;baseline\u0026quot; addMultiplier = \u0026quot;*\u0026quot; atom addConstant = \u0026quot;+\u0026quot; atom atom = number | identifier 还有很多Objective-C的语法解析，更多的可以在CocoaPods上找到：https://cocoapods.org/?q=parse。比较好的就是CoreParse，地址：https://github.com/beelsebob/CoreParse，但是需要使用它支持的语法。下面就是CoreParse支持的格式：\nNSString* grammarString = [@[ @\u0026quot;Atom ::= num@'Number' | ident@'Identifier';\u0026quot;, @\u0026quot;Constant ::= name@'Identifier' '=' value@\u0026lt;Atom\u0026gt;;\u0026quot;, @\u0026quot;Relation ::= '=' | '\u0026gt;=' | '\u0026lt;=';\u0026quot;, @\u0026quot;Attribute ::= 'left' | 'right' | 'top' | 'bottom' | 'leading' | 'trailing' | 'width' | 'height' | 'centerX' | 'centerY' | 'baseline';\u0026quot;, @\u0026quot;Multiplier ::= '*' num@'Number';\u0026quot;, @\u0026quot;AddConstant ::= '+' num@'Number';\u0026quot;, @\u0026quot;KeypathAndAttribute ::= 'Identifier' '.' \u0026lt;AttributeOrRest\u0026gt;;\u0026quot;, @\u0026quot;AttributeOrRest ::= att@\u0026lt;Attribute\u0026gt; | 'Identifier' '.' \u0026lt;AttributeOrRest\u0026gt;;\u0026quot;, @\u0026quot;Expression ::= \u0026lt;KeypathAndAttribute\u0026gt; \u0026lt;Multiplier\u0026gt;? \u0026lt;AddConstant\u0026gt;?;\u0026quot;, @\u0026quot;LayoutConstraint ::= lhs@\u0026lt;Expression\u0026gt; rel@\u0026lt;Relation\u0026gt; rhs@\u0026lt;Expression\u0026gt;;\u0026quot;, @\u0026quot;Rule ::= \u0026lt;Atom\u0026gt; | \u0026lt;LayoutConstraint\u0026gt;;\u0026quot;, ] componentsJoinedByString:@\u0026quot;\\n\u0026quot;]; 一个规则匹配后解析器就找到同样名称的类\n- (id)parser:(CPParser *)parser didProduceSyntaxTree:(CPSyntaxTree *)syntaxTree NSString *ruleName = syntaxTree.rule.name; if ([ruleName isEqualToString:@\u0026quot;Attribute\u0026quot;]) { return self.layoutAttributes[[[syntaxTree childAtIndex:0] keyword]]; } ... } 完整的解析器代码在：https://github.com/objcio/issue-9-string-parsing。里面有个解析类可以用来解析复杂的布局约束，如下：\nviewController.view.centerX + 20 \u0026lt;= self.view.centerX * 0.5 可以得到如下结果，方便转换成NSLayoutConstraint对象\n(\u0026lt;Expression: self.keyPath=(viewController, view), self.attribute=9, self.multiplier=1, self.constant=20\u0026gt; -1 \u0026lt;Expression: self.keyPath=(self, view), self.attribute=9, self.multiplier=0.5, self.constant=0\u0026gt;) 字符串的渲染 UILabel  label默认显示一行，如果设置numberOfLines为大于1的话可以显示指定行数，如果设置为0，则多少行都显示 attributedText属性可以显示富文本 label的font,textColor,textAlignment,shadowColor和shadowOffset属性可以改变外观。 改变程序内所有Label的风格，可以使用[UILabel appearance]方法  UITextField  text field只限于单行 UITextfield实现了UITextInputTraits协议，这个协议需要指定键盘外观和操作等细节。比如显示什么键盘和返回按键响应等 可以通过设置左右辅助视图，或者设置背景来自定义输入框风格了。  UITextView  相比较UITextField，它能够处理多行文本 可以使用定制Text Kit，官方文档：https://developer.apple.com/Library/ios/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/CustomTextProcessing/CustomTextProcessing.html 可以为layout manager，text container或text storage自定义行为或替换自定义子类。 在iOS7之前是基于WebKit的功能少，之后会有很多不同具体可以参考这两篇文章：Peter的https://petersteinberger.com/blog/2014/fixing-uitextview-on-ios-7/，Brent的https://inessential.com/2014/01/07/uitextview_the_solution  TableView中显示动态文本 Table view的Delegate有个方法用来计算高度：tableView:heightForRowAtIndexPath:。自定义一个UITableViewCell的子类\n- (void)layoutSubviews { [super layoutSubviews]; self.textLabel.frame = CGRectInset(self.bounds, MyTableViewCellInset, MyTableViewCellInset); } 计算真实高度需要使用boundingRectWithSize:options:context: 这个方法\n- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath { CGFloat labelWidth = self.tableView.bounds.size.width - MyTableViewCellInset*2; NSAttributedString *text = [self attributedBodyTextAtIndexPath:indexPath]; NSStringDrawingOptions options = NSStringDrawingUsesLineFragmentOrigin | NSStringDrawingUsesFontLeading; CGRect boundingRect = [text boundingRectWithSize:CGSizeMake(labelWidth, CGFLOAT_MAX) options:options context:nil]; return (CGFloat) (ceil(boundingRect.size.height) + MyTableViewCellInset*2); } 使用Text Kit和NSAttributedString进行布局 先设置attributes\nCGFloat const fontSize = 15; NSMutableDictionary *body1stAttributes = [NSMutableDictionary dictionary]; body1stAttributes[NSFontAttributeName] = [UIFont fontWithName:@\u0026quot;BodoniSvtyTwoITCTT-Book\u0026quot; size:fontSize]; NSMutableParagraphStyle *body1stParagraph = [[NSParagraphStyle defaultParagraphStyle] mutableCopy]; body1stParagraph.alignment = NSTextAlignmentJustified; body1stParagraph.minimumLineHeight = fontSize + 3; body1stParagraph.maximumLineHeight = body1stParagraph.minimumLineHeight; body1stParagraph.hyphenationFactor = 0.97; body1stAttributes[NSParagraphStyleAttributeName] = body1stParag raph; 这里字体为BodoniSvtyTwoITCTT，如果需要查看更多字体可以使用 +[UIFont familyNames]这个方法。为了得到字体的名字，可以使用 +[UIFont fontNamesForFamilyName:]。接下来创建段落的属性\nNSMutableDictionary *bodyAttributes = [body1stAttributes mutableCopy]; NSMutableParagraphStyle *bodyParagraph = [bodyAttributes[NSParagraphStyleAttributeName] mutableCopy]; bodyParagraph.firstLineHeadIndent = fontSize; bodyAttributes[NSParagraphStyleAttributeName] = bodyParagraph; 装饰段落风格，使用装饰字体将文本居中对齐，装饰字符的前后加上空白段落\nNSMutableDictionary *ornamentAttributes = [NSMutableDictionary dictionary]; ornamentAttributes[NSFontAttributeName] = [UIFont fontWithName:@\u0026quot;BodoniOrnamentsITCTT\u0026quot; size:36]; NSMutableParagraphStyle *ornamentParagraph = [[NSParagraphStyle defaultParagraphStyle] mutableCopy]; ornamentParagraph.alignment = NSTextAlignmentCenter; ornamentParagraph.paragraphSpacingBefore = fontSize; ornamentParagraph.paragraphSpacing = fontSize; ornamentAttributes[NSParagraphStyleAttributeName] = ornamentParagraph; 显示数字表格table，表格布局示例\nNSCharacterSet *decimalTerminator = [NSCharacterSet characterSetWithCharactersInString:decimalFormatter.decimalSeparator]; NSTextTab *decimalTab = [[NSTextTab alloc] initWithTextAlignment:NSTextAlignmentCenter location:100 options:@{NSTabColumnTerminatorsAttributeName:decimalTerminator}]; NSTextTab *percentTab = [[NSTextTab alloc] initWithTextAlignment:NSTextAlignmentRight location:200 options:nil]; NSMutableParagraphStyle *tableParagraphStyle = [[NSParagraphStyle defaultParagraphStyle] mutableCopy]; tableParagraphStyle.tabStops = @[decimalTab, percentTab]; 显示列表的属性设置如下\nNSMutableDictionary *listAttributes = [bodyAttributes mutableCopy]; NSMutableParagraphStyle *listParagraph = [listAttributes[NSParagraphStyleAttributeName] mutableCopy]; listParagraph.headIndent = fontSize * 3; listParagraph.firstLineHeadIndent = fontSize; NSTextTab *listTab = [[NSTextTab alloc] initWithTextAlignment:NSTextAlignmentNatural location:fontSize * 3 options:nil]; listParagraph.tabStops = @[listTab]; listAttributes[NSParagraphStyleAttributeName] = listParagraph; 字符串本地化  使用NSLocalizedString，可查看文章《字符串本地化》：（中文）（英文）  ming1016\n","title":"iOS字符串 "},{"link":"https://blog.policx.com/posts/gou-jian/","text":"   工程结构架构，减少耦合混乱以及防治需求大改造成结构重构，如何构建稳定可扩展可变换的工程结构的思考 我打算采用Information flow的方式自上而下，两大层分为基础层和展现层的结构。基础层分为多层，展现层也可分为多层。主要思想是将基础层的最下一层当做零部件，将业务层最下层当做组装大部件，通过流程串起来形成一个完整的产品，做零件时按照做出一个就扔进对应基础层的篮子里思路来，目录结构也可以按照这种来进行。这两大层的最下层按照零件拆得越小越容易应对需求变化越容易保护巩固上层的思路来就好。拿微信这个大家都熟悉的产品的几个功能来简单示例说明下这个思路构建后的结构，模块比较多，一些模块就不深入到最底层分析了：\n基础层 － 网络 －－ 收发数据 －－－单例（持续使用数据） －－－本地（缓存和持续化存储数据对业务的封装输出） －－－单次使用（API接口Model封装输出和业务逻辑封装的ViewModel，将这些做为业务零件） － 存储 －－－ NSUserDefault（对轻量需要存储的添加下一层业务零件封装） －－－ keychain（对安全级别较高需要存储的添加下一层业务零件封装） －－－ 文件存储（对时效需求短的需要存储的添加下一层业务零件封装） －－－ 数据库存储（对数据量大的需要存储的添加下一层业务零件封装，业务层上一层加一层封装CoreData或SQLite方便日后切换数据库用） － 动画（下层将动画框架输出成各个可以复用的动画功能小零件） － 视图风格 － 列表控件 －－ 上拉加载更多 －－ 下拉刷新 －－ GuideView － WebView控件 － AlertView － iOS系统空间封装 －－ 拍照控件 －－ 通讯录 － 二维码 － 语音 － 安全 － 支付 － 统计 － 日志 展现层 － 首页 －－ 订阅 －－ 扫描二维码 －－ 发布视频 － 列表 －－ 时间轴列表 －－－ Listview头部封面 －－－ 外链情况Cell －－－ 图片Cell －－－ 广告插入Cell －－－ 留言评论 －－－ 赞区域 －－ 我的列表 －－ 订阅列表 －－ 文章列表 － 详细页 －－ 分享 －－ 内容区 －－ 评论 － 登录 －－ 注册 －－ 登录 －－ 忘记密码 －－ 条款 －－ 上传头像 －－ 个人信息修改 基础层中各个模块上层可以使用类似CocoaPod或Cathage方式，下一层再对其引用进行业务封装。\n这里注意最下层需要拆的粒度越细越好。减少横向依赖。类似Common这样的东西可以拆到基础层的对应模块里，比如说配置文件里和统计相关的放到基础层的统计里，网络相关的放到网络里，颜色字体放到视图风格里，不要都堆在一个文件里。再或者是各种第三方的Category也放到对应的组里，比如说UIView+Additions和UIColor+Expanded就放到视图风格这个模块中，不要专门搞个Category放所有的Category。\n数据流控制模式MVC和MVCS/MVVM/VIPER的选择 其实这些都是对MVC的扩展，只是扩展的方向不同而已。VIPER把视图和数据拆得过细变相增加了复杂度很多人也都不熟也没有意愿去了解它的实现，但是模块复用却达到了最优，MVCS是这几个里对MVC优化最简单的只是把数据的存储拆开了。MVVM正好介于VIPER和MVCS之间，从ViewController里拆出来的ViewModel能够将数据经过逻辑处理用于View的显示，View有操作用过ReactiveCocoa将信号传给ViewModel来处理。\n如果是我个人选择我会选择VIPER，因为它更符合细粒度模块划分的思想。但是用在团队多人开发上，还是偏向MVVM这种折中方案。MVVM按照先前对应用的结构分层，会将View和ViewController放到展现层的最下面的两层里，将ViewModel和Model放到基础层对应模块的最下面一层中。最后要说的是无论选择哪种，只要是按照减少ViewController大小，将改胖的地方放到Model或View都是可以的，招式学多后最高境界就是无招胜有招嘛，有时也不需要刻板的在一个项目中将所有的模块都按照统一的思路给框死，比如说一个模块很简单就用MVC，一般复杂就用MVVM，要是项目本身业务非常庞大可以整体采用VIPER来进行ViewController的完全拆分。\n可以通过下列图表看其中的不同：\n   名称 逻辑和视图 数据     MVC View + ViewController + Model   MVCS View + ViewController + Store + Model   MVVM View + ViewController + ViewModel + Model   VIPER View + ViewController + Wireframe + Presenter + Interactor + Data Manager + Entity(Model)    代码规范 这块最有权威的应该是苹果自己提出的https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CodingGuidelines/CodingGuidelines.html，按照这套来肯定是没问题的，而且首先应该遵守。代码结构主要根据不同团队的经验来做。下面举个我常用的代码结构\n@property ... #pragma mark - Life cycle 生命周期，类似addSubview和Notification的监听和销毁都放在这里 #pragma mark - Interface 接口 #pragma mark - Event response #pragma mark - Private method 如果是ViewController，这个地方就是瘦身的关键，业务和逻辑功能相关的就放到ViewModel里。 #pragma mark - Delegate 代理 #pragma mark - Getters and Setters 建议所有的Property都设置，这样修改配置会比较方便，看起来不会很混乱 ming1016\n","title":"构建iOS稳定应用架构时方案选择的思考"},{"link":"https://blog.policx.com/posts/ios-design-pattern/","text":"iOS 设计模式\nMVC  Model：模型 View：视图 Controller：控制器  单例 单例使用懒加载方式在第一次实例时创建，如[NSUserDefaults standardUserDefaults]，[UIApplication sharedApplication]，[UIScreen mainScreen]，[NSFileManager defaultManager]\n系统的单例类\n UIApplication NSNotificationCenter NSFileManager NSUserDefaults NSURLCache NSHTTPCookieStorage  @interfaceLibraryAPI : NSObject + (LibraryAPI*)sharedInstance; @end + (LibraryAPI*)sharedInstance { // 声明一个静态变量去保存类的实例，确保它在类中的全局可用 static LibraryAPI *_sharedInstance = nil; // dispatch_once_t确保初始化器只执行一次 static dispatch_once_t oncePredicate; // 单例的关键，一旦类被初始化，初始化器不会再被调用 dispatch_once(\u0026amp;oncePredicate, ^{ _sharedInstance = [[LibraryAPI alloc] init]; }); return _sharedInstance; } @implementation XNShareTool /** 步骤: 1.一个静态变量_inastance 2.重写allocWithZone, 在里面用dispatch_once, 并调用super allocWithZone 3.自定义一个sharedXX, 用来获取单例. 在里面也调用dispatch_once, 实例化_instance -----------可选------------ 4.如果要支持copy. 则(先遵守NSCopying协议)重写copyWithZone, 直接返回_instance即可. */ /**第1步: 存储唯一实例*/ static XNShareTool *_instance; /**第2步: 分配内存孔家时都会调用这个方法. 保证分配内存alloc时都相同*/ +(id)allocWithZone:(struct _NSZone *)zone{ //调用dispatch_once保证在多线程中也只被实例化一次 static dispatch_once_t onceToken; dispatch_once(\u0026amp;onceToken, ^{ _instance = [super allocWithZone:zone]; }); return _instance; } /**第3步: 保证init初始化时都相同*/ +(instancetype)sharedTool{ static dispatch_once_t onceToken; dispatch_once(\u0026amp;onceToken, ^{ _instance = [[XNShareTool alloc] init]; }); return _instance; } /**第4步: 保证copy时都相同*/ -(id)copyWithZone:(NSZone *)zone{ return _instance; } @end 门面模式Facade 暴露接口\n装饰器模式Decorator 常见的实现是Category和Delegation，\n适配器模式Adapter 包装一个对象暴露一个标准的接口。可以使用协议的方式实现，比如UITableViewDelegate，UIScrollViewDelegate，NSCoding和NSCopying协议。\n观察者模式Observer Notifications和Key-Value Observing(KVO)都是这个设计模式\n备忘录模式Memento 比如NSUserDefaults，或者用类似的方式进行状态保存使得再次进入时能够和离开时一样。可以使用UIApplicationDidEnterBackgroundNotification 这个通知去保存状态。\n命令模式 通过Target-Action机制和Invocation实现命令模式\nming1016\n","title":"iOS设计模式"},{"link":"https://blog.policx.com/posts/ios-background-tasks/","text":"三种方式使得iOS程序即使在关闭或崩溃的情况下也能够在后台持续进行一些任务，比如更新程序界面快照，下载文件等。这三个方法分别是Background Fetch，Remote Notification和NSURLSession的backgroundSessionConfiguration *\nBackground Fetch 开启 首先在info plist文件中开启UIBackgroundModes的Background fetch。或者手动编辑这个值\n\u0026lt;key\u0026gt;UIBackgroundModes\u0026lt;/key\u0026gt; \u0026lt;array\u0026gt; \u0026lt;string\u0026gt;fetch\u0026lt;/string\u0026gt; \u0026lt;/array\u0026gt; iOS默认不进行background fetch，需要设置一个时间的间隔\n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions { //UIApplicationBackgroundFetchIntervalMinimum表示尽可能频繁去获取，如果需要指定至少多少时间更新一次就需要给定一个时间值 [application setMinimumBackgroundFetchInterval:UIApplicationBackgroundFetchIntervalMinimum]; return YES; } 最后在App Delegate里实现下面的方法，这个方法只能在30秒内完成。\n- (void) application:(UIApplication *)application performFetchWithCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler { NSURLSessionConfiguration *sessionConfiguration = [NSURLSessionConfiguration defaultSessionConfiguration]; NSURLSession *session = [NSURLSession sessionWithConfiguration:sessionConfiguration]; NSURL *url = [[NSURL alloc] initWithString:@\u0026quot;https://yourserver.com/data.json\u0026quot;]; NSURLSessionDataTask *task = [session dataTaskWithURL:url completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) { if (error) { completionHandler(UIBackgroundFetchResultFailed); return; } // 解析响应/数据以决定新内容是否可用 BOOL hasNewData = ... if (hasNewData) { completionHandler(UIBackgroundFetchResultNewData); } else { completionHandler(UIBackgroundFetchResultNoData); } }]; // 开始任务 [task resume]; } 测试  通过查看UIApplication的applicationState  - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions { NSLog(@\u0026quot;Launched in background %d\u0026quot;, UIApplicationStateBackground == application.applicationState); return YES; } Remote Notification 在普通的远程通知里带上content-available标志就可以在通知用户同时在后台进行更新。通知结构如下\n{ \u0026quot;aps\u0026quot; : { \u0026quot;content-available\u0026quot; : 1 }, \u0026quot;content-id\u0026quot; : 42 } 接收一条带有content-available的通知会调用下面的方法\n- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler { NSLog(@\u0026quot;Remote Notification userInfo is %@\u0026quot;, userInfo); NSNumber *contentID = userInfo[@\u0026quot;content-id\u0026quot;]; // 根据 content ID 进行操作 completionHandler(UIBackgroundFetchResultNewData); } 利用NSURLSession进行background transfer task 使用[NSURLSessionConfiguration backgroundSessionConfiguration]创建一个后台任务，当应用退出后，崩溃或进程被关掉都还是会运行。\n范例，先处理一条远程通知，并将NSURLSessionDownloadTask添加到后台传输服务队列。\n- (NSURLSession *)backgroundURLSession { static NSURLSession *session = nil; static dispatch_once_t onceToken; dispatch_once(\u0026amp;onceToken, ^{ NSString *identifier = @\u0026quot;io.objc.backgroundTransferExample\u0026quot;; NSURLSessionConfiguration* sessionConfig = [NSURLSessionConfiguration backgroundSessionConfiguration:identifier]; session = [NSURLSession sessionWithConfiguration:sessionConfig delegate:self delegateQueue:[NSOperationQueue mainQueue]]; }); return session; } - (void) application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler { NSLog(@\u0026quot;Received remote notification with userInfo %@\u0026quot;, userInfo); NSNumber *contentID = userInfo[@\u0026quot;content-id\u0026quot;]; NSString *downloadURLString = [NSString stringWithFormat:@\u0026quot;https://yourserver.com/downloads/%d.mp3\u0026quot;, [contentID intValue]]; NSURL* downloadURL = [NSURL URLWithString:downloadURLString]; NSURLRequest *request = [NSURLRequest requestWithURL:downloadURL]; NSURLSessionDownloadTask *task = [[self backgroundURLSession] downloadTaskWithRequest:request]; task.taskDescription = [NSString stringWithFormat:@\u0026quot;Podcast Episode %d\u0026quot;, [contentID intValue]]; //执行resume保证开始了任务 [task resume]; completionHandler(UIBackgroundFetchResultNewData); } 下载完成后调用NSURLSessionDownloadDelegate的委托方法，这些委托方法全部是必须实现的。了解所有类型session task的生命周期可以参考官方文档：https://developer.apple.com/library/ios/documentation/cocoa/Conceptual/URLLoadingSystem/NSURLSessionConcepts/NSURLSessionConcepts.html#//apple_ref/doc/uid/10000165i-CH2-SW42\n#Pragma Mark - NSURLSessionDownloadDelegate - (void) URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didFinishDownloadingToURL:(NSURL *)location { NSLog(@\u0026quot;downloadTask:%@ didFinishDownloadingToURL:%@\u0026quot;, downloadTask.taskDescription, location); // 必须用 NSFileManager 将文件复制到应用的存储中，因为临时文件在方法返回后会被删除 // ... // 通知 UI 刷新 } - (void) URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didResumeAtOffset:(int64_t)fileOffset expectedTotalBytes:(int64_t)expectedTotalBytes { } - (void) URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWritten totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite { } 后台的任务完成后如果应用没有在前台运行，需要实现UIApplication的两个delegate让系统唤醒应用\n- (void) application:(UIApplication *)application handleEventsForBackgroundURLSession:(NSString *)identifier completionHandler:(void (^)())completionHandler { // 你必须重新建立一个后台 seesiong 的参照 // 否则 NSURLSessionDownloadDelegate 和 NSURLSessionDelegate 方法会因为 // 没有 对 session 的 delegate 设定而不会被调用。参见上面的 backgroundURLSession NSURLSession *backgroundSession = [self backgroundURLSession]; NSLog(@\u0026quot;Rejoining session with identifier %@ %@\u0026quot;, identifier, backgroundSession); // 保存 completion handler 以在处理 session 事件后更新 UI [self addCompletionHandler:completionHandler forSession:identifier]; } - (void)URLSessionDidFinishEventsForBackgroundURLSession:(NSURLSession *)session { NSLog(@\u0026quot;Background URL session %@ finished events.\\n\u0026quot;, session); if (session.configuration.identifier) { // 调用在 -application:handleEventsForBackgroundURLSession: 中保存的 handler [self callCompletionHandlerForSession:session.configuration.identifier]; } } - (void)addCompletionHandler:(CompletionHandlerType)handler forSession:(NSString *)identifier { if ([self.completionHandlerDictionary objectForKey:identifier]) { NSLog(@\u0026quot;Error: Got multiple handlers for a single session identifier. This should not happen.\\n\u0026quot;); } [self.completionHandlerDictionary setObject:handler forKey:identifier]; } - (void)callCompletionHandlerForSession: (NSString *)identifier { CompletionHandlerType handler = [self.completionHandlerDictionary objectForKey: identifier]; if (handler) { [self.completionHandlerDictionary removeObjectForKey: identifier]; NSLog(@\u0026quot;Calling completion handler for session %@\u0026quot;, identifier); handler(); } } ming1016\n","title":"iOS Background Tasks"},{"link":"https://blog.policx.com/posts/block/","text":"简介 block可以当做匿名函数，可以在两个对象间将语句当做数据来进行传递。具有封闭性closure，方便取得上下文相关状态信息。\nBlock的创建  可以如声明函数那样声明一个block变量 定义函数的方法定义block 把block当做一个函数来调用  int main(int argc, const char * argv[]) { @autoreleasepool { // Declare the block variable double (^distanceFromRateAndTime)(double rate, double time); // Create and assign the block distanceFromRateAndTime = ^double(double rate, double time) { return rate * time; }; // Call the block double dx = distanceFromRateAndTime(35, 1.5); NSLog(@\u0026quot;A car driving 35 mph will travel \u0026quot; @\u0026quot;%.2f miles in 1.5 hours.\u0026quot;, dx); } return 0; } 不带参数的Block block可以简写为^ { … }\ndouble (^randomPercent)(void) = ^ { return (double)arc4random() / 4294967295; }; NSLog(@\u0026quot;Gas tank is %.1f%% full”, randomPercent() * 100); Block的闭包（closure） block内部可以访问定义在block外部的非局部变量。非局部变量会以拷贝形式存储到block中。\nNSString *make = @\u0026quot;Honda\u0026quot;; NSString *(^getFullCarName)(NSString *) = ^(NSString *model) { return [make stringByAppendingFormat:@\u0026quot; %@\u0026quot;, model]; }; NSLog(@\u0026quot;%@\u0026quot;, getFullCarName(@\u0026quot;Accord\u0026quot;)); // Honda Accord // Try changing the non-local variable (it won't change the block) make = @\u0026quot;Porsche\u0026quot;; NSLog(@\u0026quot;%@\u0026quot;, getFullCarName(@\u0026quot;911 Turbo\u0026quot;)); // Honda 911 Turbo 修改非局部变量 用__block存储修饰符号（storage modifier）声明非局部变量\n__block int i = 0; int (^count)(void) = ^ { i += 1; return i; }; NSLog(@\u0026quot;%d\u0026quot;, count()); // 1 NSLog(@\u0026quot;%d\u0026quot;, count()); // 2 NSLog(@\u0026quot;%d\u0026quot;, count()); // 3 Block作为函数的参数 // Car.h #import @interface Car : NSObject @property double odometer; - (void)driveForDuration:(double)duration withVariableSpeed:(double (^)(double time))speedFunction steps:(int)numSteps; @end //调用block // Car.m #import \u0026quot;Car.h\u0026quot; @implementation Car @synthesize odometer = _odometer; - (void)driveForDuration:(double)duration withVariableSpeed:(double (^)(double time))speedFunction steps:(int)numSteps { double dt = duration / numSteps; for (int i=1; i\u0026amp;lt;=numSteps; i++) { _odometer += speedFunction(i*dt) * dt; } } @end //在main函数中block定义在另一个函数的调用过程中。 // main.m #import #import \u0026quot;Car.h\u0026quot; int main(int argc, const char * argv[]) { @autoreleasepool { Car *theCar = [[Car alloc] init]; // Drive for awhile with constant speed of 5.0 m/s [theCar driveForDuration:10.0 withVariableSpeed:^(double time) { return 5.0; } steps:100]; NSLog(@\u0026quot;The car has now driven %.2f meters\u0026quot;, theCar.odometer); // Start accelerating at a rate of 1.0 m/s^2 [theCar driveForDuration:10.0 withVariableSpeed:^(double time) { return time + 5.0; } steps:100]; NSLog(@\u0026quot;The car has now driven %.2f meters\u0026quot;, theCar.odometer); } return 0; } 定义Block类型 // Car.h #import // Define a new type for the block typedef double (^SpeedFunction)(double); @interface Car : NSObject @property double odometer; - (void)driveForDuration:(double)duration withVariableSpeed:(SpeedFunction)speedFunction steps:(int)numSteps; @end 风险 block会存在导致retain cycles的风险，如果发送者需要 retain block 但又不能确保引用在什么时候被赋值为 nil， 那么所有在 block 内对 self 的引用就会发生潜在的 retain 环。NSOperation 是使用 block 的一个好范例。因为它在一定的地方打破了 retain 环，解决了上述的问题。\nself.queue = [[NSOperationQueue alloc] init]; MyOperation *operation = [[MyOperation alloc] init]; operation.completionBlock = ^{ [self finishedOperation]; }; [self.queue addOperation:operation]; 另一个解决方法\n@interface Encoder () @property (nonatomic, copy) void (^completionHandler)(); @end @implementation Encoder - (void)encodeWithCompletionHandler:(void (^)())handler { self.completionHandler = handler; // 进行异步处理... } // 这个方法会在完成后被调用一次 - (void)finishedEncoding { self.completionHandler(); self.completionHandler = nil; //一旦任务完成就设置为nil } @end \n","title":"Block"},{"link":"https://blog.policx.com/posts/cfrunloop/","text":"   简介 简单的说run loop是事件驱动的一个大循环，如下代码所示\nint main(int argc, char * argv[]) { //程序一直运行状态 while (AppIsRunning) { //睡眠状态，等待唤醒事件 id whoWakesMe = SleepForWakingUp(); //得到唤醒事件 id event = GetEvent(whoWakesMe); //开始处理事件 HandleEvent(event); } return 0; } Cocoa会涉及到Run Loops的  系统级：GCD，mach kernel，block，pthread 应用层：NSTimer，UIEvent，Autorelease，NSObject(NSDelayedPerforming)，NSObject(NSThreadPerformAddition)，CADisplayLink，CATransition，CAAnimation，dispatch_get_main_queue()（GCD中dispatch到main queue的block会被dispatch到main RunLoop执行），NSPort，NSURLConnection，AFNetworking(这个第三方网络请求框架使用在开启新线程中添加自己的run loop监听事件)  在Main thread堆栈中所处位置 堆栈最底层是start(dyld)，往上依次是main，UIApplication(main.m) -\u0026gt; GSEventRunModal(Graphic Services) -\u0026gt; RunLoop(包含CFRunLoopRunSpecific，__CFRunLoopRun，__CFRunLoopDoSouces0，CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION) -\u0026gt; Handle Touch Event\nRunLoop原理 CFRunLoop开源代码：https://opensource.apple.com/source/CF/CF-855.17/\n执行顺序的伪代码 SetupThisRunLoopRunTimeoutTimer(); // by GCD timer do { __CFRunLoopDoObservers(kCFRunLoopBeforeTimers); __CFRunLoopDoObservers(kCFRunLoopBeforeSources); __CFRunLoopDoBlocks(); __CFRunLoopDoSource0(); CheckIfExistMessagesInMainDispatchQueue(); // GCD __CFRunLoopDoObservers(kCFRunLoopBeforeWaiting); var wakeUpPort = SleepAndWaitForWakingUpPorts(); // mach_msg_trap // Zzz... // Received mach_msg, wake up __CFRunLoopDoObservers(kCFRunLoopAfterWaiting); // Handle msgs if (wakeUpPort == timerPort) { __CFRunLoopDoTimers(); } else if (wakeUpPort == mainDispatchQueuePort) { // GCD __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__() } else { __CFRunLoopDoSource1(); } __CFRunLoopDoBlocks(); } while (!stop \u0026amp;\u0026amp; !timeout); 构成 Thread包含一个CFRunLoop，一个CFRunLoop包含一种CFRunLoopMode，mode包含CFRunLoopSource，CFRunLoopTimer和CFRunLoopObserver。\nCFRunLoopMode RunLoop只能运行在一种mode下，如果要换mode当前的loop也需要停下重启成新的。利用这个机制，ScrollView过程中NSDefaultRunLoopMode的mode会切换UITrackingRunLoopMode来保证ScrollView的流畅滑动不受只能在NSDefaultRunLoopMode时处理的事件影响滑动。同时mode还是可定制的。\n NSDefaultRunLoopMode：默认，空闲状态 UITrackingRunLoopMode：ScrollView滑动时 UIInitializationRunLoopMode：启动时 NSRunLoopCommonModes：Mode集合 Timer计时会被scrollView的滑动影响的问题可以通过将timer添加到NSRunLoopCommonModes来解决  //将timer添加到NSDefaultRunLoopMode中 [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(timerTick:) userInfo:nil repeats:YES]; //然后再添加到NSRunLoopCommonModes里 NSTimer *timer = [NSTimer timerWithTimeInterval:1.0 target:self selector:@selector(timerTick:) userInfo:nil repeats:YES]; [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes]; CFRunLoopTimer NSTimer是对RunLoopTimer的封装\n+ (NSTimer *)timerWithTimeInterval:(NSTimeInterval)ti invocation:(NSInvocation *)invocation repeats:(BOOL)yesOrNo; + (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)ti invocation:(NSInvocation *)invocation repeats:(BOOL)yesOrNo; - (void)performSelector:(SEL)aSelector withObject:(id)anArgument afterDelay:(NSTimeInterval)delay inModes:(NSArray *)modes; + (CADisplayLink *)displayLinkWithTarget:(id)target selector:(SEL)sel; - (void)addToRunLoop:(NSRunLoop *)runloop forMode:(NSString *)mode; CFRunLoopSource  source0：处理如UIEvent，CFSocket这样的事件 source1：Mach port驱动，CFMachport，CFMessagePort  CFRunLoopObserver Cocoa框架中很多机制比如CAAnimation等都是由RunLoopObserver触发的。observer到当前状态的变化进行通知。\ntypedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) { kCFRunLoopEntry = (1UL \u0026lt;\u0026lt; 0), kCFRunLoopBeforeTimers = (1UL \u0026lt;\u0026lt; 1), kCFRunLoopBeforeSources = (1UL \u0026lt;\u0026lt; 2), kCFRunLoopBeforeWaiting = (1UL \u0026lt;\u0026lt; 5), kCFRunLoopAfterWaiting = (1UL \u0026lt;\u0026lt; 6), kCFRunLoopExit = (1UL \u0026lt;\u0026lt; 7), kCFRunLoopAllActivities = 0x0FFFFFFFU }; 使用RunLoop的案例 AFNetworking 使用NSOperation+NSURLConnection并发模型都会面临NSURLConnection下载完成前线程退出导致NSOperation对象接收不到回调的问题。AFNetWorking解决这个问题的方法是按照官方的guidhttps://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLConnection_Class/Reference/Reference.html#//apple_ref/occ/instm/NSURLConnection/initWithRequest:delegate:startImmediately:上写的NSURLConnection的delegate方法需要在connection发起的线程runloop中调用，于是AFNetWorking直接借鉴了Apple自己的一个Demohttps://developer.apple.com/LIBRARY/IOS/samplecode/MVCNetworking/Introduction/Intro.html的实现方法单独起一个global thread，内置一个runloop，所有的connection都由这个runloop发起，回调也是它接收，不占用主线程，也不耗CPU资源。\n+ (void)networkRequestThreadEntryPoint:(id)__unused object { @autoreleasepool { [[NSThread currentThread] setName:@\u0026quot;AFNetworking\u0026quot;]; NSRunLoop *runLoop = [NSRunLoop currentRunLoop]; [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode]; [runLoop run]; } } + (NSThread *)networkRequestThread { static NSThread *_networkRequestThread = nil; static dispatch_once_t oncePredicate; dispatch_once(\u0026amp;oncePredicate, ^{ _networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil]; [_networkRequestThread start]; }); return _networkRequestThread; } 类似的可以用这个方法创建一个常驻服务的线程。\nTableView中实现平滑滚动延迟加载图片 利用CFRunLoopMode的特性，可以将图片的加载放到NSDefaultRunLoopMode的mode里，这样在滚动UITrackingRunLoopMode这个mode时不会被加载而影响到。\nUIImage *downloadedImage = ...; [self.avatarImageView performSelector:@selector(setImage:) withObject:downloadedImage afterDelay:0 inModes:@[NSDefaultRunLoopMode]]; 接到程序崩溃时的信号进行自主处理例如弹出提示等 CFRunLoopRef runLoop = CFRunLoopGetCurrent(); NSArray *allModes = CFBridgingRelease(CFRunLoopCopyAllModes(runLoop)); while (1) { for (NSString *mode in allModes) { CFRunLoopRunInMode((CFStringRef)mode, 0.001, false); } } 异步测试 - (BOOL)runUntilBlock:(BOOL(^)())block timeout:(NSTimeInterval)timeout { __block Boolean fulfilled = NO; void (^beforeWaiting) (CFRunLoopObserverRef observer, CFRunLoopActivity activity) = ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) { fulfilled = block(); if (fulfilled) { CFRunLoopStop(CFRunLoopGetCurrent()); } }; CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(NULL, kCFRunLoopBeforeWaiting, true, 0, beforeWaiting); CFRunLoopAddObserver(CFRunLoopGetCurrent(), observer, kCFRunLoopDefaultMode); // Run! CFRunLoopRunInMode(kCFRunLoopDefaultMode, timeout, false); CFRunLoopRemoveObserver(CFRunLoopGetCurrent(), observer, kCFRunLoopDefaultMode); CFRelease(observer); return fulfilled; } ming1016\n","title":"CFRunLoop "},{"link":"https://blog.policx.com/posts/gcd/","text":"文中较详细介绍GCD队列，各种GCD使用方法，实例如何使用Dispatch Source监听系统底层对象，分析不同锁的性能对比，实例GCD死锁情况。文中的Demo在这里 https://github.com/ming1016/GCDDemo 对着文章试着来调demo体会更深哦，细细嚼消化好:) *\nGCD（Grand Central Dispatch） 介绍 GCD属于系统级的线程管理，在Dispatch queue中执行需要执行的任务性能非常的高。GCD这块已经开源，地址https://libdispatch.macosforge.org。GCD中的FIFO队列称为dispatch queue，用来保证先进来的任务先得到执行。\nGCD概要  和operation queue一样都是基于队列的并发编程API，他们通过集中管理大家协同使用的线程池。 公开的5个不同队列：运行在主线程中的main queue，3个不同优先级的后台队列（High Priority Queue，Default Priority Queue，Low Priority Queue），以及一个优先级更低的后台队列Background Priority Queue（用于I/O） 可创建自定义队列：串行或并列队列。自定义一般放在Default Priority Queue和Main Queue里。 操作是在多线程上还是单线程主要是看队列的类型和执行方法，并行队列异步执行才能在多线程，并行队列同步执行就只会在这个并行队列在队列中被分配的那个线程执行。（TorchLennon 指出先前文中此句一处错误）  基本概念  系统标准两个队列  //全局队列，一个并行的队列 dispatch_get_global_queue //主队列，主线程中的唯一队列，一个串行队列 dispatch_get_main_queue  自定义队列  //串行队列 dispatch_queue_create(\u0026quot;com.starming.serialqueue\u0026quot;, DISPATCH_QUEUE_SERIAL) //并行队列 dispatch_queue_create(\u0026quot;com.starming.concurrentqueue\u0026quot;, DISPATCH_QUEUE_CONCURRENT)  同步异步线程创建  //同步线程 dispatch_sync(..., ^(block)) //异步线程 dispatch_async(..., ^(block)) 队列（dispatch queue）  Serial：又叫private dispatch queues，同时只执行一个任务。Serial queue常用于同步访问特定的资源或数据。当你创建多个Serial queue时，虽然各自是同步，但serial queue之间是并发执行。 Main dispatch queue：全局可用的serial queue，在应用程序主线程上执行任务。 Concurrent：又叫global dispatch queue，可以并发的执行多个任务，但执行完成顺序是随机的。系统提供四个全局并发队列，这四个队列有这对应的优先级，用户是不能够创建全局队列的，只能获取。  dipatch_queue_t queue; queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH,0);  user create queue：创建自己定义的队列，可以用dispatch_queue_create函数，函数有两个参数，第一个自定义的队列名，第二个参数是队列类型，默认NULL或者DISPATCH_QUEUE_SERIAL的是串行，参数为DISPATCH_QUEUE_CONCURRENT为并行队列。  dispatch_queue_t queue queue = dispatch_queue_create(\u0026quot;com.starming.gcddemo.concurrentqueue\u0026quot;, DISPATCH_QUEUE_CONCURRENT);  自定义队列的优先级：可以通过dipatch_queue_attr_make_with_qos_class或dispatch_set_target_queue方法设置队列的优先级  //dipatch_queue_attr_make_with_qos_class dispatch_queue_attr_t attr = dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_SERIAL, QOS_CLASS_UTILITY, -1); dispatch_queue_t queue = dispatch_queue_create(\u0026quot;com.starming.gcddemo.qosqueue\u0026quot;, attr); //dispatch_set_target_queue dispatch_queue_t queue = dispatch_queue_create(\u0026quot;com.starming.gcddemo.settargetqueue\u0026quot;,NULL); //需要设置优先级的queue dispatch_queue_t referQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0); //参考优先级 dispatch_set_target_queue(queue, referQueue); //设置queue和referQueue的优先级一样  dispatch_set_target_queue：可以设置优先级，也可以设置队列层级体系，比如让多个串行和并行队列在统一一个串行队列里串行执行，如下  dispatch_queue_t serialQueue = dispatch_queue_create(\u0026quot;com.starming.gcddemo.serialqueue\u0026quot;, DISPATCH_QUEUE_SERIAL); dispatch_queue_t firstQueue = dispatch_queue_create(\u0026quot;com.starming.gcddemo.firstqueue\u0026quot;, DISPATCH_QUEUE_SERIAL); dispatch_queue_t secondQueue = dispatch_queue_create(\u0026quot;com.starming.gcddemo.secondqueue\u0026quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_set_target_queue(firstQueue, serialQueue); dispatch_set_target_queue(secondQueue, serialQueue); dispatch_async(firstQueue, ^{ NSLog(@\u0026quot;1\u0026quot;); [NSThread sleepForTimeInterval:3.f]; }); dispatch_async(secondQueue, ^{ NSLog(@\u0026quot;2\u0026quot;); [NSThread sleepForTimeInterval:2.f]; }); dispatch_async(secondQueue, ^{ NSLog(@\u0026quot;3\u0026quot;); [NSThread sleepForTimeInterval:1.f]; }); 队列类型 队列默认是串行的，如果设置改参数为NULL会按串行处理，只能执行一个单独的block，队列也可以是并行的，同一时间执行多个block\n- (id)init; { self = [super init]; if (self != nil) { NSString *label = [NSString stringWithFormat:@\u0026quot;%@.isolation.%p\u0026quot;, [self class], self]; self.isolationQueue = dispatch_queue_create([label UTF8String], 0); label = [NSString stringWithFormat:@\u0026quot;%@.work.%p\u0026quot;, [self class], self]; self.workQueue = dispatch_queue_create([label UTF8String], 0); } return self; } 5种队列，主队列（main queue）,四种通用调度队列，自己定制的队列。四种通用调度队列为\n QOS_CLASS_USER_INTERACTIVE：user interactive等级表示任务需要被立即执行提供好的体验，用来更新UI，响应事件等。这个等级最好保持小规模。 QOS_CLASS_USER_INITIATED：user initiated等级表示任务由UI发起异步执行。适用场景是需要及时结果同时又可以继续交互的时候。 QOS_CLASS_UTILITY：utility等级表示需要长时间运行的任务，伴有用户可见进度指示器。经常会用来做计算，I/O，网络，持续的数据填充等任务。这个任务节能。 QOS_CLASS_BACKGROUND：background等级表示用户不会察觉的任务，使用它来处理预加载，或者不需要用户交互和对时间不敏感的任务。  示例：后台加载显示图片\noverride func viewDidLoad() { super.viewDidLoad() dispatch_async(dispatch_get_global_queue(Int(QOS_CLASS_USER_INITIATED.value), 0)) { // 将工作从主线程转移到全局队列中，这是dispatch_async调用，异步提交保证调用线程会继续执行下去，这样viewDidLoad在主线程上能够更早完成， let overlayImage = self.faceOverlayImageFromImage(self.image) dispatch_async(dispatch_get_main_queue()) { // 新图完成，把一个闭包加入主线程用来更新UIImageView，只有在主线程能操作UIKit。 self.fadeInNewImage(overlayImage) // 更新UI } } } 何时使用何种队列类型\n 主队列（顺序）：队列中有任务完成需要更新UI时，dispatch_after在这种类型中使用。 并发队列：用来执行与UI无关的后台任务，dispatch_sync放在这里，方便等待任务完成进行后续处理或和dispatch barrier同步。dispatch groups放在这里也不错。 自定义顺序队列：顺序执行后台任务并追踪它时。这样做同时只有一个任务在执行可以防止资源竞争。dipatch barriers解决读写锁问题的放在这里处理。dispatch groups也是放在这里。  可以使用下面的方法简化QoS等级参数的写法\nvar GlobalMainQueue: dispatch_queue_t { return dispatch_get_main_queue() } var GlobalUserInteractiveQueue: dispatch_queue_t { return dispatch_get_global_queue(Int(QOS_CLASS_USER_INTERACTIVE.value), 0) } var GlobalUserInitiatedQueue: dispatch_queue_t { return dispatch_get_global_queue(Int(QOS_CLASS_USER_INITIATED.value), 0) } var GlobalUtilityQueue: dispatch_queue_t { return dispatch_get_global_queue(Int(QOS_CLASS_UTILITY.value), 0) } var GlobalBackgroundQueue: dispatch_queue_t { return dispatch_get_global_queue(Int(QOS_CLASS_BACKGROUND.value), 0) } //使用起来就是这样，易读而且容易看出在使用哪个队列 dispatch_async(GlobalUserInitiatedQueue) { let overlayImage = self.faceOverlayImageFromImage(self.image) dispatch_async(GlobalMainQueue) { self.fadeInNewImage(overlayImage) } } dispatch_once用法 dispatch_once_t要是全局或static变量，保证dispatch_once_t只有一份实例\n+ (UIColor *)boringColor; { static UIColor *color; //只运行一次 static dispatch_once_t onceToken; dispatch_once(\u0026amp;onceToken, ^{ color = [UIColor colorWithRed:0.380f green:0.376f blue:0.376f alpha:1.000f]; }); return color; } dispatch_async 设计一个异步的API调用dispatch_async()，这个调用放在API的方法或函数中做。让API的使用者设置一个回调处理队列\n- (void)processImage:(UIImage *)image completionHandler:(void(^)(BOOL success))handler; { dispatch_async(self.isolationQueue, ^(void){ // do actual processing here dispatch_async(self.resultQueue, ^(void){ handler(YES); }); }); } 可以避免界面会被一些耗时的操作卡死，比如读取网络数据，大数据IO，还有大量数据的数据库读写，这时需要在另一个线程中处理，然后通知主线程更新界面，GCD使用起来比NSThread和NSOperation方法要简单方便。\n//代码框架 dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ // 耗时的操作 dispatch_async(dispatch_get_main_queue(), ^{ // 更新界面 }); }); //下载图片的示例 dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ NSURL * url = [NSURL URLWithString:@\u0026quot;https://avatar.csdn.net/2/C/D/1_totogo2010.jpg\u0026quot;]; NSData * data = [[NSData alloc]initWithContentsOfURL:url]; UIImage *image = [[UIImage alloc]initWithData:data]; if (data != nil) { dispatch_async(dispatch_get_main_queue(), ^{ self.imageView.image = image; }); } }); dispatch_after延后执行 dispatch_after只是延时提交block，不是延时立刻执行。\n- (void)foo { double delayInSeconds = 2.0; dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t) (delayInSeconds * NSEC_PER_SEC)); dispatch_after(popTime, dispatch_get_main_queue(), ^(void){ [self bar]; }); } 范例，实现一个推迟出现弹出框提示，比如说提示用户评价等功能。\nfunc showOrHideNavPrompt() { let delayInSeconds = 1.0 let popTime = dispatch_time(DISPATCH_TIME_NOW, Int64(delayInSeconds * Double(NSEC_PER_SEC))) // 在这里声明推迟的时间 dispatch_after(popTime, GlobalMainQueue) { // 等待delayInSeconds将闭包异步到主队列 let count = PhotoManager.sharedManager.photos.count if count \u0026gt; 0 { self.navigationItem.prompt = nil } else { self.navigationItem.prompt = \u0026quot;Add photos with faces to Googlyify them!\u0026quot; } } } 例子中的dispatch time的参数，可以先看看函数原型\ndispatch_time_t dispatch_time ( dispatch_time_t when, int64_t delta ); 第一个参数为DISPATCH_TIME_NOW表示当前。第二个参数的delta表示纳秒，一秒对应的纳秒为1000000000，系统提供了一些宏来简化\n #define NSEC_PER_SEC 1000000000ull //每秒有多少纳秒 #define USEC_PER_SEC 1000000ull //每秒有多少毫秒 #define NSEC_PER_USEC 1000ull //每毫秒有多少纳秒 这样如果要表示一秒就可以这样写\ndispatch_time(DISPATCH_TIME_NOW, 1 * NSEC_PER_SEC); dispatch_time(DISPATCH_TIME_NOW, 1000 * USEC_PER_SEC); dispatch_time(DISPATCH_TIME_NOW, USEC_PER_SEC * NSEC_PER_USEC); dispatch_barrier_async使用Barrier Task方法Dispatch Barrier解决多线程并发读写同一个资源发生死锁 Dispatch Barrier确保提交的闭包是指定队列中在特定时段唯一在执行的一个。在所有先于Dispatch Barrier的任务都完成的情况下这个闭包才开始执行。轮到这个闭包时barrier会执行这个闭包并且确保队列在此过程不会执行其它任务。闭包完成后队列恢复。需要注意dispatch_barrier_async只在自己创建的队列上有这种作用，在全局并发队列和串行队列上，效果和dispatch_sync一样\n//创建队列 self.isolationQueue = dispatch_queue_create([label UTF8String], DISPATCH_QUEUE_CONCURRENT); //改变setter - (void)setCount:(NSUInteger)count forKey:(NSString *)key { key = [key copy]; //确保所有barrier都是async异步的 dispatch_barrier_async(self.isolationQueue, ^(){ if (count == 0) { [self.counts removeObjectForKey:key]; } else { self.counts[key] = @(count); } }); } - (void)dispatchBarrierAsyncDemo { //防止文件读写冲突，可以创建一个串行队列，操作都在这个队列中进行，没有更新数据读用并行，写用串行。 dispatch_queue_t dataQueue = dispatch_queue_create(\u0026quot;com.starming.gcddemo.dataqueue\u0026quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_async(dataQueue, ^{ [NSThread sleepForTimeInterval:2.f]; NSLog(@\u0026quot;read data 1\u0026quot;); }); dispatch_async(dataQueue, ^{ NSLog(@\u0026quot;read data 2\u0026quot;); }); //等待前面的都完成，在执行barrier后面的 dispatch_barrier_async(dataQueue, ^{ NSLog(@\u0026quot;write data 1\u0026quot;); [NSThread sleepForTimeInterval:1]; }); dispatch_async(dataQueue, ^{ [NSThread sleepForTimeInterval:1.f]; NSLog(@\u0026quot;read data 3\u0026quot;); }); dispatch_async(dataQueue, ^{ NSLog(@\u0026quot;read data 4\u0026quot;); }); } swift示例\n//使用dispatch_queue_create初始化一个并发队列。第一个参数遵循反向DNS命名习惯，方便描述，第二个参数是指出是并发还是顺序。 private let concurrentPhotoQueue = dispatch_queue_create( \u0026quot;com.raywenderlich.GooglyPuff.photoQueue\u0026quot;, DISPATCH_QUEUE_CONCURRENT) func addPhoto(photo: Photo) { dispatch_barrier_async(concurrentPhotoQueue) { // 将写操作加入到自定义的队列。开始执行时这个就是队列中唯一的一个在执行的任务。 self._photos.append(photo) // barrier能够保障不会和其他任务同时进行。 dispatch_async(GlobalMainQueue) { // 涉及到UI所以这个通知应该在主线程中，所以分派另一个异步任务到主队列中。 self.postContentAddedNotification() } } } //上面是解决了写可能发生死锁，下面是使用dispatch_sync解决读时可能会发生的死锁。 var photos: [Photo] { var photosCopy: [Photo]! dispatch_sync(concurrentPhotoQueue) { // 同步调度到concurrentPhotoQueue队列执行读操作 photosCopy = self._photos // 保存 } return photosCopy } //这样读写问题都解决了。 都用异步处理避免死锁，异步的缺点在于调试不方便，但是比起同步容易产生死锁这个副作用还算小的。\ndispatch_apply进行快速迭代 类似for循环，但是在并发队列的情况下dispatch_apply会并发执行block任务。\nfor (size_t y = 0; y \u0026lt; height; ++y) { for (size_t x = 0; x \u0026lt; width; ++x) { // Do something with x and y here } } //因为可以并行执行，所以使用dispatch_apply可以运行的更快 - (void)dispatchApplyDemo { dispatch_queue_t concurrentQueue = dispatch_queue_create(\u0026quot;com.starming.gcddemo.concurrentqueue\u0026quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_apply(10, concurrentQueue, ^(size_t i) { NSLog(@\u0026quot;%zu\u0026quot;,i); }); NSLog(@\u0026quot;The end\u0026quot;); //这里有个需要注意的是，dispatch_apply这个是会阻塞主线程的。这个log打印会在dispatch_apply都结束后才开始执行 } dispatch_apply能避免线程爆炸，因为GCD会管理并发\n- (void)dealWiththreadWithMaybeExplode:(BOOL)explode { dispatch_queue_t concurrentQueue = dispatch_queue_create(\u0026quot;com.starming.gcddemo.concurrentqueue\u0026quot;,DISPATCH_QUEUE_CONCURRENT); if (explode) { //有问题的情况，可能会死锁 for (int i = 0; i \u0026lt; 999 ; i++) { dispatch_async(concurrentQueue, ^{ NSLog(@\u0026quot;wrong %d\u0026quot;,i); //do something hard }); } } else { //会优化很多，能够利用GCD管理 dispatch_apply(999, concurrentQueue, ^(size_t i){ NSLog(@\u0026quot;correct %zu\u0026quot;,i); //do something hard }); } } 示例：\nfunc downloadPhotosWithCompletion(completion: BatchPhotoDownloadingCompletionClosure?) { var storedError: NSError! var downloadGroup = dispatch_group_create() let addresses = [OverlyAttachedGirlfriendURLString, SuccessKidURLString, LotsOfFacesURLString] dispatch_apply(UInt(addresses.count), GlobalUserInitiatedQueue) { i in let index = Int(i) let address = addresses[index] let url = NSURL(string: address) dispatch_group_enter(downloadGroup) let photo = DownloadPhoto(url: url!) { image, error in if let error = error { storedError = error } dispatch_group_leave(downloadGroup) } PhotoManager.sharedManager.addPhoto(photo) } dispatch_group_notify(downloadGroup, GlobalMainQueue) { if let completion = completion { completion(error: storedError) } } } Block组合Dispatch_groups dispatch groups是专门用来监视多个异步任务。dispatch_group_t实例用来追踪不同队列中的不同任务。\n当group里所有事件都完成GCD API有两种方式发送通知，第一种是dispatch_group_wait，会阻塞当前进程，等所有任务都完成或等待超时。第二种方法是使用dispatch_group_notify，异步执行闭包，不会阻塞。\n第一种使用dispatch_group_wait的swift的例子：\nfunc downloadPhotosWithCompletion(completion: BatchPhotoDownloadingCompletionClosure?) { dispatch_async(GlobalUserInitiatedQueue) { // 因为dispatch_group_wait会租塞当前进程，所以要使用dispatch_async将整个方法要放到后台队列才能够保证主线程不被阻塞 var storedError: NSError! var downloadGroup = dispatch_group_create() // 创建一个dispatch group for address in [OverlyAttachedGirlfriendURLString, SuccessKidURLString, LotsOfFacesURLString] { let url = NSURL(string: address) dispatch_group_enter(downloadGroup) // dispatch_group_enter是通知dispatch group任务开始了，dispatch_group_enter和dispatch_group_leave是成对调用，不然程序就崩溃了。 let photo = DownloadPhoto(url: url!) { image, error in if let error = error { storedError = error } dispatch_group_leave(downloadGroup) // 保持和dispatch_group_enter配对。通知任务已经完成 } PhotoManager.sharedManager.addPhoto(photo) } dispatch_group_wait(downloadGroup, DISPATCH_TIME_FOREVER) // dispatch_group_wait等待所有任务都完成直到超时。如果任务完成前就超时了，函数会返回一个非零值，可以通过返回值判断是否超时。也可以用DISPATCH_TIME_FOREVER表示一直等。 dispatch_async(GlobalMainQueue) { // 这里可以保证所有图片任务都完成，然后在main queue里加入完成后要处理的闭包，会在main queue里执行。 if let completion = completion { // 执行闭包内容 completion(error: storedError) } } } } oc例子\n- (void)dispatchGroupWaitDemo { dispatch_queue_t concurrentQueue = dispatch_queue_create(\u0026quot;com.starming.gcddemo.concurrentqueue\u0026quot;,DISPATCH_QUEUE_CONCURRENT); dispatch_group_t group = dispatch_group_create(); //在group中添加队列的block dispatch_group_async(group, concurrentQueue, ^{ [NSThread sleepForTimeInterval:2.f]; NSLog(@\u0026quot;1\u0026quot;); }); dispatch_group_async(group, concurrentQueue, ^{ NSLog(@\u0026quot;2\u0026quot;); }); dispatch_group_wait(group, DISPATCH_TIME_FOREVER); NSLog(@\u0026quot;go on\u0026quot;); } 第二种使用dispatch_group_notify的swift的例子：\nfunc downloadPhotosWithCompletion(completion: BatchPhotoDownloadingCompletionClosure?) { // 不用加dispatch_async，因为没有阻塞主进程 var storedError: NSError! var downloadGroup = dispatch_group_create() for address in [OverlyAttachedGirlfriendURLString, SuccessKidURLString, LotsOfFacesURLString] { let url = NSURL(string: address) dispatch_group_enter(downloadGroup) let photo = DownloadPhoto(url: url!) { image, error in if let error = error { storedError = error } dispatch_group_leave(downloadGroup) } PhotoManager.sharedManager.addPhoto(photo) } dispatch_group_notify(downloadGroup, GlobalMainQueue) { // dispatch_group_notify和dispatch_group_wait的区别就是是异步执行闭包的，当dispatch groups中没有剩余的任务时闭包才执行。这里是指明在主队列中执行。 if let completion = completion { completion(error: storedError) } } } oc例子\n//dispatch_group_notify - (void)dispatchGroupNotifyDemo { dispatch_queue_t concurrentQueue = dispatch_queue_create(\u0026quot;com.starming.gcddemo.concurrentqueue\u0026quot;,DISPATCH_QUEUE_CONCURRENT); dispatch_group_t group = dispatch_group_create(); dispatch_group_async(group, concurrentQueue, ^{ NSLog(@\u0026quot;1\u0026quot;); }); dispatch_group_async(group, concurrentQueue, ^{ NSLog(@\u0026quot;2\u0026quot;); }); dispatch_group_notify(group, dispatch_get_main_queue(), ^{ NSLog(@\u0026quot;end\u0026quot;); }); NSLog(@\u0026quot;can continue\u0026quot;); } //dispatch_group_wait - (void)dispatchGroupWaitDemo { dispatch_queue_t concurrentQueue = dispatch_queue_create(\u0026quot;com.starming.gcddemo.concurrentqueue\u0026quot;,DISPATCH_QUEUE_CONCURRENT); dispatch_group_t group = dispatch_group_create(); //在group中添加队列的block dispatch_group_async(group, concurrentQueue, ^{ [NSThread sleepForTimeInterval:2.f]; NSLog(@\u0026quot;1\u0026quot;); }); dispatch_group_async(group, concurrentQueue, ^{ NSLog(@\u0026quot;2\u0026quot;); }); dispatch_group_wait(group, DISPATCH_TIME_FOREVER); NSLog(@\u0026quot;can continue\u0026quot;); } 如何对现有API使用dispatch_group_t\n//给Core Data的-performBlock:添加groups。组合完成任务后使用dispatch_group_notify来运行一个block即可。 - (void)withGroup:(dispatch_group_t)group performBlock:(dispatch_block_t)block { if (group == NULL) { [self performBlock:block]; } else { dispatch_group_enter(group); [self performBlock:^(){ block(); dispatch_group_leave(group); }]; } } //NSURLConnection也可以这样做 + (void)withGroup:(dispatch_group_t)group sendAsynchronousRequest:(NSURLRequest *)request queue:(NSOperationQueue *)queue completionHandler:(void (^)(NSURLResponse*, NSData*, NSError*))handler { if (group == NULL) { [self sendAsynchronousRequest:request queue:queue completionHandler:handler]; } else { dispatch_group_enter(group); [self sendAsynchronousRequest:request queue:queue completionHandler:^(NSURLResponse *response, NSData *data, NSError *error){ handler(response, data, error); dispatch_group_leave(group); }]; } } 注意事项\n dispatch_group_async等价于dispatch_group_enter() 和 dispatch_group_leave()的组合。 dispatch_group_enter() 必须运行在 dispatch_group_leave() 之前。 dispatch_group_enter() 和 dispatch_group_leave() 需要成对出现的  Dispatch Block 队列执行任务都是block的方式，\n 创建block  - (void)createDispatchBlock { //normal way dispatch_queue_t concurrentQueue = dispatch_queue_create(\u0026quot;com.starming.gcddemo.concurrentqueue\u0026quot;,DISPATCH_QUEUE_CONCURRENT); dispatch_block_t block = dispatch_block_create(0, ^{ NSLog(@\u0026quot;run block\u0026quot;); }); dispatch_async(concurrentQueue, block); //QOS way dispatch_block_t qosBlock = dispatch_block_create_with_qos_class(0, QOS_CLASS_USER_INITIATED, -1, ^{ NSLog(@\u0026quot;run qos block\u0026quot;); }); dispatch_async(concurrentQueue, qosBlock); }  dispatch_block_wait：可以根据dispatch block来设置等待时间，参数DISPATCH_TIME_FOREVER会一直等待block结束  - (void)dispatchBlockWaitDemo { dispatch_queue_t serialQueue = dispatch_queue_create(\u0026quot;com.starming.gcddemo.serialqueue\u0026quot;, DISPATCH_QUEUE_SERIAL); dispatch_block_t block = dispatch_block_create(0, ^{ NSLog(@\u0026quot;star\u0026quot;); [NSThread sleepForTimeInterval:5.f]; NSLog(@\u0026quot;end\u0026quot;); }); dispatch_async(serialQueue, block); //设置DISPATCH_TIME_FOREVER会一直等到前面任务都完成 dispatch_block_wait(block, DISPATCH_TIME_FOREVER); NSLog(@\u0026quot;ok, now can go on\u0026quot;); }  dispatch_block_notify：可以监视指定dispatch block结束，然后再加入一个block到队列中。三个参数分别为，第一个是需要监视的block，第二个参数是需要提交执行的队列，第三个是待加入到队列中的block  - (void)dispatchBlockNotifyDemo { dispatch_queue_t serialQueue = dispatch_queue_create(\u0026quot;com.starming.gcddemo.serialqueue\u0026quot;, DISPATCH_QUEUE_SERIAL); dispatch_block_t firstBlock = dispatch_block_create(0, ^{ NSLog(@\u0026quot;first block start\u0026quot;); [NSThread sleepForTimeInterval:2.f]; NSLog(@\u0026quot;first block end\u0026quot;); }); dispatch_async(serialQueue, firstBlock); dispatch_block_t secondBlock = dispatch_block_create(0, ^{ NSLog(@\u0026quot;second block run\u0026quot;); }); //first block执行完才在serial queue中执行second block dispatch_block_notify(firstBlock, serialQueue, secondBlock); }  dispatch_block_cancel：iOS8后GCD支持对dispatch block的取消  - (void)dispatchBlockCancelDemo { dispatch_queue_t serialQueue = dispatch_queue_create(\u0026quot;com.starming.gcddemo.serialqueue\u0026quot;, DISPATCH_QUEUE_SERIAL); dispatch_block_t firstBlock = dispatch_block_create(0, ^{ NSLog(@\u0026quot;first block start\u0026quot;); [NSThread sleepForTimeInterval:2.f]; NSLog(@\u0026quot;first block end\u0026quot;); }); dispatch_block_t secondBlock = dispatch_block_create(0, ^{ NSLog(@\u0026quot;second block run\u0026quot;); }); dispatch_async(serialQueue, firstBlock); dispatch_async(serialQueue, secondBlock); //取消secondBlock dispatch_block_cancel(secondBlock); } 使用dispatch block object（调度块）在任务执行前进行取消 dispatch block object可以为队列中的对象设置 示例，下载图片中途进行取消\nfunc downloadPhotosWithCompletion(completion: BatchPhotoDownloadingCompletionClosure?) { var storedError: NSError! let downloadGroup = dispatch_group_create() var addresses = [OverlyAttachedGirlfriendURLString, SuccessKidURLString, LotsOfFacesURLString] addresses += addresses + addresses // 扩展address数组，复制3份 var blocks: [dispatch_block_t] = [] // 一个保存block的数组 for i in 0 ..\u0026lt; addresses.count { dispatch_group_enter(downloadGroup) let block = dispatch_block_create(DISPATCH_BLOCK_INHERIT_QOS_CLASS) { // 创建一个block，block的标志是DISPATCH_BLOCK_INHERIT_QOS_CLASS let index = Int(i) let address = addresses[index] let url = NSURL(string: address) let photo = DownloadPhoto(url: url!) { image, error in if let error = error { storedError = error } dispatch_group_leave(downloadGroup) } PhotoManager.sharedManager.addPhoto(photo) } blocks.append(block) dispatch_async(GlobalMainQueue, block) // 把这个block放到GlobalMainQueue上异步调用。因为全局队列是一个顺序队列所以方便取消对象block，同时可以保证下载任务在downloadPhotosWithCompletion返回后才开始执行。 } for block in blocks[3 ..\u0026lt; blocks.count] { let cancel = arc4random_uniform(2) // 随机返回一个整数，会返回0或1 if cancel == 1 { dispatch_block_cancel(block) // 如果是1就取消block，这个只能发生在block还在队列中并没有开始的情况下。因为把block已经放到了GlobalMainQueue中，所以这个地方会先执行，执行完了才会执行block。 dispatch_group_leave(downloadGroup) // 因为已经dispatch_group_enter了，所以取消时也要将其都leave掉。 } } dispatch_group_notify(downloadGroup, GlobalMainQueue) { if let completion = completion { completion(error: storedError) } } } Dispatch IO 文件操作 dispatch io读取文件的方式类似于下面的方式，多个线程去读取文件的切片数据，对于大的数据文件这样会比单线程要快很多。\ndispatch_async(queue,^{/*read 0-99 bytes*/}); dispatch_async(queue,^{/*read 100-199 bytes*/}); dispatch_async(queue,^{/*read 200-299 bytes*/});  dispatch_io_create：创建dispatch io dispatch_io_set_low_water：指定切割文件大小 dispatch_io_read：读取切割的文件然后合并。  苹果系统日志API里用到了这个技术，可以在这里查看：https://github.com/Apple-FOSS-Mirror/Libc/blob/2ca2ae74647714acfc18674c3114b1a5d3325d7d/gen/asl.c\npipe_q = dispatch_queue_create(\u0026quot;PipeQ\u0026quot;, NULL); //创建 pipe_channel = dispatch_io_create(DISPATCH_IO_STREAM, fd, pipe_q, ^(int err){ close(fd); }); *out_fd = fdpair[1]; //设置切割大小 dispatch_io_set_low_water(pipe_channel, SIZE_MAX); dispatch_io_read(pipe_channel, 0, SIZE_MAX, pipe_q, ^(bool done, dispatch_data_t pipedata, int err){ if (err == 0) { size_t len = dispatch_data_get_size(pipedata); if (len \u0026gt; 0) { //对每次切块数据的处理 const char *bytes = NULL; char *encoded; uint32_t eval; dispatch_data_t md = dispatch_data_create_map(pipedata, (const void **)\u0026amp;bytes, \u0026amp;len); encoded = asl_core_encode_buffer(bytes, len); asl_msg_set_key_val(aux, ASL_KEY_AUX_DATA, encoded); free(encoded); eval = _asl_evaluate_send(NULL, (aslmsg)aux, -1); _asl_send_message(NULL, eval, aux, NULL); asl_msg_release(aux); dispatch_release(md); } } if (done) { //semaphore +1使得不需要再等待继续执行下去。 dispatch_semaphore_signal(sem); dispatch_release(pipe_channel); dispatch_release(pipe_q); } }); Dispatch Source 用GCD监视进程 Dispatch Source用于监听系统的底层对象，比如文件描述符，Mach端口，信号量等。主要处理的事件如下表\n   方法 说明     DISPATCH_SOURCE_TYPE_DATA_ADD 数据增加   DISPATCH_SOURCE_TYPE_DATA_OR 数据OR   DISPATCH_SOURCE_TYPE_MACH_SEND Mach端口发送   DISPATCH_SOURCE_TYPE_MACH_RECV Mach端口接收   DISPATCH_SOURCE_TYPE_MEMORYPRESSURE 内存情况   DISPATCH_SOURCE_TYPE_PROC 进程事件   DISPATCH_SOURCE_TYPE_READ 读数据   DISPATCH_SOURCE_TYPE_SIGNAL 信号   DISPATCH_SOURCE_TYPE_TIMER 定时器   DISPATCH_SOURCE_TYPE_VNODE 文件系统变化   DISPATCH_SOURCE_TYPE_WRITE 文件写入    方法\n dispatch_source_create：创建dispatch source，创建后会处于挂起状态进行事件接收，需要设置事件处理handler进行事件处理。 dispatch_source_set_event_handler：设置事件处理handler dispatch_source_set_cancel_handler：事件取消handler，就是在dispatch source释放前做些清理的事。 dispatch_source_cancel：关闭dispatch source，设置的事件处理handler不会被执行，已经执行的事件handler不会取消。  NSRunningApplication *mail = [NSRunningApplication runningApplicationsWithBundleIdentifier:@\u0026quot;com.apple.mail\u0026quot;]; if (mail == nil) { return; } pid_t const pid = mail.processIdentifier; self.source = dispatch_source_create(DISPATCH_SOURCE_TYPE_PROC, pid, DISPATCH_PROC_EXIT, DISPATCH_TARGET_QUEUE_DEFAULT); dispatch_source_set_event_handler(self.source, ^(){ NSLog(@\u0026quot;Mail quit.\u0026quot;); }); //在事件源传到你的事件处理前需要调用dispatch_resume()这个方法 dispatch_resume(self.source); 监视文件夹内文件变化\nNSURL *directoryURL; // assume this is set to a directory int const fd = open([[directoryURL path] fileSystemRepresentation], O_EVTONLY); if (fd \u0026lt; 0) { char buffer[80]; strerror_r(errno, buffer, sizeof(buffer)); NSLog(@\u0026quot;Unable to open \\\u0026quot;%@\\\u0026quot;: %s (%d)\u0026quot;, [directoryURL path], buffer, errno); return; } dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_VNODE, fd, DISPATCH_VNODE_WRITE | DISPATCH_VNODE_DELETE, DISPATCH_TARGET_QUEUE_DEFAULT); dispatch_source_set_event_handler(source, ^(){ unsigned long const data = dispatch_source_get_data(source); if (data \u0026amp; DISPATCH_VNODE_WRITE) { NSLog(@\u0026quot;The directory changed.\u0026quot;); } if (data \u0026amp; DISPATCH_VNODE_DELETE) { NSLog(@\u0026quot;The directory has been deleted.\u0026quot;); } }); dispatch_source_set_cancel_handler(source, ^(){ close(fd); }); self.source = source; dispatch_resume(self.source); //还要注意需要用DISPATCH_VNODE_DELETE 去检查监视的文件或文件夹是否被删除，如果删除了就停止监听 NSTimer在主线程的runloop里会在runloop切换其它模式时停止，这时就需要手动在子线程开启一个模式为NSRunLoopCommonModes的runloop，如果不想开启一个新的runloop可以用不跟runloop关联的dispatch source timer，如下。\ndispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER,0, 0, DISPATCH_TARGET_QUEUE_DEFAULT); dispatch_source_set_event_handler(source, ^(){ NSLog(@\u0026quot;Time flies.\u0026quot;); }); dispatch_time_t start dispatch_source_set_timer(source, DISPATCH_TIME_NOW, 5ull * NSEC_PER_SEC,100ull * NSEC_PER_MSEC); self.source = source; dispatch_resume(self.source); Dispatch Semaphore和的介绍 另外一种保证同步的方法。使用dispatch_semaphore_signal加1dispatch_semaphore_wait减1，为0时等待的设置方式来达到线程同步的目的和同步锁一样能够解决资源抢占的问题。\n//dispatch semaphore - (void)dispatchSemaphoreDemo { //创建semaphore dispatch_semaphore_t semaphore = dispatch_semaphore_create(0); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ NSLog(@\u0026quot;start\u0026quot;); [NSThread sleepForTimeInterval:1.f]; NSLog(@\u0026quot;semaphore +1\u0026quot;); dispatch_semaphore_signal(semaphore); //+1 semaphore }); dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); NSLog(@\u0026quot;continue\u0026quot;); } 锁 这里简单介绍下iOS中常用的各种锁和他们的性能。\n NSRecursiveLock：递归锁，可以在一个线程中反复获取锁不会造成死锁，这个过程会记录获取锁和释放锁的次数来达到何时释放的作用。 NSDistributedLock：分布锁，基于文件方式的锁机制，可以跨进程访问。 NSConditionLock：条件锁，用户定义条件，确保一个线程可以获取满足一定条件的锁。因为线程间竞争会涉及到条件锁检测，系统调用上下切换频繁导致耗时是几个锁里最长的。 OSSpinLock：自旋锁，不进入内核，减少上下文切换，性能最高，但抢占多时会占用较多cpu，好点多，这时使用pthread_mutex较好。 pthread_mutex_t：同步锁基于C语言，底层api性能高，使用方法和其它的类似。 @synchronized：更加简单。  dispatch_suspend和dispatch_resume挂起和恢复队列 dispatch_suspend这里挂起不会暂停正在执行的block，只是能够暂停还没执行的block。\ndispatch_set_context和dispatch_get_context GCD深入操作  缓冲区：dispatch_data_t基于零碎的内存区域，使用dispatch_data_apply来遍历，还可以用dispatch_data_create_subrange来创建一个不做任何拷贝的子区域 I/O调度：使用GCD提供的dispatch_io_read，dispatch_io_write和dispatch_io_close 测试：使用dispatch_benchmark小工具 原子操作： libkern/OSAtomic.h里可以查看那些函数，用于底层多线程编程。  GCD死锁 当前串行队列里面同步执行当前串行队列就会死锁，解决的方法就是将同步的串行队列放到另外一个线程就能够解决。\n- (void)deadLockCase1 { NSLog(@\u0026quot;1\u0026quot;); //主队列的同步线程，按照FIFO的原则（先入先出），2排在3后面会等3执行完，但因为同步线程，3又要等2执行完，相互等待成为死锁。 dispatch_sync(dispatch_get_main_queue(), ^{ NSLog(@\u0026quot;2\u0026quot;); }); NSLog(@\u0026quot;3\u0026quot;); } - (void)deadLockCase2 { NSLog(@\u0026quot;1\u0026quot;); //3会等2，因为2在全局并行队列里，不需要等待3，这样2执行完回到主队列，3就开始执行 dispatch_sync(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{ NSLog(@\u0026quot;2\u0026quot;); }); NSLog(@\u0026quot;3\u0026quot;); } - (void)deadLockCase3 { dispatch_queue_t serialQueue = dispatch_queue_create(\u0026quot;com.starming.gcddemo.serialqueue\u0026quot;, DISPATCH_QUEUE_SERIAL); NSLog(@\u0026quot;1\u0026quot;); dispatch_async(serialQueue, ^{ NSLog(@\u0026quot;2\u0026quot;); //串行队列里面同步一个串行队列就会死锁 dispatch_sync(serialQueue, ^{ NSLog(@\u0026quot;3\u0026quot;); }); NSLog(@\u0026quot;4\u0026quot;); }); NSLog(@\u0026quot;5\u0026quot;); } - (void)deadLockCase4 { NSLog(@\u0026quot;1\u0026quot;); dispatch_async(dispatch_get_global_queue(0, 0), ^{ NSLog(@\u0026quot;2\u0026quot;); //将同步的串行队列放到另外一个线程就能够解决 dispatch_sync(dispatch_get_main_queue(), ^{ NSLog(@\u0026quot;3\u0026quot;); }); NSLog(@\u0026quot;4\u0026quot;); }); NSLog(@\u0026quot;5\u0026quot;); } - (void)deadLockCase5 { dispatch_async(dispatch_get_global_queue(0, 0), ^{ NSLog(@\u0026quot;1\u0026quot;); //回到主线程发现死循环后面就没法执行了 dispatch_sync(dispatch_get_main_queue(), ^{ NSLog(@\u0026quot;2\u0026quot;); }); NSLog(@\u0026quot;3\u0026quot;); }); NSLog(@\u0026quot;4\u0026quot;); //死循环 while (1) { // } } GCD实际使用 FMDB如何使用dispatch_queue_set_specific和dispatch_get_specific来防止死锁 作用类似objc_setAssociatedObject跟objc_getAssociatedObject\nstatic const void * const kDispatchQueueSpecificKey = \u0026amp;kDispatchQueueSpecificKey; //创建串行队列，所有数据库的操作都在这个队列里 _queue = dispatch_queue_create([[NSString stringWithFormat:@\u0026quot;fmdb.%@\u0026quot;, self] UTF8String], NULL); //标记队列 dispatch_queue_set_specific(_queue, kDispatchQueueSpecificKey, (__bridge void *)self, NULL); //检查是否是同一个队列来避免死锁的方法 - (void)inDatabase:(void (^)(FMDatabase *db))block { FMDatabaseQueue *currentSyncQueue = (__bridge id)dispatch_get_specific(kDispatchQueueSpecificKey); assert(currentSyncQueue != self \u0026amp;\u0026amp; \u0026quot;inDatabase: was called reentrantly on the same queue, which would lead to a deadlock\u0026quot;); } DTCoreText使用GCD加快解析速度 DTCoreText采用的是SAX解析，iOS自带了XML/HTML的解析引擎libxml，提供了两个解析接口，DOM解析和SAX解析，前者使用简单但是占用内存多，SAX解析由于不会返回一个dom树，采用的是查到一个标签比如回调startElement方法碰到内容就回调_characters碰到类似就回调endElement这样的方式。\n根据这种解析方式DTCoreText使用多线程解析能够更快的解析，DTHTMLAttributedStringBuilder使用三个dispatch_queue\n _dataParsingQueue：解析html的 _treeBuildingQueue：生成dom树的 _stringAssemblyQueue：组装NSAttributeString的 获取三个队列全部完成采用了dispatch_group的dispatch_group_wait这种阻塞同步方式来返回结果。  iOS系统版本新特性 iOS8 iOS8新加了一个功能叫Quality of Service(QoS)，里面提供了一下几个更容易理解的枚举名来使用user interactive，user initiated，utility和background。下面的表做了对比\n   Global queue Corresponding QoS class 说明     Main thread NSQualityOfServiceUserInteractive UI相关，交互等   DISPATCH_QUEUE_PRIORITY_HIGH NSQualityOfServiceUserInitiated 用户发起需要马上得到结果进行后续任务   DISPATCH_QUEUE_PRIORITY_DEFAULT NSQualityOfServiceDefault 默认的不应该使用这个设置任务   DISPATCH_QUEUE_PRIORITY_LOW NSQualityOfServiceUtility 花费时间稍多比如下载，需要几秒或几分钟的   DISPATCH_QUEUE_PRIORITY_BACKGROUND NSQualityOfServiceBackground 不可见在后台的操作可能需要好几分钟甚至几小时的    参考资料 WWDC  Building Responsive and Efficient Apps with GCD：https://developer.apple.com/videos/play/wwdc2015-718/  文档  官方文档：https://developer.apple.com/library/prerelease/ios/documentation/Performance/Reference/GCD_libdispatch_Ref/  \n","title":"细说GCD（Grand Central Dispatch）如何用"},{"link":"https://blog.policx.com/posts/ios-bing-fa/","text":"   线程 使用Instruments的CPU strategy view查看代码如何在多核CPU中执行。创建线程可以使用POSIX 线程API，或者NSThread（封装POSIX 线程API）。下面是并发4个线程在一百万个数字中找最小值和最大值的pthread例子：\n#import \u0026lt;pthread.h\u0026gt; struct threadInfo { uint32_t * inputValues; size_t count; }; struct threadResult { uint32_t min; uint32_t max; }; void * findMinAndMax(void *arg) { struct threadInfo const * const info = (struct threadInfo *) arg; uint32_t min = UINT32_MAX; uint32_t max = 0; for (size_t i = 0; i \u0026lt; info-\u0026gt;count; ++i) { uint32_t v = info-\u0026gt;inputValues[i]; min = MIN(min, v); max = MAX(max, v); } free(arg); struct threadResult * const result = (struct threadResult *) malloc(sizeof(*result)); result-\u0026gt;min = min; result-\u0026gt;max = max; return result; } int main(int argc, const char * argv[]) { size_t const count = 1000000; uint32_t inputValues[count]; // 使用随机数字填充 inputValues for (size_t i = 0; i \u0026lt; count; ++i) { inputValues[i] = arc4random(); } // 开始4个寻找最小值和最大值的线程 size_t const threadCount = 4; pthread_t tid[threadCount]; for (size_t i = 0; i \u0026lt; threadCount; ++i) { struct threadInfo * const info = (struct threadInfo *) malloc(sizeof(*info)); size_t offset = (count / threadCount) * i; info-\u0026gt;inputValues = inputValues + offset; info-\u0026gt;count = MIN(count - offset, count / threadCount); int err = pthread_create(tid + i, NULL, \u0026amp;findMinAndMax, info); NSCAssert(err == 0, @\u0026quot;pthread_create() failed: %d\u0026quot;, err); } // 等待线程退出 struct threadResult * results[threadCount]; for (size_t i = 0; i \u0026lt; threadCount; ++i) { int err = pthread_join(tid[i], (void **) \u0026amp;(results[i])); NSCAssert(err == 0, @\u0026quot;pthread_join() failed: %d\u0026quot;, err); } // 寻找 min 和 max uint32_t min = UINT32_MAX; uint32_t max = 0; for (size_t i = 0; i \u0026lt; threadCount; ++i) { min = MIN(min, results[i]-\u0026gt;min); max = MAX(max, results[i]-\u0026gt;max); free(results[i]); results[i] = NULL; } NSLog(@\u0026quot;min = %u\u0026quot;, min); NSLog(@\u0026quot;max = %u\u0026quot;, max); return 0; } 使用NSThread来写\n@interface FindMinMaxThread : NSThread @property (nonatomic) NSUInteger min; @property (nonatomic) NSUInteger max; - (instancetype)initWithNumbers:(NSArray *)numbers; @end @implementation FindMinMaxThread { NSArray *_numbers; } - (instancetype)initWithNumbers:(NSArray *)numbers { self = [super init]; if (self) { _numbers = numbers; } return self; } - (void)main { NSUInteger min; NSUInteger max; // 进行相关数据的处理 self.min = min; self.max = max; } @end //启动一个新的线程，创建一个线程对象 NSMutableSet *threads = [NSMutableSet set]; NSUInteger numberCount = self.numbers.count; NSUInteger threadCount = 4; for (NSUInteger i = 0; i \u0026lt; threadCount; i++) { NSUInteger offset = (count / threadCount) * i; NSUInteger count = MIN(numberCount - offset, numberCount / threadCount); NSRange range = NSMakeRange(offset, count); NSArray *subset = [self.numbers subarrayWithRange:range]; FindMinMaxThread *thread = [[FindMinMaxThread alloc] initWithNumbers:subset]; [threads addObject:thread]; [thread start]; } Grand Central Dispatch GCD中的FIFO队列称为dispatch queue，用来保证先进来的任务先得到执行。\ndispatch queue分三种\n Serial：又叫private dispatch queues，同时只执行一个任务。Serial queue常用于同步访问特定的资源或数据。当你创建多个Serial queue时，虽然各自是同步，但serial queue之间是并发执行。 Concurrent：又叫global dispatch queue，可以并发的执行多个任务，但执行完成顺序是随机的。 Main dispatch queue：全局可用的serial queue，在应用程序主线程上执行任务。  GCD概要  和operation queue一样都是基于队列的并发编程API，他们通过集中管理大家协同使用的线程池。 公开的5个不同队列：运行在主线程中的main queue，3个不同优先级的后台队列（High Priority Queue，Default Priority Queue，Low Priority Queue），以及一个优先级更低的后台队列Background Priority Queue（用于I/O） 可创建自定义队列：串行或并列队列。自定义一般放在Default Priority Queue和Main Queue里。  dispatch_once用法 + (UIColor *)boringColor; { static UIColor *color; //只运行一次 static dispatch_once_t onceToken; dispatch_once(\u0026amp;onceToken, ^{ color = [UIColor colorWithRed:0.380f green:0.376f blue:0.376f alpha:1.000f]; }); return color; } dispatch_async（较常用） 可以避免界面会被一些耗时的操作卡死，比如读取网络数据，大数据IO，还有大量数据的数据库读写，这时需要在另一个线程中处理，然后通知主线程更新界面，GCD使用起来比NSThread和NSOperation方法要简单方便。\n//代码框架 dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ // 耗时的操作 dispatch_async(dispatch_get_main_queue(), ^{ // 更新界面 }); }); //下载图片的示例 dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ NSURL * url = [NSURL URLWithString:@\u0026quot;https://avatar.csdn.net/2/C/D/1_totogo2010.jpg\u0026quot;]; NSData * data = [[NSData alloc]initWithContentsOfURL:url]; UIImage *image = [[UIImage alloc]initWithData:data]; if (data != nil) { dispatch_async(dispatch_get_main_queue(), ^{ self.imageView.image = image; }); } }); dispatch_after延后执行 - (void)foo { double delayInSeconds = 2.0; dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t) (delayInSeconds * NSEC_PER_SEC)); dispatch_after(popTime, dispatch_get_main_queue(), ^(void){ [self bar]; }); } 范例，实现一个推迟出现弹出框提示，比如说提示用户评价等功能。\nfunc showOrHideNavPrompt() { let delayInSeconds = 1.0 let popTime = dispatch_time(DISPATCH_TIME_NOW, Int64(delayInSeconds * Double(NSEC_PER_SEC))) // 在这里声明推迟的时间 dispatch_after(popTime, GlobalMainQueue) { // 等待delayInSeconds将闭包异步到主队列 let count = PhotoManager.sharedManager.photos.count if count \u0026gt; 0 { self.navigationItem.prompt = nil } else { self.navigationItem.prompt = \u0026quot;Add photos with faces to Googlyify them!\u0026quot; } } } GCD队列 队列默认是串行的，只能执行一个单独的block，队列也可以是并行的，同一时间执行多个block\n- (id)init; { self = [super init]; if (self != nil) { NSString *label = [NSString stringWithFormat:@\u0026quot;%@.isolation.%p\u0026quot;, [self class], self]; self.isolationQueue = dispatch_queue_create([label UTF8String], 0); label = [NSString stringWithFormat:@\u0026quot;%@.work.%p\u0026quot;, [self class], self]; self.workQueue = dispatch_queue_create([label UTF8String], 0); } return self; } 5种队列，主队列（main queue）,四种通用调度队列，自己定制的队列。四种通用调度队列为\n QOS_CLASS_USER_INTERACTIVE：user interactive等级表示任务需要被立即执行提供好的体验，用来更新UI，响应事件等。这个等级最好保持小规模。 QOS_CLASS_USER_INITIATED：user initiated等级表示任务由UI发起异步执行。适用场景是需要及时结果同时又可以继续交互的时候。 QOS_CLASS_UTILITY：utility等级表示需要长时间运行的任务，伴有用户可见进度指示器。经常会用来做计算，I/O，网络，持续的数据填充等任务。这个任务节能。 QOS_CLASS_BACKGROUND：background等级表示用户不会察觉的任务，使用它来处理预加载，或者不需要用户交互和对时间不敏感的任务。  示例：后台加载显示图片\noverride func viewDidLoad() { super.viewDidLoad() dispatch_async(dispatch_get_global_queue(Int(QOS_CLASS_USER_INITIATED.value), 0)) { // 将工作从主线程转移到全局队列中，这是dispatch_async调用，异步提交保证调用线程会继续执行下去，这样viewDidLoad在主线程上能够更早完成， let overlayImage = self.faceOverlayImageFromImage(self.image) dispatch_async(dispatch_get_main_queue()) { // 新图完成，把一个闭包加入主线程用来更新UIImageView，只有在主线程能操作UIKit。 self.fadeInNewImage(overlayImage) // 更新UI } } } 何时使用何种队列类型\n 主队列（顺序）：队列中有任务完成需要更新UI时，dispatch_after在这种类型中使用。 并发队列：用来执行与UI无关的后台任务，dispatch_sync放在这里，方便等待任务完成进行后续处理或和dispatch barrier同步。dispatch groups放在这里也不错。 自定义顺序队列：顺序执行后台任务并追踪它时。这样做同时只有一个任务在执行可以防止资源竞争。dipatch barriers解决读写锁问题的放在这里处理。dispatch groups也是放在这里。  可以使用下面的方法简化QoS等级参数的写法\nvar GlobalMainQueue: dispatch_queue_t { return dispatch_get_main_queue() } var GlobalUserInteractiveQueue: dispatch_queue_t { return dispatch_get_global_queue(Int(QOS_CLASS_USER_INTERACTIVE.value), 0) } var GlobalUserInitiatedQueue: dispatch_queue_t { return dispatch_get_global_queue(Int(QOS_CLASS_USER_INITIATED.value), 0) } var GlobalUtilityQueue: dispatch_queue_t { return dispatch_get_global_queue(Int(QOS_CLASS_UTILITY.value), 0) } var GlobalBackgroundQueue: dispatch_queue_t { return dispatch_get_global_queue(Int(QOS_CLASS_BACKGROUND.value), 0) } //使用起来就是这样，易读而且容易看出在使用哪个队列 dispatch_async(GlobalUserInitiatedQueue) { let overlayImage = self.faceOverlayImageFromImage(self.image) dispatch_async(GlobalMainQueue) { self.fadeInNewImage(overlayImage) } } 使用Barrier Task方法Dispatch Barrier解决多线程并发读写同一个资源发生死锁 Dispatch Barrier确保提交的闭包是指定队列中在特定时段唯一在执行的一个。在所有先于Dispatch Barrier的任务都完成的情况下这个闭包才开始执行。轮到这个闭包时barrier会执行这个闭包并且确保队列在此过程不会执行其它任务。闭包完成后队列恢复。\n//创建队列 self.isolationQueue = dispatch_queue_create([label UTF8String], DISPATCH_QUEUE_CONCURRENT); //改变setter - (void)setCount:(NSUInteger)count forKey:(NSString *)key { key = [key copy]; //确保所有barrier都是async异步的 dispatch_barrier_async(self.isolationQueue, ^(){ if (count == 0) { [self.counts removeObjectForKey:key]; } else { self.counts[key] = @(count); } }); } swift示例\n//使用dispatch_queue_create初始化一个并发队列。第一个参数遵循反向DNS命名习惯，方便描述，第二个参数是指出是并发还是顺序。 private let concurrentPhotoQueue = dispatch_queue_create( \u0026quot;com.raywenderlich.GooglyPuff.photoQueue\u0026quot;, DISPATCH_QUEUE_CONCURRENT) func addPhoto(photo: Photo) { dispatch_barrier_async(concurrentPhotoQueue) { // 将写操作加入到自定义的队列。开始执行时这个就是队列中唯一的一个在执行的任务。 self._photos.append(photo) // barrier能够保障不会和其他任务同时进行。 dispatch_async(GlobalMainQueue) { // 涉及到UI所以这个通知应该在主线程中，所以分派另一个异步任务到主队列中。 self.postContentAddedNotification() } } } //上面是解决了写可能发生死锁，下面是使用dispatch_sync解决读时可能会发生的死锁。 var photos: [Photo] { var photosCopy: [Photo]! dispatch_sync(concurrentPhotoQueue) { // 同步调度到concurrentPhotoQueue队列执行读操作 photosCopy = self._photos // 保存 } return photosCopy } //这样读写问题都解决了。 都用异步处理避免死锁，异步的缺点在于调试不方便，但是比起同步容易产生死锁这个副作用还算小的。\n异步API写法 设计一个异步的API调用dispatch_async()，这个调用放在API的方法或函数中做。让API的使用者设置一个回调处理队列\n- (void)processImage:(UIImage *)image completionHandler:(void(^)(BOOL success))handler; { dispatch_async(self.isolationQueue, ^(void){ // do actual processing here dispatch_async(self.resultQueue, ^(void){ handler(YES); }); }); } dispatch_apply进行快速迭代 for (size_t y = 0; y \u0026lt; height; ++y) { for (size_t x = 0; x \u0026lt; width; ++x) { // Do something with x and y here } } //使用dispatch_apply可以运行的更快 dispatch_apply(height, dispatch_get_global_queue(0, 0), ^(size_t y) { for (size_t x = 0; x \u0026lt; width; x += 2) { // Do something with x and y here } }); 示例：\nfunc downloadPhotosWithCompletion(completion: BatchPhotoDownloadingCompletionClosure?) { var storedError: NSError! var downloadGroup = dispatch_group_create() let addresses = [OverlyAttachedGirlfriendURLString, SuccessKidURLString, LotsOfFacesURLString] dispatch_apply(UInt(addresses.count), GlobalUserInitiatedQueue) { i in let index = Int(i) let address = addresses[index] let url = NSURL(string: address) dispatch_group_enter(downloadGroup) let photo = DownloadPhoto(url: url!) { image, error in if let error = error { storedError = error } dispatch_group_leave(downloadGroup) } PhotoManager.sharedManager.addPhoto(photo) } dispatch_group_notify(downloadGroup, GlobalMainQueue) { if let completion = completion { completion(error: storedError) } } } Block组合Dispatch_groups dispatch groups是专门用来监视多个异步任务。dispatch_group_t实例用来追踪不同队列中的不同任务。\n当group里所有事件都完成GCD API有两种方式发送通知，第一种是dispatch_group_wait，会阻塞当前进程，等所有任务都完成或等待超时。第二种方法是使用dispatch_group_notify，异步执行闭包，不会阻塞。\n第一种使用dispatch_group_wait的swift的例子：\nfunc downloadPhotosWithCompletion(completion: BatchPhotoDownloadingCompletionClosure?) { dispatch_async(GlobalUserInitiatedQueue) { // 因为dispatch_group_wait会租塞当前进程，所以要使用dispatch_async将整个方法要放到后台队列才能够保证主线程不被阻塞 var storedError: NSError! var downloadGroup = dispatch_group_create() // 创建一个dispatch group for address in [OverlyAttachedGirlfriendURLString, SuccessKidURLString, LotsOfFacesURLString] { let url = NSURL(string: address) dispatch_group_enter(downloadGroup) // dispatch_group_enter是通知dispatch group任务开始了，dispatch_group_enter和dispatch_group_leave是成对调用，不然程序就崩溃了。 let photo = DownloadPhoto(url: url!) { image, error in if let error = error { storedError = error } dispatch_group_leave(downloadGroup) // 保持和dispatch_group_enter配对。通知任务已经完成 } PhotoManager.sharedManager.addPhoto(photo) } dispatch_group_wait(downloadGroup, DISPATCH_TIME_FOREVER) // dispatch_group_wait等待所有任务都完成直到超时。如果任务完成前就超时了，函数会返回一个非零值，可以通过返回值判断是否超时。也可以用DISPATCH_TIME_FOREVER表示一直等。 dispatch_async(GlobalMainQueue) { // 这里可以保证所有图片任务都完成，然后在main queue里加入完成后要处理的闭包，会在main queue里执行。 if let completion = completion { // 执行闭包内容 completion(error: storedError) } } } } 第二种使用dispatch_group_notify的swift的例子：\nfunc downloadPhotosWithCompletion(completion: BatchPhotoDownloadingCompletionClosure?) { // 不用加dispatch_async，因为没有阻塞主进程 var storedError: NSError! var downloadGroup = dispatch_group_create() for address in [OverlyAttachedGirlfriendURLString, SuccessKidURLString, LotsOfFacesURLString] { let url = NSURL(string: address) dispatch_group_enter(downloadGroup) let photo = DownloadPhoto(url: url!) { image, error in if let error = error { storedError = error } dispatch_group_leave(downloadGroup) } PhotoManager.sharedManager.addPhoto(photo) } dispatch_group_notify(downloadGroup, GlobalMainQueue) { // dispatch_group_notify和dispatch_group_wait的区别就是是异步执行闭包的，当dispatch groups中没有剩余的任务时闭包才执行。这里是指明在主队列中执行。 if let completion = completion { completion(error: storedError) } } } dispatch_group_t group = dispatch_group_create(); dispatch_queue_t queue = dispatch_get_global_queue(0, 0); dispatch_group_async(group, queue, ^(){ // 会处理一会 [self doSomeFoo]; dispatch_group_async(group, dispatch_get_main_queue(), ^(){ self.foo = 42; }); }); dispatch_group_async(group, queue, ^(){ // 处理一会儿 [self doSomeBar]; dispatch_group_async(group, dispatch_get_main_queue(), ^(){ self.bar = 1; }); }); // 上面的都搞定后这里会执行一次 dispatch_group_notify(group, dispatch_get_main_queue(), ^(){ NSLog(@\u0026quot;foo: %d\u0026quot;, self.foo); NSLog(@\u0026quot;bar: %d\u0026quot;, self.bar); }); 如何对现有API使用dispatch_group_t\n//给Core Data的-performBlock:添加groups。组合完成任务后使用dispatch_group_notify来运行一个block即可。 - (void)withGroup:(dispatch_group_t)group performBlock:(dispatch_block_t)block { if (group == NULL) { [self performBlock:block]; } else { dispatch_group_enter(group); [self performBlock:^(){ block(); dispatch_group_leave(group); }]; } } //NSURLConnection也可以这样做 + (void)withGroup:(dispatch_group_t)group sendAsynchronousRequest:(NSURLRequest *)request queue:(NSOperationQueue *)queue completionHandler:(void (^)(NSURLResponse*, NSData*, NSError*))handler { if (group == NULL) { [self sendAsynchronousRequest:request queue:queue completionHandler:handler]; } else { dispatch_group_enter(group); [self sendAsynchronousRequest:request queue:queue completionHandler:^(NSURLResponse *response, NSData *data, NSError *error){ handler(response, data, error); dispatch_group_leave(group); }]; } } 注意事项\n dispatch_group_enter() 必须运行在 dispatch_group_leave() 之前。 dispatch_group_enter() 和 dispatch_group_leave() 需要成对出现的  使用dispatch block object（调度块）在任务执行前进行取消 dispatch block object可以为队列中的对象设置 示例，下载图片中途进行取消\nfunc downloadPhotosWithCompletion(completion: BatchPhotoDownloadingCompletionClosure?) { var storedError: NSError! let downloadGroup = dispatch_group_create() var addresses = [OverlyAttachedGirlfriendURLString, SuccessKidURLString, LotsOfFacesURLString] addresses += addresses + addresses // 扩展address数组，复制3份 var blocks: [dispatch_block_t] = [] // 一个保存block的数组 for i in 0 ..\u0026lt; addresses.count { dispatch_group_enter(downloadGroup) let block = dispatch_block_create(DISPATCH_BLOCK_INHERIT_QOS_CLASS) { // 创建一个block，block的标志是DISPATCH_BLOCK_INHERIT_QOS_CLASS let index = Int(i) let address = addresses[index] let url = NSURL(string: address) let photo = DownloadPhoto(url: url!) { image, error in if let error = error { storedError = error } dispatch_group_leave(downloadGroup) } PhotoManager.sharedManager.addPhoto(photo) } blocks.append(block) dispatch_async(GlobalMainQueue, block) // 把这个block放到GlobalMainQueue上异步调用。因为全局队列是一个顺序队列所以方便取消对象block，同时可以保证下载任务在downloadPhotosWithCompletion返回后才开始执行。 } for block in blocks[3 ..\u0026lt; blocks.count] { let cancel = arc4random_uniform(2) // 随机返回一个整数，会返回0或1 if cancel == 1 { dispatch_block_cancel(block) // 如果是1就取消block，这个只能发生在block还在队列中并没有开始的情况下。因为把block已经放到了GlobalMainQueue中，所以这个地方会先执行，执行完了才会执行block。 dispatch_group_leave(downloadGroup) // 因为已经dispatch_group_enter了，所以取消时也要将其都leave掉。 } } dispatch_group_notify(downloadGroup, GlobalMainQueue) { if let completion = completion { completion(error: storedError) } } } 用GCD监视进程 NSRunningApplication *mail = [NSRunningApplication runningApplicationsWithBundleIdentifier:@\u0026quot;com.apple.mail\u0026quot;]; if (mail == nil) { return; } pid_t const pid = mail.processIdentifier; self.source = dispatch_source_create(DISPATCH_SOURCE_TYPE_PROC, pid, DISPATCH_PROC_EXIT, DISPATCH_TARGET_QUEUE_DEFAULT); dispatch_source_set_event_handler(self.source, ^(){ NSLog(@\u0026quot;Mail quit.\u0026quot;); }); //在事件源传到你的事件处理前需要调用dispatch_resume()这个方法 dispatch_resume(self.source); 监视文件夹内文件变化 NSURL *directoryURL; // assume this is set to a directory int const fd = open([[directoryURL path] fileSystemRepresentation], O_EVTONLY); if (fd \u0026lt; 0) { char buffer[80]; strerror_r(errno, buffer, sizeof(buffer)); NSLog(@\u0026quot;Unable to open \\\u0026quot;%@\\\u0026quot;: %s (%d)\u0026quot;, [directoryURL path], buffer, errno); return; } dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_VNODE, fd, DISPATCH_VNODE_WRITE | DISPATCH_VNODE_DELETE, DISPATCH_TARGET_QUEUE_DEFAULT); dispatch_source_set_event_handler(source, ^(){ unsigned long const data = dispatch_source_get_data(source); if (data \u0026amp; DISPATCH_VNODE_WRITE) { NSLog(@\u0026quot;The directory changed.\u0026quot;); } if (data \u0026amp; DISPATCH_VNODE_DELETE) { NSLog(@\u0026quot;The directory has been deleted.\u0026quot;); } }); dispatch_source_set_cancel_handler(source, ^(){ close(fd); }); self.source = source; dispatch_resume(self.source); //还要注意需要用DISPATCH_VNODE_DELETE 去检查监视的文件或文件夹是否被删除，如果删除了就停止监听 GCD版定时器 dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER,0, 0, DISPATCH_TARGET_QUEUE_DEFAULT); dispatch_source_set_event_handler(source, ^(){ NSLog(@\u0026quot;Time flies.\u0026quot;); }); dispatch_time_t start dispatch_source_set_timer(source, DISPATCH_TIME_NOW, 5ull * NSEC_PER_SEC,100ull * NSEC_PER_MSEC); self.source = source; dispatch_resume(self.source); GCD深入操作  缓冲区：dispatch_data_t基于零碎的内存区域，使用dispatch_data_apply来遍历，还可以用dispatch_data_create_subrange来创建一个不做任何拷贝的子区域 I/O调度：使用GCD提供的dispatch_io_read，dispatch_io_write和dispatch_io_close 测试：使用dispatch_benchmark小工具 原子操作： libkern/OSAtomic.h里可以查看那些函数，用于底层多线程编程。  Cocoa NSOperation 使用NSOperation的两种方式。一种用定义好的两个子类NSInvocationOperation和NSBlockOperation，另一个是继承NSOperation。\nNSOperation是设计用来扩展的，只需继承重写NSOperation的一个方法main，然后把NSOperation子类的对象放入NSOperationQueue队列中，该队列就会启动并开始处理它。\nNSInvocationOperation例子\n#import \u0026quot;ViewController.h\u0026quot; #define kURL @\u0026quot;https://avatar.csdn.net/2/C/D/1_totogo2010.jpg\u0026quot; @interface ViewController () @end @implementation ViewController - (void)viewDidLoad { [super viewDidLoad]; NSInvocationOperation *operation = [[NSInvocationOperation alloc]initWithTarget:self selector:@selector(downloadImage:) object:kURL]; NSOperationQueue *queue = [[NSOperationQueue alloc]init]; [queue addOperation:operation]; //放进去就开始了 // Do any additional setup after loading the view, typically from a nib. } -(void)downloadImage:(NSString *)url{ NSLog(@\u0026quot;url:%@\u0026quot;, url); NSURL *nsUrl = [NSURL URLWithString:url]; NSData *data = [[NSData alloc]initWithContentsOfURL:nsUrl]; UIImage * image = [[UIImage alloc]initWithData:data]; [self performSelectorOnMainThread:@selector(updateUI:) withObject:image waitUntilDone:YES]; } -(void)updateUI:(UIImage*) image{ self.imageView.image = image; }  Operation Queue是在GCD上实现了一些方便的功能。优点是不需要关心线程管理，数据同步。Cocoa operation相关的类是NSOperation，NSOperationQueue。 NSOperationQueue有主队列和自定义队列两种类型队列。主队列在主线程上运行，自定义队列在后台。 重写main方法自定义自己的operations。较简单，不需要管理isExecuting和isFinished，main返回时operation就结束了。  @implementation YourOperation - (void)main { // 进行处理 ... } @end  重写start方法能够获得更多的控制权，还可以在一个操作中执行异步任务  @implementation YourOperation - (void)start { self.isExecuting = YES; self.isFinished = NO; // 开始处理，在结束时应该调用 finished ... } - (void)finished { self.isExecuting = NO; self.isFinished = YES; } @end //使操作队列有取消功能，需要不断检查isCancelled属性 - (void)main { while (notDone \u0026amp;\u0026amp; !self.isCancelled) { // 进行处理 } }  定义好operation类以后，将一个operation加到队列里：  NSOperationQueue *queue = [[NSOperationQueue alloc] init]; YourOperation *operation = [[YourOperation alloc] init]; [queue addOperation:operation];  如果是在主队列中进行一个一次性任务，可以将block加到操作队列  [[NSOperationQueue mainQueue] addOperationWithBlock:^{ // 代码... }];  通过maxConcurrentOperationCount属性控制一个特定队列中并发执行操作的数量。设置为1就是串行队列。 对operation优先级排序，指定operation之间的依赖关系。  //确保operation1和operation2是在intermediateOperation和finishOperation之前执行 [intermediateOperation addDependency:operation1]; [intermediateOperation addDependency:operation2]; [finishedOperation addDependency:intermediateOperation]; NSThread NSThread抽象度最高，也是Apple所推荐的。缺点是需要自己管理线程的生命周期，线程同步。线程同步对数据加锁会有一定系统开销。NSThread实现的技术有三种\n Cocoa threads POSIX threads Multiprocessing Services  创建方式 - (id)initWithTarget:(id)target selector:(SEL)selector object:(id)argument //实例方法 + (void)detachNewThreadSelector:(SEL)aSelector toTarget:(id)aTarget withObject:(id)anArgument //类方法 //直接创建线程并且运行 1、[NSThread detachNewThreadSelector:@selector(doSomething:) toTarget:self withObject:nil]; //先创建线程对象，再运行线程操作，运行前可以设置线程优先级等线程信息。 2、NSThread* myThread = [[NSThread alloc] initWithTarget:self selector:@selector(doSomething:) object:nil]; [myThread start]; //不显式创建线程的方法，使用NSObject的类方法创建一个线程 3、[Obj performSelectorInBackground:@selector(doSomething) withObject:nil]; 示例\n#import \u0026quot;ViewController.h\u0026quot; #define kURL @\u0026quot;https://avatar.csdn.net/2/C/D/1_totogo2010.jpg\u0026quot; @interface ViewController () @end @implementation ViewController -(void)downloadImage:(NSString *) url{ NSData *data = [[NSData alloc] initWithContentsOfURL:[NSURL URLWithString:url]]; UIImage *image = [[UIImage alloc]initWithData:data]; if(image == nil){ }else{ //更新主线程外的数据使用performSelector:onThread:withObject:waitUntilDone: [self performSelectorOnMainThread:@selector(updateUI:) withObject:image waitUntilDone:YES]; } } -(void)updateUI:(UIImage*) image{ self.imageView.image = image; } - (void)viewDidLoad { [super viewDidLoad]; // [NSThread detachNewThreadSelector:@selector(downloadImage:) toTarget:self withObject:kURL]; NSThread *thread = [[NSThread alloc]initWithTarget:self selector:@selector(downloadImage:) object:kURL]; [thread start]; } @end NSThread的线程同步，使用NSLock 卖票的例子\n#import \u0026lt;UIKit/UIKit.h\u0026gt; @class ViewController; @interface AppDelegate : UIResponder \u0026lt;UIApplicationDelegate\u0026gt; { int tickets; int count; NSThread* ticketsThreadone; NSThread* ticketsThreadtwo; NSCondition* ticketsCondition; NSLock *theLock; } @property (strong, nonatomic) UIWindow *window; @property (strong, nonatomic) ViewController *viewController; @end - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions { tickets = 100; count = 0; theLock = [[NSLock alloc] init]; // 锁对象 ticketsCondition = [[NSCondition alloc] init]; ticketsThreadone = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil]; [ticketsThreadone setName:@\u0026quot;Thread-1\u0026quot;]; [ticketsThreadone start]; ticketsThreadtwo = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil]; [ticketsThreadtwo setName:@\u0026quot;Thread-2\u0026quot;]; [ticketsThreadtwo start]; self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]]; // Override point for customization after application launch. self.viewController = [[ViewController alloc] initWithNibName:@\u0026quot;ViewController\u0026quot; bundle:nil]; self.window.rootViewController = self.viewController; [self.window makeKeyAndVisible]; return YES; } - (void)run{ while (TRUE) { // 上锁 // [ticketsCondition lock]; [theLock lock]; if(tickets \u0026gt;= 0){ [NSThread sleepForTimeInterval:0.09]; count = 100 - tickets; NSLog(@\u0026quot;当前票数是:%d,售出:%d,线程名:%@\u0026quot;,tickets,count,[[NSThread currentThread] name]); tickets--; }else{ break; } [theLock unlock]; // [ticketsCondition unlock]; } } 没有线程同步lock,卖票数可能会是-1.加上能够保证数据的正确。\nNSThread线程的顺序执行同步 可以通过[NSCondition signal]的方式发送信号，在一个线程唤醒另一个线程等待\n#import \u0026quot;AppDelegate.h\u0026quot; #import \u0026quot;ViewController.h\u0026quot; @implementation AppDelegate - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions { tickets = 100; count = 0; theLock = [[NSLock alloc] init]; // 锁对象 ticketsCondition = [[NSCondition alloc] init]; ticketsThreadone = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil]; [ticketsThreadone setName:@\u0026quot;Thread-1\u0026quot;]; [ticketsThreadone start]; ticketsThreadtwo = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil]; [ticketsThreadtwo setName:@\u0026quot;Thread-2\u0026quot;]; [ticketsThreadtwo start]; NSThread *ticketsThreadthree = [[NSThread alloc] initWithTarget:self selector:@selector(run3) object:nil]; [ticketsThreadthree setName:@\u0026quot;Thread-3\u0026quot;]; [ticketsThreadthree start]; self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]]; // Override point for customization after application launch. self.viewController = [[ViewController alloc] initWithNibName:@\u0026quot;ViewController\u0026quot; bundle:nil]; self.window.rootViewController = self.viewController; [self.window makeKeyAndVisible]; return YES; } -(void)run3{ while (YES) { [ticketsCondition lock]; [NSThread sleepForTimeInterval:3]; [ticketsCondition signal]; [ticketsCondition unlock]; } } - (void)run{ while (TRUE) { // 上锁 [ticketsCondition lock]; [ticketsCondition wait]; [theLock lock]; if(tickets \u0026gt;= 0){ [NSThread sleepForTimeInterval:0.09]; count = 100 - tickets; NSLog(@\u0026quot;当前票数是:%d,售出:%d,线程名:%@\u0026quot;,tickets,count,[[NSThread currentThread] name]); tickets--; }else{ break; } [theLock unlock]; [ticketsCondition unlock]; } } wait是等待，假啊一个线程3去唤醒其它两个线程锁中的wait\n其它同步 可以使用@synchronized来简化NSLock使用，这样就不必显示编写创建NSLock加锁并解锁相关代码。\n- (void)doSomeThing:(id)anObj { @synchronized(anObj) { // Everything between the braces is protected by the @synchronized directive. } } 还有些其它的锁对象，比如循环锁NSRecursiveLock，条件锁NSConditionLock，分布式锁NSDistributedLock等，可查阅官方文档。\nRun Loops  Run loop比GCD和操作队列要容易，不必处理并发中复杂情况就能异步执行。 主线程配置main run loop，其它线程默认都没有配置run loop。一般都在主线程中调用后分配给其它队列。如果要在其它线程添加run loop至少添加一个input source，不然一运行就会退出。  在后台操作UI 使用操作队列处理 //weak引用参照self避免循环引用，及block持有self，operationQueue retain了block，而self有retain了operationQueue。 __weak id weakSelf = self; [self.operationQueue addOperationWithBlock:^{ NSNumber* result = findLargestMersennePrime(); [[NSOperationQueue mainQueue] addOperationWithBlock:^{ MyClass* strongSelf = weakSelf; strongSelf.textLabel.text = [result stringValue]; }]; }]; drawRect在后台绘制 drawRect:方法会影响性能，所以可以放到后台执行。\n//使用UIGraphicsBeginImageContextWithOptions取代UIGraphicsGetCurrentContext:方法 UIGraphicsBeginImageContextWithOptions(size, NO, 0); // drawing code here UIImage *i = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return i; 可以把这个方法运用到table view中，使table view的cell在滚出边界时能在didEndDisplayingCell委托方法中取消。WWDC中有讲解：Session 211 \u0026ndash; Building Concurrent User Interfaces on iOS https://developer.apple.com/videos/wwdc/2012/\n还有个使用CALayer里drawsAsynchronously属性的方法。不过有时work，有时不一定。\n网络异步请求 网络都要使用异步方式，但是不要直接使用dispatch_async，这样没法取消这个网络请求。dataWithContentsOfURL:的超时是30秒，那么这个线程需要干等到超时完。解决办法就是使用NSURLConnection的异步方法，把所有操作转化成operation来执行。NSURLConnection是通过run loop来发送事件的。AFNetworking是建立一个独立的线程设置一个非main run loop。下面是处理URL连接重写自定义operation子类里的start方法\n- (void)start { NSURLRequest* request = [NSURLRequest requestWithURL:self.url]; self.isExecuting = YES; self.isFinished = NO; [[NSOperationQueue mainQueue] addOperationWithBlock:^ { self.connection = [NSURLConnectionconnectionWithRequest:request delegate:self]; }]; } 重写start方法需要管理isExecuting和isFinished状态。下面是取消操作的方法\n- (void)cancel { [super cancel]; [self.connection cancel]; self.isFinished = YES; self.isExecuting = NO; } //连接完成发送回调 - (void)connectionDidFinishLoading:(NSURLConnection *)connection { self.data = self.buffer; self.buffer = nil; self.isExecuting = NO; self.isFinished = YES; } 后台处理I/O 异步处理文件可以使用NSInputStream。官方文档：https://developer.apple.com/library/ios/#documentation/FileManagement/Conceptual/FileSystemProgrammingGUide/TechniquesforReadingandWritingCustomFiles/TechniquesforReadingandWritingCustomFiles.html 实例：https://github.com/objcio/issue-2-background-file-io\n@interface Reader : NSObject - (void)enumerateLines:(void (^)(NSString*))block completion:(void (^)())completion; - (id)initWithFileAtPath:(NSString*)path; //采用main run loop的事件将数据发到后台操作线程去处理 - (void)enumerateLines:(void (^)(NSString*))block completion:(void (^)())completion { if (self.queue == nil) { self.queue = [[NSOperationQueue alloc] init]; self.queue.maxConcurrentOperationCount = 1; } self.callback = block; self.completion = completion; self.inputStream = [NSInputStream inputStreamWithURL:self.fileURL]; self.inputStream.delegate = self; [self.inputStream scheduleInRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode]; [self.inputStream open]; } @end //input stream在主线程中发送代理消息，接着就可以在操作队列加入block操作 - (void)stream:(NSStream*)stream handleEvent:(NSStreamEvent)eventCode { switch (eventCode) { ... case NSStreamEventHasBytesAvailable: { NSMutableData *buffer = [NSMutableData dataWithLength:4 * 1024]; NSUInteger length = [self.inputStream read:[buffer mutableBytes] maxLength:[buffer length]]; if (0 \u0026lt; length) { [buffer setLength:length]; __weak id weakSelf = self; [self.queue addOperationWithBlock:^{ [weakSelf processDataChunk:buffer]; }]; } break; } ... } } //处理数据chunk，原理就是把数据切成很多小块，然后不断更新和处理buffer缓冲区，逐块读取和存入方式来处理大文件响应快而且内存开销也小。 - (void)processDataChunk:(NSMutableData *)buffer; { if (self.remainder != nil) { [self.remainder appendData:buffer]; } else { self.remainder = buffer; } [self.remainder obj_enumerateComponentsSeparatedBy:self.delimiter usingBlock:^(NSData* component, BOOL last) { if (!last) { [self emitLineWithData:component]; } else if (0 \u0026lt; [component length]) { self.remainder = [component mutableCopy]; } else { self.remainder = nil; } }]; } 并发开发会遇到的困难问题 多个线程访问共享资源 比如两个线程都会把计算结果写到一个整型数中。为了防止，需要一种互斥机制来访问共享资源\n互斥锁 同一时刻只能有一个线程访问某个资源。某线程要访问某个共享资源先获得共享资源的互斥锁，完成操作再释放这个互斥锁，然后其它线程就能访问这个共享资源。\n还有需要解决无序执行问题，这时就需要引入内存屏障。\n在Objective-C中如果属性声明为atomic就能够支持互斥锁，但是因为加解锁会有性能代价，所以一般是声明noatomic的。\n死锁 当多个线程在相互等待对方锁结束时就会发生死锁，程序可能会卡住。\nvoid swap(A, B) { lock(lockA); lock(lockB); int a = A; int b = B; A = b; B = a; unlock(lockB); unlock(lockA); } //一般没问题，但是如果两个线程使用相反的值同时调用上面这个方法就可能会死锁。线程1获得X的一个锁，线程2获得Y的一个锁，它们会同时等待另一个锁的释放，但是却是没法等到的。 swap(X, Y); // 线程 1 swap(Y, X); // 线程 2 为了防止死锁，需要使用比简单读写锁更好的办法，比如write preferencehttps://en.wikipedia.org/wiki/Readers%E2%80%93writer_lock，或read-copy-update算法https://en.wikipedia.org/wiki/Read-copy-update\n优先级反转 运行时低优先级任务由于先取得了释放了锁的共享资源而阻塞了高优先级任务，这种情况叫做优先级反转\n最佳安全实践避免问题的方法 从主线程中取到数据，利用一个操作队列在后台处理数据，完后返回后台队列中得到的数据到主队列中。这样的操作不会有任何锁操作。\n并发测试  使用SenTestingKit框架测试：https://github.com/nxtbgthng/SenTestingKitAsync kiwi：https://github.com/allending/Kiwi GHunit：https://github.com/gabriel/gh-unit/ ming1016  ","title":"iOS并发编程"},{"link":"https://blog.policx.com/posts/beijing/","text":"   ","title":"月薪多少能撑起一个家？"},{"link":"https://blog.policx.com/posts/2year/","text":"","title":"融贝二周年"},{"link":"https://blog.policx.com/posts/linux/","text":"   ","title":"Linux"},{"link":"https://blog.policx.com/posts/nokia/","text":"","title":"诺基亚"},{"link":"https://blog.policx.com/posts/ios-zhinan/","text":"   ","title":"iOS界面元素指南"},{"link":"https://blog.policx.com/posts/git/","text":"同生活中的许多伟大事件一样，Git 诞生于一个极富纷争大举创新的年代。Linux 内核开源项目有着为数众广的参与者。绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上（1991－2002年间）。\n很多人都知道，Linus在1991年创建了开源的Linux，从此，Linux系统不断发展，已经成为最大的服务器系统软件了。\nLinus Torvalds 虽然创建了Linux，但Linux的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为Linux编写代码，那Linux的代码是如何管理的呢？\n事实是，在2002年以前，世界各地的志愿者把源代码文件通过diff的方式发给Linus，然后由Linus本人通过手工方式合并代码！\n你也许会想，为什么Linus不把Linux代码放到版本控制系统里呢？不是有CVS、SVN这些免费的版本控制系统吗？因为Linus坚定地反对CVS和SVN，这些集中式的版本控制系统不但速度慢，而且必须联网才能使用。有一些商用的版本控制系统，虽然比CVS、SVN好用，但那是付费的，和Linux的开源精神不符。\n不过，到了2002年，Linux系统已经发展了十年了，代码库之大让Linus很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是Linus选择了一个商业的版本控制系统BitKeeper，BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统。\n安定团结的大好局面在2005年就被打破了，原因是Linux社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发Samba的Andrew试图破解BitKeeper的协议（这么干的其实也不只他一个），被BitMover公司发现了（监控工作做得不错！），于是BitMover公司怒了，要收回Linux社区的免费使用权。\nLinus可以向BitMover公司道个歉，保证以后严格管教弟兄们，嗯，这是不可能的。\n开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了免费使用 BitKeeper 的权力。这就迫使 Linux 开源社区（特别是 Linux 的缔造者 Linus Torvalds ）不得不吸取教训，只有开发一套属于自己的版本控制系统才不至于重蹈覆辙。他们对新的系统制订了若干目标：\n 速度 简单的设计 对非线性开发模式的强力支持（允许上千个并行开发的分支） 完全分布式 有能力高效管理类似 Linux 内核一样的超大规模项目（速度和数据量）  最后实际情况是这样的：Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux系统的源码已经由Git管理了！牛是怎么定义的呢？大家可以感受一下。\nGit迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。\n历史就是这么偶然，如果不是当年BitMover公司威胁Linux社区，可能现在我们就没有免费而超级好用的Git了。\n","title":"GIT"},{"link":"https://blog.policx.com/posts/framework/","text":"   前言 之前有很多的大神们已经写过framework的制作，但最近由于Xcode7的出现，很多之前的教程内容已经不符，对于初学者来说，找到一篇能够直接明了，简单易学的制作framework的文章比较困难。本文将基于Xcode7创建一个简单的工程，通过两种方法来教大家如何制作一个自己的framework。\n简介 Mac OS X扩展了framework的功能，让我们能够利用它来共享代码和资源。通过framework我们可以共享所有形式的资源，如动态共享库，nib文件，图像字符资源以及文档等。 系统会在需要的时候将framework载入内存中，多个应用程序可以同时使用同一个framework。这种方法可以使得你的代码易分享，在多个工程中复用，并且可以隐藏实现细节，控制公开的头文件。\n制作 步骤  打开Xcode，创建新工程。手下留情，请先看图！  创建功能类。这里我创建一个继承自NSObject的SayHello类 在新创建的类里面声明方法并实现。这里我写一个 sayHello的方法，以便后面测试使用。   SayHello.h\n  #import \u0026lt;Foundation/Foundation.h\u0026gt; @interface SayHello : NSObject -(void)sayHello; @end  SayHello.m\n  #import \u0026quot;SayHello.h\u0026quot; @implementation SayHello -(void)sayHello { NSLog(@\u0026quot;你好，第一次见面，请多关照\u0026quot;); } @end  在TARGETS下选中工程，在Build Settings下更改几个参数。   在Architectures下增加armv7s，并选中。将Build Active Architecture Only 设置为NO。  设置Headers 将你要公开的头文件移动到Public下，要隐藏的放在Private或者Project下，当然，隐藏的头文件就无法再被引用。   然后需要在Test.h（必须是公开的，否则无法引用）中将你所有要公开的.h引入。 打包framework\n 方法一    选中模拟器，编译程序\n  选中测试机，编译程序\n  在finder中找到framework文件   选中图中所标示的framework，然后右键show in finder。 找到下图中所示的Test文件，一个是Debug-iphoneos（真机）下的，一个是Debug-iphonesimulator(模拟器)下的。 4.通过终端命令将两个framework合为一个模拟器和真机都可使用的framework。\n打开控制台输入 lipo -create iphoneos下frameworkTest的路径 simulator下frameworkTest的路径 -output 新的路径，这样就完成了模拟器和真机版本的合并，新路径下的frameworkTest就是你合并后的文件，将这个文件名字改成和你未合并之前的Test一样的名字，放到framework文件夹下，替换掉原来的frameworkTest文件。 上面这段命令就是把真机和模拟器的frameworkTest合并成一个MyNewFrameworktest文件并存放在桌面上的New文件夹下。 5.将修改后的framework拷贝出来保存，这就是我们最终制作的framework。\n 方法二 1.选中TARGETS下的工程，点击上方的Editor,选择Add Target创建一个Aggregate.   选择Other下的Aggregate，点击Next创建。 2.嵌入脚本。选中刚刚创建的Aggregate,然后选中右侧的Build Phases,点击左下方加号，选择New Run Script Phase 将这段脚本复制进去。\n # Sets the target folders and the final framework product. # 如果工程名称和Framework的Target名称不一样的 话，要自定义FMKNAME # 例如: FMK_NAME = \u0026quot;MyFramework\u0026quot; FMK_NAME=${PROJECT_NAME} # Install dir will be the final output to the framework. # The following line create it in the root folder of the current project. INSTALL_DIR=${SRCROOT}/Products/$ {FMK_NAME}.framework # Working dir will be deleted after the framework creation. WRK_DIR=build DEVICE_DIR=${WRK_DIR}/Release-iphoneos/$ {FMK_NAME}.framework SIMULATOR_DIR=${WRK_DIR}/Release- iphonesimulator/${FMK_NAME}.framework # -configuration ${CONFIGURATION} # Clean and Building both architectures. xcodebuild -configuration \u0026quot;Release\u0026quot; -target \u0026quot;${FMK_NAME}\u0026quot; -sdk iphoneos clean build xcodebuild -configuration \u0026quot;Release\u0026quot; -target \u0026quot;${FMK_NAME}\u0026quot; -sdk iphonesimulator clean build # Cleaning the oldest. if [ -d \u0026quot;${INSTALL_DIR}\u0026quot; ] then rm -rf \u0026quot;${INSTALL_DIR}\u0026quot; fi mkdir -p \u0026quot;${INSTALL_DIR}\u0026quot; cp -R \u0026quot;${DEVICE_DIR}/\u0026quot; \u0026quot;${INSTALL_DIR}/\u0026quot; # Uses the Lipo Tool to merge both binary files (i386 + armv6/armv7) into one Universal final product. lipo -create \u0026quot;${DEVICE_DIR}/${FMK_NAME}\u0026quot; \u0026quot;${SIMULATOR_DIR}/${FMK_NAME}\u0026quot; -output \u0026quot;$ {INSTALL_DIR}/${FMK_NAME}\u0026quot; rm -r \u0026quot;${WRK_DIR}\u0026quot; open \u0026quot;${INSTALL_DIR}\u0026quot; 3.编译。如图所示，command+B编译。 4.在finder中找到framework，拷贝出来。\n 使用制作完成的framework 直接将你制作出来的framework添加到要使用的工程里，在需要使用的文件里引入头文件，使用framework中的功能类。如下图   提醒   在制作framework或者lib的时候，如果使用了category，则使用改FMWK的程序运行时会crash，此时需要在该工程中 other linker flags添加两个参数 -ObjC -all_load.\n  带有图片资源的需要把图片打包成Bundle文件，和framework一起拷贝到相应的项目中。\n  公开的类中如果引用的private的类，打包以后对外会报错，找不到那个private的类，可以把那个private的.h放到\n  结言 现在，相信你已经可以按照文档步骤制作出一个framework，相信过程中可能还会遇到一些问题，希望大家能够把这些问题记录并整理，将这些经验分享出来。也欢迎大家联系、讨论。 最后，希望大家能完成带有图片资源的Bundle的制作。\nTry your best!\n","title":"iOS-制作Framework"},{"link":"https://blog.policx.com/posts/programmer/","text":"有人说，每个看起来与正常人无异的工程师，其实都是在学习程序开发的途中熬过、压抑过、而且创伤过的反社会人士(sociopaths)。\n在学习程序开发的过程中，常常看到网络上的「甘苦谈」，也听过身边前途一片光明的工程师朋友们分享过学习历程，总觉得不同的人、同样的故事却不断的重复，像是狼叫声般，从远处传来一声又一声的回响。\n最近读到Erik Trautman在Viking Code School部落格中的文章《Why Learning to Code is So Damn Hard》，文章里将学习写程序(Learn to Code)的过程分成了四个阶段，并解释了两个影响各阶段形成的关键因素「资料密度」以及「知识广度」，最后集合成这张图：\n这篇文章很有趣也十分符合我所听闻的那些「工程师辛酸史」，因此决定将这四个阶段介绍给大家，希望程序初学者们在进入这条不归路之前，眼睛要放亮、计划要周详，清楚明白在前方等你们的是什么，做好完全心理准备吧!\n接下来我将介绍从刚开始写程序到成为一名工程师，Erik Trautman所归类必经的四个阶段：\n想成为工程师，请做好准备迎接这段必经之路\n先假设你学写程序的终极目标是要靠这行吃饭––进入相关领域工作或是自行创业，你是否做好万全准备可以从你的信心(Confidence)跟能力(Capability)散佈图中看出： 随着你具备的知识跟技能越来越多，你的自信心也会随之而增减，最后达到能力够信心足的「Job Ready」点。在Job Ready前则可以分成四个阶段：\n第一阶段：手牵手心连心蜜月期 刚开始进入程序开发界的朋友们总是怀抱着远大的梦想跟抱负，这不能怪他们，毕竟一方面，大家小时候听多了「写程序很难」、「电脑科学很硬」这种传闻，从一开始就把不少人吓去念社会科学(…没有冒犯社会科学专业人士的意思);另一方面，「全民写程序」这项运动实在太成功，坊间许多工具跟学习平台让程序开发变得超好理解、上手容易，像是Codecademy、Treehouse、跟Code School等线上平台，或是麻省理工的Scratch语言、Google的Blockly等程序语言工具，成功地营造了人人都能写程序而且靠这行吃饭的假象形象。\n突然间我们的问题不再是「困难度」，而是「比天高的期望」跟「比地大的梦想」。\n最重要的是，以上提到的这些工具跟平台实在太有用，带领毫无程序开发经验的初学者们一步步认识变数、条件语句、程序语法。当你一路过关斩将把程序语言基本逻辑跟语法学会的同时，你就会超有成就感、自信心大增，开始有「原来我也行嘛」、「写程序也不过就这样」的感觉，基本上觉得自己已经跟「工程师」相差不远了。 这个阶段将充满喜悦与成就感，在各种线上工具、网络教学的帮助下，你享受着用指尖下指令、电脑就能准确执行的主导感，你赞叹着程序语言的神奇与强大之处，从Hello World到简单回圈，每完成一道练习题你的成就感又增加几分，很多人会在这个时候认为自己已经爱上了电脑科学(而且觉得电脑科学也爱他们)，正处于能力提升，自信心也大增的「蜜月期」，这时你可能会觉得世界真美好、人生大概就会从此飞黄腾达，但我得残酷的告诉你：\n这段旅程才刚开始而已。\n第二阶段：困惑之崖 就跟大部份的情侣/新婚夫妻一样，蜜月期会结束，你会慢慢发现「相爱没这么简单」。\n作业难度一增加(重点是程序码长度也会跟着增加)，程序错误警告就频频出现，开始不停的除错(Debug)。而且通常最大的挑战是––当错误出现时，你根本不知道错在哪里、该问什么问题。你的学习进度在这个阶段开始停滞不前，像路走到一半突然遇到悬崖而无路可走般，开始对之前的认知感到困惑，跟着信心大失。 通常这个阶段会在你完成线上的基础教学后发生。以制作个人网站(Portfolio Website)为例好了，W3 School平台提供了一系列HTML、CSS、JavaScript等网页制作相关的程序教学，让初学者一单元一单元的学习语法跟功能，每单元还有例子示范用法，看似好简单!全部跟着学一遍之后，你准备好动手打造自己的网站，打开文字编辑器，……，然后写没两行就卡关了。\n也许靠Google搜寻可以让你撑到完成网站基本架构，但当你想实现自己的创意、加上个人化的设计时，网络上的回答跟示范总是和你心里所想的不太一样，所以程序码不能全抄，然而左拼右凑出的程序码看似可行但实际上差得可远了!偏偏还不知从何debug起，可能投资了大半的时间程序码还「有减无增」，毫无进展可言。\n这是一个尤其挫折的必经阶段，想成为Programmer就必须经历这个关卡，勇敢跳下悬崖、逼自己展翅高飞(当然在这个阶段摔死的小雏鸟数量十分可观)。\n但即使你消灭了无数的bug，终于完成了几个小专桉后，你也别高兴得太早，未来的路还是非常长远而且挑战性更高!对于想进入这行吃饭的人来说，「困惑之崖」通常是你决定是否全心全意进入这一行的转捩点，而当你投资所有的时间心力在写程序上时，你将进入最让人心灰意冷的第三阶段。\n你可能会很好奇，到底为什么紧紧相连的第一阶段(蜜月期)跟第二阶段(困惑之崖)会差这么多?如果你也正在经历以上两个阶段，你要知道，造成阶段转换的原因跟你一点关係都没有，并不完全是因为你比别人笨或比别人不努力，而是因为「资源密度」改变的缘故。\n因素1：资源密度Resource Density 在第一阶段中有提到，当零经验零基础的你开始学习写程序时，身边有着无数的资源跟工具等着你来运用。到Google搜寻打「Learn to Code」你会查到超多程序学习平台、教学文、教学影片、甚至经验谈，让你感到万分的亲切及温暖，其「手牵手心连心蜜月期」的称谓当之无愧。 然而到了第二阶段时，这些教学资源的数量将大为骤减，任何一个刚脱离初学者的程序学习者都能够证实我此言不假。初学者一开始遇到的障碍都是「一般常见问题」，教学文、教科书里就会注明了;后期由于作业难度以及个人需求，问题才渐渐复杂起来，要从Stack Overflow或是一些程序人的部落格中去找寻解题线索。一直到在你遇到的问题已经棘手到网络上根本找不太到线索的时候，你便进入了下一个阶段。\n第三阶段：绝望沙洲 要了解进入第三阶段的关键，就要了解另一项影响着各阶段变化的重要因素：知识广度。\n因素2：知识广度Scope of Knowledge 「知识广度」也就是度过每个阶段你所必备的知识领域范围。刚开始时你需要吸收的知识很集中，不管用哪种程序语言、不管功能是什么，首先都要学会变数型态、宣告语法、回圈及条件判断式等等，这时随便请一个工程师教你都是一样的，因为「重要须知」就是这几点而已。\n然而学完基本功后，你所需的知识领域会一下子扩展很多，像是开始学习物件导向或是着重演算法的效率，你会需要扎实的电脑科学背景来应付，而且每一个应用都可以牵扯出更多的变化…相信我，这不是几堂MOOC课程就能救得了你的。\n在这个时期，万能的Google也只会丢给你更多你不懂的东西，根本查不到相关的线索!最糟的是你根本不知道你什么不知道。(You don’t know what you don’t know.)。于是「学也学不完、越学越不懂」的无力感排山倒海而来，进入最最难熬的第三阶段––「绝望沙洲」。\n这个阶段顾名思义像是在横越沙漠般，是一段非常长且寂寞的旅程，让你有不知何年何月才能走出来的绝望感。在一望无际的沙漠里，根本搞不清楚东西南北，资料查了半天毫无斩获，还不时被海市蜃楼(错误资讯或看似可行的解决方桉)给误导，搞得灰头土脸、头昏眼花，在这个阶段晒死、渴死、绝望死的有为青年更是不计其数。 但只要在绝望沙洲里熬下去，接下来就会自在许多了!累积足够的经验，程序的错误就会大量减少、达到一定知识水准，就能准确判断问题的方向切入核心，工作效率因而有所增进，知识广度也会慢慢聚焦。等你拖着一身的疲惫终于走出这荒漠时，就进入了最后的阶段。\n第四阶段：创伤后的恢复期 踩着千万人的尸体成功横越了沙漠，你的自信心开始回升，Google功力也可以说是神人的等级。到了这个时候，Hacker News的新闻以及超硬的MOOC课程都不成问题，你也选定了某个程序语言跟框架来专研，而且有能力制作出可以正常运作的应用程序了。\n但你心里深处总有着隐隐的不安，觉得程序能「用」但其实代码凌乱无章，工程师的头衔下其实是误打误撞进这行的半调子，虽然你似乎具备了一切就职条件，却总害怕面试官发现你根基薄弱的电脑知识…你正在经历「创伤后的恢复期」。\n在飞越困惑之崖、横越绝望沙洲之后，你应该已经学会该学的、做了该做的，成为一个名符其实的工程师，却总觉得自已资质平庸根基不稳，虽然有成功打造出一个个专案而信心回升，但老是感叹自己与心目中「专业工程师」仍有一大段差距…，这些都是「冒牌者症候群」(Impostor Syndrome)在作祟! 在这创伤后的恢复期中，你可能会经常自我怀疑，但只要顺着这波效率提升信心也回升的潮流继续努力，在能力与自信达到一个程度时…恭喜你：You Are Job Ready!\n 来源：inside 作者：Jewel  ","title":"为什么成为一名程序员这么难？"},{"link":"https://blog.policx.com/posts/macbook/","text":"2015年1月14日\n微软雷德蒙德公司总部，这里即将召开一场关于 WIN10 系统的发布会。然而微软新任CEO 萨蒂亚·纳德拉 却铁青着脸望向台下。 毕竟，几乎被淹没在媒体记者身前各种各样发光苹果 Logo 之中的微软发布会，俨然成为了一个免费的苹果广告。\nMacBook 系列笔记本之所以成为办公人士的心头宠，除了极具科技和美感的设计，主流的硬件配置之外，高效的 Mac OS X 系统才是提高生产力的关键所在。\nOption + Shift + 调节音量亮度 mac通过音量键或者亮度键就可以简单快速的调节，但是每次一大格一跳，两者之间跨度对某些场景来说还是间隔有些大，比如在静音环境的时候想要稍微开一些音量却不想影响他人，此时你可以试试按住Option + Shift然后配合音量键，你会惊奇的发现，音量亮度会以1/4格的差距进行调节 调整窗口大小 调整窗口大小的同时按住Option + Shift键将会使整个事物一次成比例地增长和缩小。的同时按住Option + Shift键将会使整个事物一次成比例地增长和缩小。 电源提示音  激活的方法很简单:   打开应用程序 - 实用工具 - 终端.\n  输入如下的命令:  defaults write com.apple.PowerChime ChimeOnAllHardware -bool true; open /System/Library/CoreServices/PowerChime.app \u0026amp; 然后回车, 再试试充电是不是就有提示音了?\n 如果你不喜欢日后也可以取消命令行如下  defaults write com.apple.PowerChime ChimeOnAllHardware -bool false;killall PowerChime 关闭任务  Command + Option + Escape\n 使用这个技巧会比自己在每个麻烦的应用程序上右击更快。\nLaunchpad中不显示App图标  在终端重启Launchpad  第一步 rm ~/Library/Application\\ Support/Dock/*.db 第二步 killall Dock\nOK。\nmac Zip 加密  最通俗的用法  zip -q -r -e -m -o [yourName].zip someThing  -q 表示不显示压缩进度状态\n  -r 表示子目录子文件全部压缩为zip //这部比较重要，不然的话只有something这个文件夹被压缩，里面的没有被压缩进去\n  -e 表示你的压缩文件需要加密，终端会提示你输入密码的\n  // 还有种加密方法，这种是直接在命令行里做的，比如zip -r -P Password01! modudu.zip SomeDir, 就直接用Password01!来加密modudu.zip了。\n  -m 表示压缩完删除原文件\n  -o 表示设置所有被压缩文件的最后修改时间为当前压缩时间\n  当跨目录的时候是这么操作的  zip -q -r -e -m -o '\\user\\someone\\someDir\\someFile.zip' '\\users\\someDir' 截图 Command + Shift + 3 捕捉整个屏幕。 Command + Shift + 4 将捕获显示的自定义部分。\n分割视图布局 Split Screen分屏功能 这依旧是一条提升生产力的功能，习惯一个屏打开IDEA，另外一个开着Google，对于没有外接显示器来说我们可以使用Mac自带的分屏来实现（有的软件可能不支持）\n使用方法:\n 左键按住一个程序左上方绿色最大化按钮不动，这时会让你选择当前选中App会出现在哪一边，可以是左边也可以是右边，排好之后再点击另一个App就会出现在另一侧，这样一来，同一屏幕中就同时有了两个App的界面。中间有一条分隔线，拖动分割线可以重新划分左右的区域大小，可以让你的注意力更集中在某一方面    Xcode 和模拟器分屏需要在终端实现以下命令  defaults write com.apple.iphonesimulator AllowFullscreenMode -bool YES  选项卡或窗口之间切换 不使用鼠标的情况下在选项卡或窗口之间切换。 在不同应用程序之间切换：Command + Tab 在相同应用程序的多个窗口之间切换：Command + ~\n要在同一个浏览器窗口中切换标签，实际上有两种方法：\n  Command + Option +前进/后退箭头\n  Control + Tab通过标签向前移动，Control + Tab + Shift向后移动标签。\n  去格式粘贴 复制文本内容的时候经常会带格式（字号、颜色、字体，有时候还有看不见的代码），手动调整会很麻烦，\n使用方法：\n Command+C\nCommand+V \u0026ndash;\u0026gt; Command + Shift + option + V\n 通过以上方法就能快速的丢弃原有的格式属性，使其与当前文本格式保持一致\n 3、应用程序“接力” 例：“电脑上复制，手机上粘贴”的通用剪贴板，是不是很NB\n 条件：\n1、所有设备均使用同一 Apple ID 登录 iCloud\n2、所有设备均已开启蓝牙\n3、所有设备均已开启 Wi-Fi\n   打开接力\n手机：设置\u0026ndash;\u0026gt;通用\u0026ndash;\u0026gt;接力    MAC：系统偏好设置\u0026ndash;\u0026gt; 通用 \u0026ndash;\u0026gt; 允许在这台Mac和iClould设备之间使用“接力”     打开iCloud   手机打开iCloud：设置\u0026ndash;\u0026gt;头像\u0026ndash;\u0026gt;iCloud   电脑打开iCloud：系统偏好设置\u0026ndash;\u0026gt; iCloud      ","title":"Mac 技巧"},{"link":"https://blog.policx.com/posts/2015/","text":"I think the greatest value of learning how to think\u0026hellip;. I think everybody in this country should learn how to program a computer, should learn a computer language, because it teaches you how to think, it’s like going to law school, I don’t think anybody should be a lawyer, but I think going to law school may actually be useful coz it teaches you how to think in a certain way. In the same way the computer programming teaches you in a slightly different way how to think\u0026hellip; And so … I view computer science as a liberal art. It should be something everybody takes in a year in their life, one of the courses they take is, you know learning how to program. \u0026mdash;\u0026mdash;\u0026ndash; Steve Jobs\n我认为学习思考最大的价值在于\u0026hellip; 我觉得所有美国人都应该学习编程，学习一门编程语言，学习编程教你如何思考，就像学法律一样，学法律的人未必都成为律师，但法律教你一种思考方式。同样编程会教你另一种思考方式，所以我把计算机科学看成基础教育，是每个人都应该花一年时间学习的课程。 \u0026mdash;\u0026mdash;\u0026ndash; 史蒂夫·乔布斯\n","title":"WWDC 2015"},{"link":"https://blog.policx.com/posts/centos/","text":"   Step 1、为centos配置rpmforge及epel源。centos官方的源其实也够用，不过像php的一些扩展如 php-mcrypt在官方源中并没有。 rpm -ivh https://pkgs.repoforge.org/rpmforge-release/rpmforge-release-0.5.3- 1.el7.rf.x86_64.rpm rpm -ivh https://mirrors.ustc.edu.cn/centos/6.5/extras/x86_64/Packages/epel- release-6-8.noarch.rpm rpm -ivh https://mirrors.163.com/centos/7/extras/x86_64/Packages/epel-release- 7-2.noarch.rpm Step 2. 安装php/mysql/httpd 安装apache yum -y install httpd httpd-devel\n安装mysql yum -y install mysql mysql-devel mysql-server mysql-libs\n安装php yum -y install php\n安装php扩展 yum -y install php-mysql php-gd php-imap php-ldap php-odbc php-mbstring php- devel php-soap php-cli php-pdo yum -y install php-mcrypt php-tidy php-xml php-xmlrpc php-pear 其它不常用php扩展, www.linuxidc.com 可不用安装 yum -y install php-pecl-memcache php-eaccelerator\n安装phpmyadmin yum -y install phpmyadmin\n安装完成之后，启动 service httpd start service mysqld start Step 3.配置httpd、mysqld开机自启动 chkconfig mysqld on chkconfig httpd on Step 4.配置phpmyadmin 修改/usr/share/phpmyadmin/config.inc.php 将这里abcde文字修改为自己的字符，可任意 $cfg['blowfish_secret'] = 'abcde';\n常见问题 1. phpmyadmin提示未开启php-mcrypt,这是因为没有安装php-mrcrpt扩展。在官方源没有php-mrcrpt扩展，请安装epel源后再 yum install php-mcrypt\n2. phpmyadmin无法访问 phpmyadmin默认只能使用 https://localhost/phpmyadmin 来访问， 可以修改/etc/httpd/conf.d/phpmyadmin.conf中对应部分为\n\u0026lt;Directory \u0026quot;/usr/share/phpmyadmin\u0026quot;\u0026gt; Order Deny,Allow Deny from all Allow from All \u0026lt;/Directory\u0026gt; 不过强烈不支持这么做的，把phpmyadmin暴露了不安全 注意： apache解析php，修改httpd.conf文件，添加\nAddtype application/x-httpd-php .php .phtml Addtype application/x-httpd-php-source .phps myql可以远程登录 设置mysql密码\nmysql\u0026gt;; USE mysql; mysql\u0026gt;; UPDATE user SET Password=PASSWORD('newpassword') WHERE user='root'; mysql\u0026gt;; FLUSH PRIVILEGES; 1.2.3 允许远程登录\nmysql -u root -p Enter Password: \u0026lt;your new password\u0026gt; mysql\u0026gt;GRANT ALL PRIVILEGES ON *.* TO '用户名'@'%' IDENTIFIED BY '密码' WITH GRANT OPTION; 完成后就能用mysql-front远程管理mysql了。 设为开机启动 chkconfig mysqld on\n","title":"centos 6.5 网站建设"},{"link":"https://blog.policx.com/posts/juanshi/","text":"告别工作多年的公司，我要去新的地方了。\n","title":"告别"},{"link":"https://blog.policx.com/posts/xiaomi/","text":"   昨天，接到了小米的电话，这个刚刚满二十岁小伙子说自己有些感到孤单，我半开玩笑的说：去谈恋爱吧。 二十岁，一个多少人羡慕的年龄，我在二十岁的时候，还在象牙塔中读书，小米已然工作了一年。话语中他流露出与社会间的不完全融入，苦了他了。 惭愧的是我写下这段文字的时候，我并没有能够给他足够的可行性建议，更多的是一个倾听者。 我感谢他能在不如意的时候想到我，\n","title":"小米"},{"link":"https://blog.policx.com/posts/sjz/","text":"再次来到这座城，当火车到达车站的时候，我才意识到我很久没有来过了。火车站具体的位置没有弄清楚，但是真的很气派的建筑，恍惚间以为是北京南站。市内公交（至少我坐的那路）比北京的要好，或许是新车的原因。晚饭和面对一桌的初次见面的人，我抿了十分之一杯白酒，却感觉晕乎乎的。此刻躺在宾馆的床上，微困。\n","title":"石家庄"},{"link":"https://blog.policx.com/posts/wjx/","text":"1803的望京西，雨后的残云裹着斜阳，我眯着疲惫的双眼，抿嘴微笑，略带凉意的风吹过，此刻，就想这么走，一直走，走很久很久！\n","title":"1803的望京西"},{"link":"https://blog.policx.com/posts/ios-neicun/","text":"   一：写在前面 请使用ARC！！！\n如果使用的第三方库不支持ARC机制，可以在target-\u0026gt;build phase-\u0026gt;compile sources中选择对应的源码文件并在气候加入-fno-objc-arc标示，如下图所示： 如果你的应用对内存泄露比较敏感(长时间运行或者耗费较多内存),或者你对代码有洁癖无法忍受半点内存泄露，而你又没有大把的时间和精力取修复那些虚无缥缈的泄漏点，那么ARC将是你最好的选择，因为修复泄露bug实在是太坑爹了\u0026hellip; 如果你不习惯ARC，又或者你使用的SDK版本根本不支持ARC，那么，请看下文。\n二：修复方法 好，言归正传。\n按我个人理解，修复内存泄露可分为三个阶段：\n第一阶段：编码 好的编码习惯可以杜绝大部分的内存泄露，具体操作规范可参见我的另一篇博客iOS编程内存管理小结，这也是杜绝内存泄露的最关键阶段。在本阶段多花一些力气放在精确的内存管理上，你将会在调试阶段节省下大把的用于修复泄露的时间与精力。所谓：磨刀不误砍柴工！\n第二阶段：静态分析 说白了，静态分析就是使用Xcode自带的Analyze功能（Product-\u0026gt; Analyze），对代码进行静态分析，对于内存泄露（Potential Memory Leak）, 未使用局部变量(dead store)，逻辑错误(Logic Flaws)以及API使用问题(API-usage)等明确的展示出来，如下图所示： dead store比较好处理，将从未使用的变量删掉即可。\nMemory Leak的提示其实也比较好办，因为其提示已经足够详细，具体到了具体泄露的代码行。找到问题对症下药即可, 忘记release 的加上release，该放autorelease的地方加上auto release。有一个情况需要特别说明一下，见下面所示代码：\n[cpp] view plaincopy \u0026lt;span style=\u0026quot;font-size:12px;\u0026quot;\u0026gt;if （self.dataMember == nil) { self.dataMember = [[NSArray alloc] init]; }\u0026lt;/span\u0026gt; 这段代码在Analyze的时候也提示有内存泄露，开始我没看出来，后来才发现，等号右边的临时变量却是是泄露了的。正确的写法应该如下所示：\n[cpp] view plaincopy \u0026lt;span style=\u0026quot;font-size:12px;\u0026quot;\u0026gt;if (self.dataMember == nil) { self.dataMember = [[[NSArray alloc] init] autorelease]; //或者\nNSArray* temp = [[NSArray alloc] init]; self.dataMember = temp; [temp release]; }\u0026lt;/span\u0026gt; 我比较倾向于第二种写法，到处autorelease对内存占用和性能肯定会有多多少少的影响的。\n使用Analyze找到的内存泄露点基本还是准确的，但比较坑人的是Anayze并不能找出所用的泄露点，即使某些极为明显的泄露点使用Analyze也无法分析出来。这时就需要终极大杀器：Instruments登场了。\n第三阶段：动态分析 Instruments是Xcode自带的一个强大的应用分析工具，其功能并不局限于内存泄露的分析上，内存占用、CPU使用率等都是其分析的对象，有兴趣的筒子可以仔细研究研究，对提高应用的质量大有益处。\n使用Instruments分析内存泄露时，最好使用真机进行调试，笔者就碰到过同一份代码在模拟器上分析有泄露而实体机上就没有的情况，看来不同的CPU架构(x86 vs ARM)对内存的管理还是有一定影响的。\n连接实体机到开发机，选择选择运行设备为设备，点击Products-\u0026gt; Profile，经过编译后，会弹出如下对话框： 双击Leak, 进入如下界面： 上面的蓝色条状部分是内存占用情况，而下面的便是内存泄露情况，当下面的状态栏出现粉色条状物体时，恭喜你，泄露出现了\u0026hellip; 如果运气比较好的话，下面的提示区域会明确的告诉你那个文件哪个函数有泄露出现，但\u0026hellip;很多情况下，出现的只是下面这种无厘头的提示： 这是要闹那样\u0026hellip;\n当然，上面图中所示的为5.1.1系统中的一个bug，在tableview滚动的过程中会出现一些莫名其妙的泄露点，同样的代码在5.0.1中并不会出现上面的泄露问题。\n但这种很难找到泄露根源的问题会很多，寻找这些问题需要耗费大量的时间与精力。\n修复泄露有下面两种处理方法：\nA: 对于那些非常明显的提示，很简单，按图索骥，根据提示的代码文件函数和泄露的对象类型判断泄露类型进行修复。\nB: 对于那些不是很明显的提示，例如提示的泄漏点是一个第三方的库或者某个lib，那么这时就需要回忆一下刚才什么操作之后导致了泄露，然后找到与刚刚的操作相关的代码，在分析泄露的类型，例如是NSString或者NSArray，根据泄露的数据类型来推测具体泄露的代码段。这需要那么一点点的灵感和运气\u0026hellip;\n三：总结 以我亲身精力来说，调泄露是很烦的一件事，花在上面的时间可能要比你预想的多得多。\n所以，正如前面提到的，要么在编码过程中提高内存控制的精确性，要么就一劳永逸，直接使用ARC，要泄露去屎吧！\n","title":"iOS开发内存泄露修复"},{"link":"https://blog.policx.com/posts/iphone/","text":"故事的开始 ","title":"iPhone"},{"link":"https://blog.policx.com/posts/kindle/","text":"酒仙桥到立水桥的距离，一辆公交车。至此时此刻，我已经在上下班的路上看过三本书了，它们是《幸福了吗》《看见》《拖延心理学》和《美国记忆冠军》。我很庆幸没有浪费这段宝贵的时光，同时我也在思考，他们给了我一些什么？我又是否体现了它们的价值？看书不记书的我，还得要斥责自己呐，我享受这车上的时光，不觉得时间流淌。还是要去记一点吧，白岩松的《幸福了吗》我记忆深刻的是九一一后一段故事，作者当时作为媒体人一种敏感。\n","title":"读书"},{"link":"https://blog.policx.com/posts/training/","text":" 入职培训\n ","title":"培训"},{"link":"https://blog.policx.com/posts/2012/","text":"2012 一切都还好。\n 世界未末日 作词：方文山 作曲：周杰伦 演唱：周杰伦\n 这街道在下陷 我们就快失去了家园 你我却都没有埋怨 将眼泪停格瞬间 街景摧毁 我内心却不轻易撤退 满天风雪 我们会微笑去面对 我牵着你的手 一路穿梭在城市路口 就算故事到了尽头 我们也绝不退缩 快转风景 被一再提醒失去森林 落叶声音 停不住我们的关心 就算是世界要崩溃 亲爱的我也绝不会落泪 不放弃爱过的那种感觉 珍惜着有你记忆的一切 就算是世界要倾斜 亲爱的我也绝不说离别 尽管末日威胁再强烈 有爱就不累 我牵着你的手 一路穿梭在城市路口 就算故事到了尽头 我们也绝不退缩 快转风景 被一再提醒失去森林 落叶声音 停不住我们的关心 就算是世界要崩溃 亲爱的我也绝不会落泪 不放弃爱过的那种感觉 珍惜着有你记忆的一切 就算是世界要倾斜 亲爱的我也绝不说离别 尽管末日威胁再强烈 有爱就不累\n ","title":"2012"},{"link":"https://blog.policx.com/posts/2011start/","text":"故事的开始\n 歌曲：启程 作词\\作曲：卢庚戌 演唱：水木年华 编曲：卢梁博 录音师：郝宇 混音师：颜仲坤 和声编配：缪杰 和声：缪杰 哈达 吉他：李延亮 班卓琴：李延亮 贝斯：韩阳 鼓：刁磊\n 向过去的悲伤说再见吧 还是好好珍惜现在吧 你寻求的幸福 其实不在远处 它就是你现在 一直走的路 就在启程的时刻 让我为你唱首歌 孤独时候要记得想起我 等到相遇的时刻 我们再唱这首歌 就像我们从未曾离别过 不管怎样的时刻 请你记住这首歌 记住我们的坚持从未变过 未来怎样的时刻 请你记住这首歌 记住我们的梦想从未变过 记住我们的梦想从未变过 记住我们的梦想从未变过\n ","title":"启程"}],"tags":[{"link":"https://blog.policx.com/tags/django/","name":"Django","slug":"Django"},{"link":"https://blog.policx.com/tags/git/","name":"git","slug":"git"},{"link":"https://blog.policx.com/tags/linux/","name":"Linux","slug":"Linux"},{"link":"https://blog.policx.com/tags/markdown/","name":"Markdown","slug":"Markdown"},{"link":"https://blog.policx.com/tags/program/","name":"program","slug":"program"},{"link":"https://blog.policx.com/tags/python/","name":"Python","slug":"Python"},{"link":"https://blog.policx.com/tags/wwdc/","name":"wwdc","slug":"wwdc"},{"link":"https://blog.policx.com/tags/%E5%96%84%E7%94%A8%E4%BD%B3%E8%BD%AF/","name":"善用佳软","slug":"善用佳软"}]}